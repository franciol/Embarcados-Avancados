{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bem vindo a Eletiva - SoC e Linux Embarcado! \u00b6 2020-2 Material revisado Disciplina: Eletiva da Engenharia da Computa\u00e7\u00e3o Vers\u00f5es: 2018b/ 2019b / 2020 Prof. Rafael Corsi / rafael.corsi@insper.edu.br Reposit\u00f3rio: http:/github.com/insper/Embarcados-Avancados Local: Laborat\u00f3rio de Arquitetura de Computadores \u00a9 Todos os direitos reservados OBJETIVOS: \u00b6 Formular solu\u00e7\u00f5es que satisfazem requisitos de hardware e software de projetos com FPGA-SoC (System-on-a-chip) Integrar em um prot\u00f3tipo solu\u00e7\u00e3o para um sistema embarcado com requisitos de processamento e/ou tempo real via FPGA-SoC Interfacear diferentes m\u00f3dulos em um sistema embarcado (processadores, firmware e sistema operacional) Metodologia \u00b6 A disciplina \u00e9 baseada em tutoriais, onde os conceitos te\u00f3ricos e pr\u00e1ticos s\u00e3o apresentados. O aluno deve seguir o material conforme \u00e9 apresentado (na sequ\u00eancia) pois o mesmo foi concebido de maneira incremental. Cada tutorial (ou s\u00e9rie de) possui uma entrega (APS) que deve ser realizada, o tutorial \u00e9 ponto de entrada para a entrega, por\u00e9m vai al\u00e9m em compreens\u00e3o e conceitos. Avalia\u00e7\u00e3o \u00b6 A avalia\u00e7\u00e3o \u00e9 composta de entregas ao longo do semestre (a cada s\u00e9rie de tutoriais existe uma entrega com nota) e de um tutorial que deve ser criado ao longo da disciplina e integrado na p\u00e1gina do curso. O tutorial \u00e9 de tema livre dentro dos objetivos da disciplina e possui algumas entregas intermedi\u00e1rias que ir\u00e3o compor a nota final. Motiva\u00e7\u00e3o \u00b6 O que \u00e9 um System On Chip (SoC) ? Quem s\u00e3o os principal fabricantes de SoC? Samsung / Qualcomm / Xilinx / Intel FPGA \u00c1reas / Aplica\u00e7\u00f5es: macbook pro / aws f1 / Intel 1 / Intel 2 / xilinx Qual a diferen\u00e7a entre Soft-Processor e um HardProcessor? x86 + FPGA ? Empregos? A qual desses voc\u00ea se aplicaria ? facebook / google / apple / microsoft / amazon Como usar o hardware a servi\u00e7o do software? HLS / OpenCL Infraestrutura \u00b6 Para facilitar o andamento do curso, estamos enviando um SSD com os softwares listados aqui . Iremos com o kit DE10-Standard . Din\u00e2mica \u00b6 A disciplina \u00e9 baseada em uma s\u00e9rie de tutoriais (com entregas ao final) que come\u00e7a a partir de um simples hardware na FPGA para controlar LEDs da placa e chega at\u00e9 a execu\u00e7\u00e3o de um sistema Linux com interface gr\u00e1fica e co-processamento em um sistema embarcado. Bibliografia \u00b6 B\u00e1sica [HALLINAN, 2007] HALLINAN, C. Embedded Linux primer: a practical, real-world approach. Pearson Education India, 2007. [DESCHAMPS, 2012] DESCHAMPS, J. P.; SUTTER, G. D.; CANT\u00d3 E. Guide to FPGA implementation of arithmetic functions. Springer Science & Business Media; 2012, Apr 5. [CHU, 2011] CHU, PONG P. Embedded SoPC design with Nios II processor and VHDL examples. John Wiley & Sons, 2011. Complementar [SASS, 2010] SASS, R., SCHMIDT, A.G.; Embedded Systems Design with Platform FPGAs: Principles and Practices. Elsevier, 2010. [BOVET, 2005] Bovet, Daniel P., and Marco Cesati. Understanding the Linux Kernel: from I/O ports to process management. \" O'Reilly Media, Inc.\", 2005. [SIMPSON, 2015] Simpson, Philip Andrew; FPGA Design: Best Practices for Team-based Reuse 2 nd ed. Springer, 2015 Edition. [KOOPMAN, 2010] Koopman, Philip. Better Embedded System Software. Drumnadrochit Education, 2010. [VENKATESWARAN, 2008] Venkateswaran, Sreekrishnan. Essential Linux device drivers. Prentice Hall Press, 2008. Para come\u00e7ar \u00b6 Trazer os softwares instalados Criar um reposit\u00f3rio no github Pensar um pouco sobre um tema que gostaria de se aprofundar (para o tutorial) Dicas Leitura recomendada: https://www.intel.com/content/www/us/en/products/programmable/fpga/new-to-fpgas/resource-center/overview.html Dispon\u00edvel no lab: [CHU, 2011, cap. 1], [KOOPMAN, 2010, cap. 2] Nunca mexeu com FPGA? VHDL introdu\u00e7\u00e3o v\u00eddeo livro fpgas for dummie","title":"Home"},{"location":"#bem-vindo-a-eletiva-soc-e-linux-embarcado","text":"2020-2 Material revisado Disciplina: Eletiva da Engenharia da Computa\u00e7\u00e3o Vers\u00f5es: 2018b/ 2019b / 2020 Prof. Rafael Corsi / rafael.corsi@insper.edu.br Reposit\u00f3rio: http:/github.com/insper/Embarcados-Avancados Local: Laborat\u00f3rio de Arquitetura de Computadores \u00a9 Todos os direitos reservados","title":"Bem vindo a Eletiva - SoC e Linux Embarcado!"},{"location":"#objetivos","text":"Formular solu\u00e7\u00f5es que satisfazem requisitos de hardware e software de projetos com FPGA-SoC (System-on-a-chip) Integrar em um prot\u00f3tipo solu\u00e7\u00e3o para um sistema embarcado com requisitos de processamento e/ou tempo real via FPGA-SoC Interfacear diferentes m\u00f3dulos em um sistema embarcado (processadores, firmware e sistema operacional)","title":"OBJETIVOS:"},{"location":"#metodologia","text":"A disciplina \u00e9 baseada em tutoriais, onde os conceitos te\u00f3ricos e pr\u00e1ticos s\u00e3o apresentados. O aluno deve seguir o material conforme \u00e9 apresentado (na sequ\u00eancia) pois o mesmo foi concebido de maneira incremental. Cada tutorial (ou s\u00e9rie de) possui uma entrega (APS) que deve ser realizada, o tutorial \u00e9 ponto de entrada para a entrega, por\u00e9m vai al\u00e9m em compreens\u00e3o e conceitos.","title":"Metodologia"},{"location":"#avaliacao","text":"A avalia\u00e7\u00e3o \u00e9 composta de entregas ao longo do semestre (a cada s\u00e9rie de tutoriais existe uma entrega com nota) e de um tutorial que deve ser criado ao longo da disciplina e integrado na p\u00e1gina do curso. O tutorial \u00e9 de tema livre dentro dos objetivos da disciplina e possui algumas entregas intermedi\u00e1rias que ir\u00e3o compor a nota final.","title":"Avalia\u00e7\u00e3o"},{"location":"#motivacao","text":"O que \u00e9 um System On Chip (SoC) ? Quem s\u00e3o os principal fabricantes de SoC? Samsung / Qualcomm / Xilinx / Intel FPGA \u00c1reas / Aplica\u00e7\u00f5es: macbook pro / aws f1 / Intel 1 / Intel 2 / xilinx Qual a diferen\u00e7a entre Soft-Processor e um HardProcessor? x86 + FPGA ? Empregos? A qual desses voc\u00ea se aplicaria ? facebook / google / apple / microsoft / amazon Como usar o hardware a servi\u00e7o do software? HLS / OpenCL","title":"Motiva\u00e7\u00e3o"},{"location":"#infraestrutura","text":"Para facilitar o andamento do curso, estamos enviando um SSD com os softwares listados aqui . Iremos com o kit DE10-Standard .","title":"Infraestrutura"},{"location":"#dinamica","text":"A disciplina \u00e9 baseada em uma s\u00e9rie de tutoriais (com entregas ao final) que come\u00e7a a partir de um simples hardware na FPGA para controlar LEDs da placa e chega at\u00e9 a execu\u00e7\u00e3o de um sistema Linux com interface gr\u00e1fica e co-processamento em um sistema embarcado.","title":"Din\u00e2mica"},{"location":"#bibliografia","text":"B\u00e1sica [HALLINAN, 2007] HALLINAN, C. Embedded Linux primer: a practical, real-world approach. Pearson Education India, 2007. [DESCHAMPS, 2012] DESCHAMPS, J. P.; SUTTER, G. D.; CANT\u00d3 E. Guide to FPGA implementation of arithmetic functions. Springer Science & Business Media; 2012, Apr 5. [CHU, 2011] CHU, PONG P. Embedded SoPC design with Nios II processor and VHDL examples. John Wiley & Sons, 2011. Complementar [SASS, 2010] SASS, R., SCHMIDT, A.G.; Embedded Systems Design with Platform FPGAs: Principles and Practices. Elsevier, 2010. [BOVET, 2005] Bovet, Daniel P., and Marco Cesati. Understanding the Linux Kernel: from I/O ports to process management. \" O'Reilly Media, Inc.\", 2005. [SIMPSON, 2015] Simpson, Philip Andrew; FPGA Design: Best Practices for Team-based Reuse 2 nd ed. Springer, 2015 Edition. [KOOPMAN, 2010] Koopman, Philip. Better Embedded System Software. Drumnadrochit Education, 2010. [VENKATESWARAN, 2008] Venkateswaran, Sreekrishnan. Essential Linux device drivers. Prentice Hall Press, 2008.","title":"Bibliografia"},{"location":"#para-comecar","text":"Trazer os softwares instalados Criar um reposit\u00f3rio no github Pensar um pouco sobre um tema que gostaria de se aprofundar (para o tutorial) Dicas Leitura recomendada: https://www.intel.com/content/www/us/en/products/programmable/fpga/new-to-fpgas/resource-center/overview.html Dispon\u00edvel no lab: [CHU, 2011, cap. 1], [KOOPMAN, 2010, cap. 2] Nunca mexeu com FPGA? VHDL introdu\u00e7\u00e3o v\u00eddeo livro fpgas for dummie","title":"Para come\u00e7ar"},{"location":"Atividades/","text":"Atividades \u00b6","title":"Atividades"},{"location":"Atividades/#atividades","text":"","title":"Atividades"},{"location":"Entrega-1/","text":"\ud83d\udc41 Entrega 1 \u00b6 2020-2 Material atualizado. O que deve ser entregue? Pasta: Entrega_1_FPGA_RTL V\u00eddeo do projeto funcionando com uma explica\u00e7\u00e3o (curto!) A ideia dessa entrega \u00e9 que voc\u00eas trabalhem um pouco mais com o VHDL e que tamb\u00e9m relembrem/aprendem como desenvolver um projeto de forma hier\u00e1rquica. Nessa entrega voc\u00eas ir\u00e3o desenvolver um IP core ( intellectual property core ) dedicado para o controle de um motor de passos. Esse componente deve controlar as quatro fases de um motor de passos (voc\u00eas receberam junto ao kit) de forma a girar o motor nos dois sentidos e com algumas velocidades diferentes. Cheguei Aqui! Exemplo \u00b6 Para facilitar o desenvolvimento est\u00e1 dispon\u00edvel na pasta ( /Entrega1/ ) no reposit\u00f3rio da disciplina um projeto e um componente que controla o motor de passos, mas n\u00e3o realiza tudo o que est\u00e1 sendo pedido aqui. Nesse exemplo o motor de passos gira apenas para um sentido ( DIR n\u00e3o funciona), o sinal de EN n\u00e3o controla se o motor vai estar ligado/desligar e o motor possui apenas duas velocidades ( VEL ). Os pinos j\u00e1 foram mapeados e voc\u00eas devem conectar o motor como indicado a seguir! Warning Fa\u00e7a com aten\u00e7\u00e3o para evitar queimar a placa. Montagem final: Clique para ampliar GPIO esquem\u00e1tico Extra\u00eddo do manual: TODO Ap\u00f3s montar, abra o projeto exemplo, compile e grave na FPGA. Voc\u00ea deve ver o motor girando. Mexa nas chaves 2 e 3, a velocidade do motor deve variar. Rubrica \u00b6 Entrega - google forms Loading\u2026 A aplica uma curva de acelera\u00e7\u00e3o na velocidade. B possuir n\u00famero de passos a serem executados. C aciona o motor de passos e possui um sinal de: EN (que liga e desliga o motor) DIR (que controla a dire\u00e7\u00e3o na qual o motor gira) VEL[1:0] (quatro velocidades de rota\u00e7\u00e3o) D Entregou o tutorial I N\u00e3o entregou nada","title":"\ud83d\udc41 Entrega 1"},{"location":"Entrega-1/#entrega-1","text":"2020-2 Material atualizado. O que deve ser entregue? Pasta: Entrega_1_FPGA_RTL V\u00eddeo do projeto funcionando com uma explica\u00e7\u00e3o (curto!) A ideia dessa entrega \u00e9 que voc\u00eas trabalhem um pouco mais com o VHDL e que tamb\u00e9m relembrem/aprendem como desenvolver um projeto de forma hier\u00e1rquica. Nessa entrega voc\u00eas ir\u00e3o desenvolver um IP core ( intellectual property core ) dedicado para o controle de um motor de passos. Esse componente deve controlar as quatro fases de um motor de passos (voc\u00eas receberam junto ao kit) de forma a girar o motor nos dois sentidos e com algumas velocidades diferentes. Cheguei Aqui!","title":"\ud83d\udc41 Entrega 1"},{"location":"Entrega-1/#exemplo","text":"Para facilitar o desenvolvimento est\u00e1 dispon\u00edvel na pasta ( /Entrega1/ ) no reposit\u00f3rio da disciplina um projeto e um componente que controla o motor de passos, mas n\u00e3o realiza tudo o que est\u00e1 sendo pedido aqui. Nesse exemplo o motor de passos gira apenas para um sentido ( DIR n\u00e3o funciona), o sinal de EN n\u00e3o controla se o motor vai estar ligado/desligar e o motor possui apenas duas velocidades ( VEL ). Os pinos j\u00e1 foram mapeados e voc\u00eas devem conectar o motor como indicado a seguir! Warning Fa\u00e7a com aten\u00e7\u00e3o para evitar queimar a placa. Montagem final: Clique para ampliar GPIO esquem\u00e1tico Extra\u00eddo do manual: TODO Ap\u00f3s montar, abra o projeto exemplo, compile e grave na FPGA. Voc\u00ea deve ver o motor girando. Mexa nas chaves 2 e 3, a velocidade do motor deve variar.","title":"Exemplo"},{"location":"Entrega-1/#rubrica","text":"Entrega - google forms Loading\u2026 A aplica uma curva de acelera\u00e7\u00e3o na velocidade. B possuir n\u00famero de passos a serem executados. C aciona o motor de passos e possui um sinal de: EN (que liga e desliga o motor) DIR (que controla a dire\u00e7\u00e3o na qual o motor gira) VEL[1:0] (quatro velocidades de rota\u00e7\u00e3o) D Entregou o tutorial I N\u00e3o entregou nada","title":"Rubrica"},{"location":"Entrega-2/","text":"\ud83d\udc41 Entrega 2 \u00b6 Success Revisado 2020-2 O que deve ser entregue? Pasta: Entrega_2_FPGA_NIOS V\u00eddeo do projeto funcionando com uma explica\u00e7\u00e3o (aprox 1.5 min) Nessa entrega iremos ter a mesma funcionalidade que a Entrega 1 por\u00e9m com o motor sendo acionado pelo NIOS (soft processor). Para isso ser\u00e1 necess\u00e1rio modificar o projeto criado no tutorial para possuir ao menos mais um perif\u00e9rico PIO (que ser\u00e1 respons\u00e1vel por ler os bot\u00f5es). Al\u00e9m de adicionar esse novo perif\u00e9rico, nessa entrega iremos aprimorar nosso sistema com: Perif\u00e9rico JTAG deve gerar interrup\u00e7\u00e3o Perif\u00e9rico PIO que lida com o bot\u00e3o deve gerar interrup\u00e7\u00e3o Mem\u00f3ria de programa separada da de dados Uma vez que o JTAG come\u00e7a a gerar interrup\u00e7\u00f5es n\u00e3o ser\u00e1 mais necess\u00e1rio usar o small driver do JTAG, lembre de alterar isso no bsp . Comece por ler os bot\u00f5es sem interrup\u00e7\u00e3o, uma vez que estiver funcionando, utilize os sites a seguir como refer\u00eancia para implementar interrup\u00e7\u00e3o no NIOS: Dicas: http://www.johnloomis.org/NiosII/interrupts/interrupt/interrupt.html https://www.altera.com/en_US/pdfs/literature/hb/nios2/n2sw_nii52006.pdf Rubrica \u00b6 Entrega - google forms Loading\u2026 A Insira um RTOS no NIOS para fazer o controle da aplica\u00e7\u00e3o, ou Curva de acelera\u00e7\u00e3o no motor B Implementar VEL no SWx Interrup\u00e7\u00e3o na leitura do bot\u00e3o C Mem\u00f3ria de dados separada da de programa JTAG gerando interrup\u00e7\u00e3o. PIO dedicado a ler bot\u00f5es (SWx) e controlar EN e DIR D Entregou somente tutorial I N\u00e3o entregou nada","title":"\ud83d\udc41 Entrega 2"},{"location":"Entrega-2/#entrega-2","text":"Success Revisado 2020-2 O que deve ser entregue? Pasta: Entrega_2_FPGA_NIOS V\u00eddeo do projeto funcionando com uma explica\u00e7\u00e3o (aprox 1.5 min) Nessa entrega iremos ter a mesma funcionalidade que a Entrega 1 por\u00e9m com o motor sendo acionado pelo NIOS (soft processor). Para isso ser\u00e1 necess\u00e1rio modificar o projeto criado no tutorial para possuir ao menos mais um perif\u00e9rico PIO (que ser\u00e1 respons\u00e1vel por ler os bot\u00f5es). Al\u00e9m de adicionar esse novo perif\u00e9rico, nessa entrega iremos aprimorar nosso sistema com: Perif\u00e9rico JTAG deve gerar interrup\u00e7\u00e3o Perif\u00e9rico PIO que lida com o bot\u00e3o deve gerar interrup\u00e7\u00e3o Mem\u00f3ria de programa separada da de dados Uma vez que o JTAG come\u00e7a a gerar interrup\u00e7\u00f5es n\u00e3o ser\u00e1 mais necess\u00e1rio usar o small driver do JTAG, lembre de alterar isso no bsp . Comece por ler os bot\u00f5es sem interrup\u00e7\u00e3o, uma vez que estiver funcionando, utilize os sites a seguir como refer\u00eancia para implementar interrup\u00e7\u00e3o no NIOS: Dicas: http://www.johnloomis.org/NiosII/interrupts/interrupt/interrupt.html https://www.altera.com/en_US/pdfs/literature/hb/nios2/n2sw_nii52006.pdf","title":"\ud83d\udc41 Entrega 2"},{"location":"Entrega-2/#rubrica","text":"Entrega - google forms Loading\u2026 A Insira um RTOS no NIOS para fazer o controle da aplica\u00e7\u00e3o, ou Curva de acelera\u00e7\u00e3o no motor B Implementar VEL no SWx Interrup\u00e7\u00e3o na leitura do bot\u00e3o C Mem\u00f3ria de dados separada da de programa JTAG gerando interrup\u00e7\u00e3o. PIO dedicado a ler bot\u00f5es (SWx) e controlar EN e DIR D Entregou somente tutorial I N\u00e3o entregou nada","title":"Rubrica"},{"location":"Entrega-3/","text":"\ud83d\udc41 Entrega 3 \u00b6 2020-2 Material atualizado. O que deve ser entregue? Pasta: Entrega_3_FPGA_NIOS_IP V\u00eddeo do projeto funcionando com uma explica\u00e7\u00e3o (aprox 1.5 min) Nessa entrega iremos encapsular o perif\u00e9rico que criamos para controlar o motor de passos ( Entrega-1 ) no Plataform Designer (criando um perif\u00e9rico mapeado em mem\u00f3ria) a fim de possuirmos um componente dedicado para controlar o motor. Hardware \u00b6 O diagrama a seguir \u00e9 uma vis\u00e3o geral do que deve ser feito, nessa concep\u00e7\u00e3o iremos \"encapsular\" o IP da desenvolvido na Entrega-1 em um \"perif\u00e9rico mapeado em mem\u00f3ria\" ( StepMotor-MM ), para isso ser\u00e1 necess\u00e1rio adicionar uma l\u00f3gica extra, normalmente chamada de Glue Logic que realiza a interface entre o barramento e o IP. Glue Logic \u00b6 A l\u00f3gica de controle deve interfacear com o perif\u00e9rico do Motor de passos em todos os sinais de controle (menos nos de sa\u00edda (pahse)) de maneira abstrair o acesso mapeado em mem\u00f3ria para o perif\u00e9rico. A maneira mais f\u00e1cil de fazer isso \u00e9 definindo funcionalidades a endere\u00e7os do perif\u00e9rico, por exemplo: Offset Funcionalidade Tipo 0 EN R/W 1 DIR R/W 2 VEL R/W ... ... A tabela anterior mapeia para cada endere\u00e7o do perif\u00e9rico uma funcionalidade diferente, nesse exemplo, se o usu\u00e1rio deseja ativar o motor, deve fazer a escrita no endere\u00e7o 0 desse perif\u00e9rico. Note que alguns endere\u00e7os s\u00e3o Read Only e outros Read/Write (tipo), isso se d\u00e1 porque n\u00e3o tem sentido (nem \u00e9 poss\u00edvel fisicamente) escrever me alguns endere\u00e7os. (rubrica C) Software \u00b6 Entrega - google forms Loading\u2026 Al\u00e9m da parte de HW, iremos desenvolver uma biblioteca em C que ir\u00e1 abstrair a interface com esse perif\u00e9rico. O perif\u00e9rico deve possuir um driver capaz de interagir com o perif\u00e9rico. Iremos padronizar algumas fun\u00e7\u00f5es a fim de definirmos um padr\u00e3o de interface: // Para rubrica C int motor_init ( ..... ); // Inicializa o perif\u00e9rico int motor_halt ( ..... ); // Desativa o perif\u00e9rico int motor_en ( ..... ); // retorna se houve algum click (rubrica A/B) Software (melhorando) \u00b6 Adicionar as seguintes fun\u00e7\u00f5es (cada uma + meio conceito): // Para rubrica B/A int motor_dir ( ..... ); // configura dire\u00e7\u00e3o int motor_vel ( ..... ); // condigura velocidade Esse driver deve estar distribu\u00eddo em dois arquivos: motor.c e motor.h .","title":"\ud83d\udc41 Entrega 3"},{"location":"Entrega-3/#entrega-3","text":"2020-2 Material atualizado. O que deve ser entregue? Pasta: Entrega_3_FPGA_NIOS_IP V\u00eddeo do projeto funcionando com uma explica\u00e7\u00e3o (aprox 1.5 min) Nessa entrega iremos encapsular o perif\u00e9rico que criamos para controlar o motor de passos ( Entrega-1 ) no Plataform Designer (criando um perif\u00e9rico mapeado em mem\u00f3ria) a fim de possuirmos um componente dedicado para controlar o motor.","title":"\ud83d\udc41 Entrega 3"},{"location":"Entrega-3/#hardware","text":"O diagrama a seguir \u00e9 uma vis\u00e3o geral do que deve ser feito, nessa concep\u00e7\u00e3o iremos \"encapsular\" o IP da desenvolvido na Entrega-1 em um \"perif\u00e9rico mapeado em mem\u00f3ria\" ( StepMotor-MM ), para isso ser\u00e1 necess\u00e1rio adicionar uma l\u00f3gica extra, normalmente chamada de Glue Logic que realiza a interface entre o barramento e o IP.","title":"Hardware"},{"location":"Entrega-3/#glue-logic","text":"A l\u00f3gica de controle deve interfacear com o perif\u00e9rico do Motor de passos em todos os sinais de controle (menos nos de sa\u00edda (pahse)) de maneira abstrair o acesso mapeado em mem\u00f3ria para o perif\u00e9rico. A maneira mais f\u00e1cil de fazer isso \u00e9 definindo funcionalidades a endere\u00e7os do perif\u00e9rico, por exemplo: Offset Funcionalidade Tipo 0 EN R/W 1 DIR R/W 2 VEL R/W ... ... A tabela anterior mapeia para cada endere\u00e7o do perif\u00e9rico uma funcionalidade diferente, nesse exemplo, se o usu\u00e1rio deseja ativar o motor, deve fazer a escrita no endere\u00e7o 0 desse perif\u00e9rico. Note que alguns endere\u00e7os s\u00e3o Read Only e outros Read/Write (tipo), isso se d\u00e1 porque n\u00e3o tem sentido (nem \u00e9 poss\u00edvel fisicamente) escrever me alguns endere\u00e7os.","title":"Glue Logic"},{"location":"Entrega-3/#rubrica-c-software","text":"Entrega - google forms Loading\u2026 Al\u00e9m da parte de HW, iremos desenvolver uma biblioteca em C que ir\u00e1 abstrair a interface com esse perif\u00e9rico. O perif\u00e9rico deve possuir um driver capaz de interagir com o perif\u00e9rico. Iremos padronizar algumas fun\u00e7\u00f5es a fim de definirmos um padr\u00e3o de interface: // Para rubrica C int motor_init ( ..... ); // Inicializa o perif\u00e9rico int motor_halt ( ..... ); // Desativa o perif\u00e9rico int motor_en ( ..... ); // retorna se houve algum click","title":"(rubrica C) Software"},{"location":"Entrega-3/#rubrica-ab-software-melhorando","text":"Adicionar as seguintes fun\u00e7\u00f5es (cada uma + meio conceito): // Para rubrica B/A int motor_dir ( ..... ); // configura dire\u00e7\u00e3o int motor_vel ( ..... ); // condigura velocidade Esse driver deve estar distribu\u00eddo em dois arquivos: motor.c e motor.h .","title":"(rubrica A/B) Software (melhorando)"},{"location":"Entrega-4/","text":"\ud83d\udc41 Entrega 4 \u00b6 2020-2 Material atualizado. O objetivo dessa entrega \u00e9 automatizarmos a compila\u00e7\u00e3o e deploy de novos programas para o target . Para isso, teremos que criar um Makefile que deve ser capaz de compilar e fazer o deploy de programa. Para isso temos diversas op\u00e7\u00f5es, sendo alguma delas: Transfer\u00eancia de arquivo via ssh: scp Montar do pasta do target no host remota via ssh: sshfs Via gdb server executa no target um gdb server que possibilita ao host transferir e debugar um bin\u00e1rio. Note que todas as solu\u00e7\u00f5es demandam de conex\u00e3o com de rede, para isso, siga o roteiro: Info HPS Ethernet . Rubrica: \u00b6 Entrega - google forms Loading\u2026 Para testar, modifique o makefile do BlinkLed A Debuga um programar no target (via gdbserver) B Via Makefile consegue executar o bin\u00e1rio no target make run / make deploy C Criou um Makefile que compila o c\u00f3digo e faz o deploy para o target de um programa make deploy D Entregou somente os tutoriais I N\u00e3o entregou nada","title":"\ud83d\udc41 Entrega 4"},{"location":"Entrega-4/#entrega-4","text":"2020-2 Material atualizado. O objetivo dessa entrega \u00e9 automatizarmos a compila\u00e7\u00e3o e deploy de novos programas para o target . Para isso, teremos que criar um Makefile que deve ser capaz de compilar e fazer o deploy de programa. Para isso temos diversas op\u00e7\u00f5es, sendo alguma delas: Transfer\u00eancia de arquivo via ssh: scp Montar do pasta do target no host remota via ssh: sshfs Via gdb server executa no target um gdb server que possibilita ao host transferir e debugar um bin\u00e1rio. Note que todas as solu\u00e7\u00f5es demandam de conex\u00e3o com de rede, para isso, siga o roteiro: Info HPS Ethernet .","title":"\ud83d\udc41 Entrega 4"},{"location":"Entrega-4/#rubrica","text":"Entrega - google forms Loading\u2026 Para testar, modifique o makefile do BlinkLed A Debuga um programar no target (via gdbserver) B Via Makefile consegue executar o bin\u00e1rio no target make run / make deploy C Criou um Makefile que compila o c\u00f3digo e faz o deploy para o target de um programa make deploy D Entregou somente os tutoriais I N\u00e3o entregou nada","title":"Rubrica:"},{"location":"Entrega-5/","text":"\ud83d\udc41 Entrega 5 \u00b6 Voc\u00eas devem criar uma sistema embarcado que possui um webserver e uma p\u00e1gina web que permita sensoriar e controlar o hardware por uma interface simples. A p\u00e1gina deve permitir: Controlar o LED da placa Fazer a leitura do bot\u00e3o da placa Rubrica: \u00b6 Entrega - google forms Loading\u2026 C \u00b6 webserver que permite: controlar o bot\u00e3o do LED da placa leitura da chave da placa (status) B \u00b6 O deploy e configura\u00e7\u00e3o do webserver deve ser feito via um makefile O sistema deve ser inicializado automaticamente A \u00b6 Leitura e exibi\u00e7\u00e3o da IMU da placa (dica: usar c\u00f3digo exemplo ( hps_gsensor )) Escrever no LCD da placa (dica: usar c\u00f3digo exemplo hps_lcd )","title":"\ud83d\udc41 Entrega 5"},{"location":"Entrega-5/#entrega-5","text":"Voc\u00eas devem criar uma sistema embarcado que possui um webserver e uma p\u00e1gina web que permita sensoriar e controlar o hardware por uma interface simples. A p\u00e1gina deve permitir: Controlar o LED da placa Fazer a leitura do bot\u00e3o da placa","title":"\ud83d\udc41 Entrega 5"},{"location":"Entrega-5/#rubrica","text":"Entrega - google forms Loading\u2026","title":"Rubrica:"},{"location":"Entrega-5/#c","text":"webserver que permite: controlar o bot\u00e3o do LED da placa leitura da chave da placa (status)","title":"C"},{"location":"Entrega-5/#b","text":"O deploy e configura\u00e7\u00e3o do webserver deve ser feito via um makefile O sistema deve ser inicializado automaticamente","title":"B"},{"location":"Entrega-5/#a","text":"Leitura e exibi\u00e7\u00e3o da IMU da placa (dica: usar c\u00f3digo exemplo ( hps_gsensor )) Escrever no LCD da placa (dica: usar c\u00f3digo exemplo hps_lcd )","title":"A"},{"location":"Entrega-6/","text":"\ud83d\udc41 Entrega 6 \u00b6 Desenhe um diagrama de blocos que explica o tutorial anterior (HPS+FPGA)! Nele deve conter: SDCARD ARM DDR3 FPGA perif\u00e9rico PIO","title":"\ud83d\udc41 Entrega 6"},{"location":"Entrega-6/#entrega-6","text":"Desenhe um diagrama de blocos que explica o tutorial anterior (HPS+FPGA)! Nele deve conter: SDCARD ARM DDR3 FPGA perif\u00e9rico PIO","title":"\ud83d\udc41 Entrega 6"},{"location":"Entrega-Extra-1/","text":"\ud83d\udc41 Entrega Opcional 1 \u00b6 Agora que vimos como faz para interfacear ARM com FPGA, que tal voc\u00ea adicionar o perif\u00e9rico que criou na entrega 2 (o peripheral_led ) e controlar os LEDs da FPGA via Linux com o seu pr\u00f3prio perif\u00e9rico? Modifique o platform designer adicionando o seu IP Anote o endere\u00e7o Compile o projeto, gere o .rbf e .dtb (copie para o SDcard) Modifique o main.c para acessar o seu perif\u00e9rico Teste Nota: \u00b6 Essa entrega extra entra como uma nota a mais na m\u00e9dia de valor A (ou seja, quem fez \u00e9 beneficiado e quem n\u00e3o quer fazer, tudo bem!)","title":"\ud83d\udc41 Entrega Opcional 1"},{"location":"Entrega-Extra-1/#entrega-opcional-1","text":"Agora que vimos como faz para interfacear ARM com FPGA, que tal voc\u00ea adicionar o perif\u00e9rico que criou na entrega 2 (o peripheral_led ) e controlar os LEDs da FPGA via Linux com o seu pr\u00f3prio perif\u00e9rico? Modifique o platform designer adicionando o seu IP Anote o endere\u00e7o Compile o projeto, gere o .rbf e .dtb (copie para o SDcard) Modifique o main.c para acessar o seu perif\u00e9rico Teste","title":"\ud83d\udc41 Entrega Opcional 1"},{"location":"Entrega-Extra-1/#nota","text":"Essa entrega extra entra como uma nota a mais na m\u00e9dia de valor A (ou seja, quem fez \u00e9 beneficiado e quem n\u00e3o quer fazer, tudo bem!)","title":"Nota:"},{"location":"Projeto-Entrega-1/","text":"Entregas \u00b6 2020-2 Material atualizado. 1 \u00b6 Data 7/9 Nessa primeira entrega voc\u00ea deve ter uma sugest\u00e3o de t\u00f3picos que gostaria de atacar e ter em mente qual hardware seria necess\u00e1rio para a execu\u00e7\u00e3o do mesmo, de onde voc\u00ea quer sair e onde quer chegar... Criar um reposit\u00f3rio e escrever no readme: Tecnologia Hardware Ponto de partida / Ponto de chegada Exemplos/ sites/ manuais que leu e achou que pode servir como refer\u00eancia","title":"Entregas"},{"location":"Projeto-Entrega-1/#entregas","text":"2020-2 Material atualizado.","title":"Entregas"},{"location":"Projeto-Entrega-1/#1","text":"Data 7/9 Nessa primeira entrega voc\u00ea deve ter uma sugest\u00e3o de t\u00f3picos que gostaria de atacar e ter em mente qual hardware seria necess\u00e1rio para a execu\u00e7\u00e3o do mesmo, de onde voc\u00ea quer sair e onde quer chegar... Criar um reposit\u00f3rio e escrever no readme: Tecnologia Hardware Ponto de partida / Ponto de chegada Exemplos/ sites/ manuais que leu e achou que pode servir como refer\u00eancia","title":"1"},{"location":"Projeto-Overview/","text":"Overview \u00b6 O projeto final da disciplina deve ser um tutorial que tenha rela\u00e7\u00e3o com ao menos um objetivo de aprendizagem da mat\u00e9ria: Formular solu\u00e7\u00f5es que satisfazem requisitos de hardware e software de projetos com FPGA-SoC (System-on-a-chip) Integrar em um prot\u00f3tipo solu\u00e7\u00e3o para um sistema embarcado com requisitos de processamento e/ou tempo real via FPGA-SoC Interfacear diferentes m\u00f3dulos em um sistema embarcado (processadores, firmware e sistema operacional) \u00c1reas \u00b6 Alguns exemplos de \u00e1reas que podem ser exploradas: Acelera\u00e7\u00e3o/ implementa\u00e7\u00e3o de algum algor\u00edtimo em hardware processamento de dados, FFT, compress\u00e3o, criptografia, ... HLD/ HLS/ OpenCL/ FPGA Amazon Compara\u00e7\u00e3o de performance entre diferentes tecnologias SoC vs GPU vs FPGA vs uC Sistema operacional Escalonador real time kernel linux, Android, RTOS embarcado Tecnologias/ Ferramentas \u00b6 A seguir uma lista de tecnologias que podem ser estudadas no tutorial: HDL (VHDL/Verilog) Adicionar uma instru\u00e7\u00e3o customizada ao NIOS Platform designer Criar um sistema para controlar um dos rob\u00f4s de rob\u00f3tica Criar um perif\u00e9rico para interfacear com o mundo externo (ler teclado/ motor/ fita de Led/ ...) High Level Synthesis (HLS) Criar um perif\u00e9rico que acelera uma fun\u00e7\u00e3o ( example ) OpenCL Criar um hardware que acelera uma fun\u00e7\u00e3o Terasic Manual ( example ) Linux real time / otimiza\u00e7\u00e3o energ\u00e9tica / \ud83d\udc4d boot time / aplica\u00e7\u00f5es / \ud83d\udc4d Android / openCL .... Hardwares \u00b6 A seguir, eu tentei resumir os hardwares dispon\u00edveis no Insper e as respectivas tecnologias que podem ser utilizados para desenvolver os projetos: Kit Empresa Tecnologia vhdl HLS OpenCL Linux OpenCV Cuda Arria 10 SoC Intel FPGA + ARM x x x x x DE10-Standard Intel FPGA + ARM x x x x x DE10-nano-soc Intel FPGA + ARM x x x x x Terasic SoC SoM Intel FPGA + ARM x x x x x DE5a-NET-DDR4 Intel FPGA x x x x ZedBoard Xilinx FPGA + ARM x x x x x inst\u00e2ncia F1 AWS FPGA x Jetson TK2 NVIDIa ARM + GPU x x x Exemplos de temas/ coisas legais \u00b6 legenda: \u203c demanda uma dedica\u00e7\u00e3o maior Criando um SoftProcessor e API para controlar um Drone OpenCV acelerado com OpenCL - ZedBoard !! Criar uma aplica\u00e7\u00e3o com HLS/OpenCL que acelera uma fun\u00e7\u00e3o na FPGA Processamento de imagem/ compress\u00e3o de dados/ criptografia/ fft/ ... \u203c Criar uma aplica\u00e7\u00e3o com OpenCL na AWS Embarcando ROS no SoC-FPGA (primeiro passo para controlarmos os rob\u00f4s de rob\u00f3tica com a FPGA) \u203c Usar o LCD LT24 com o Linux (Comunica\u00e7\u00e3o ARM-FPGA) Real Time kernel \u00e9 realmente tempo real? Estudo de lat\u00eancia... Otimizando o boot time do linux Executando Android na DE10-Standard Interface gr\u00e1ficas em sistemas embarcados (exe: criar um totem de pagamento) Device driver: Criar um driver no linux para algum sensor de dist\u00e2ncia \u203c Criar um perif\u00e9rico para controlar a fita de LED RGB e criar um driver para o Linux controlar BanchMark entre os diferentes kits de desenvolvimento Usando o yocto como alternativa ao buildroot para gerar o Linux","title":"Overview"},{"location":"Projeto-Overview/#overview","text":"O projeto final da disciplina deve ser um tutorial que tenha rela\u00e7\u00e3o com ao menos um objetivo de aprendizagem da mat\u00e9ria: Formular solu\u00e7\u00f5es que satisfazem requisitos de hardware e software de projetos com FPGA-SoC (System-on-a-chip) Integrar em um prot\u00f3tipo solu\u00e7\u00e3o para um sistema embarcado com requisitos de processamento e/ou tempo real via FPGA-SoC Interfacear diferentes m\u00f3dulos em um sistema embarcado (processadores, firmware e sistema operacional)","title":"Overview"},{"location":"Projeto-Overview/#areas","text":"Alguns exemplos de \u00e1reas que podem ser exploradas: Acelera\u00e7\u00e3o/ implementa\u00e7\u00e3o de algum algor\u00edtimo em hardware processamento de dados, FFT, compress\u00e3o, criptografia, ... HLD/ HLS/ OpenCL/ FPGA Amazon Compara\u00e7\u00e3o de performance entre diferentes tecnologias SoC vs GPU vs FPGA vs uC Sistema operacional Escalonador real time kernel linux, Android, RTOS embarcado","title":"\u00c1reas"},{"location":"Projeto-Overview/#tecnologias-ferramentas","text":"A seguir uma lista de tecnologias que podem ser estudadas no tutorial: HDL (VHDL/Verilog) Adicionar uma instru\u00e7\u00e3o customizada ao NIOS Platform designer Criar um sistema para controlar um dos rob\u00f4s de rob\u00f3tica Criar um perif\u00e9rico para interfacear com o mundo externo (ler teclado/ motor/ fita de Led/ ...) High Level Synthesis (HLS) Criar um perif\u00e9rico que acelera uma fun\u00e7\u00e3o ( example ) OpenCL Criar um hardware que acelera uma fun\u00e7\u00e3o Terasic Manual ( example ) Linux real time / otimiza\u00e7\u00e3o energ\u00e9tica / \ud83d\udc4d boot time / aplica\u00e7\u00f5es / \ud83d\udc4d Android / openCL ....","title":"Tecnologias/ Ferramentas"},{"location":"Projeto-Overview/#hardwares","text":"A seguir, eu tentei resumir os hardwares dispon\u00edveis no Insper e as respectivas tecnologias que podem ser utilizados para desenvolver os projetos: Kit Empresa Tecnologia vhdl HLS OpenCL Linux OpenCV Cuda Arria 10 SoC Intel FPGA + ARM x x x x x DE10-Standard Intel FPGA + ARM x x x x x DE10-nano-soc Intel FPGA + ARM x x x x x Terasic SoC SoM Intel FPGA + ARM x x x x x DE5a-NET-DDR4 Intel FPGA x x x x ZedBoard Xilinx FPGA + ARM x x x x x inst\u00e2ncia F1 AWS FPGA x Jetson TK2 NVIDIa ARM + GPU x x x","title":"Hardwares"},{"location":"Projeto-Overview/#exemplos-de-temas-coisas-legais","text":"legenda: \u203c demanda uma dedica\u00e7\u00e3o maior Criando um SoftProcessor e API para controlar um Drone OpenCV acelerado com OpenCL - ZedBoard !! Criar uma aplica\u00e7\u00e3o com HLS/OpenCL que acelera uma fun\u00e7\u00e3o na FPGA Processamento de imagem/ compress\u00e3o de dados/ criptografia/ fft/ ... \u203c Criar uma aplica\u00e7\u00e3o com OpenCL na AWS Embarcando ROS no SoC-FPGA (primeiro passo para controlarmos os rob\u00f4s de rob\u00f3tica com a FPGA) \u203c Usar o LCD LT24 com o Linux (Comunica\u00e7\u00e3o ARM-FPGA) Real Time kernel \u00e9 realmente tempo real? Estudo de lat\u00eancia... Otimizando o boot time do linux Executando Android na DE10-Standard Interface gr\u00e1ficas em sistemas embarcados (exe: criar um totem de pagamento) Device driver: Criar um driver no linux para algum sensor de dist\u00e2ncia \u203c Criar um perif\u00e9rico para controlar a fita de LED RGB e criar um driver para o Linux controlar BanchMark entre os diferentes kits de desenvolvimento Usando o yocto como alternativa ao buildroot para gerar o Linux","title":"Exemplos de temas/ coisas legais"},{"location":"Projeto-Rubrica/","text":"Rubrica \u00b6 2020-2 Material revisado O tutorial deve ser de autoria do aluno e auto contido, publicado na wiki da disciplina. A rubrica \u00e9 incremental, para tirar A precisa ter alcan\u00e7ado o B antes... Tutoriais em ingl\u00eas s\u00e3o acrescidos de \u00bd conceito. A \u00c9 um tutorial de um tema novo Possui um guia ao final do tutorial em como se aprofundar no tema Possui claro quais s\u00e3o os pontos cr\u00edticos, e o que fazer em caso de erro B O tutorial \u00e9 uma jun\u00e7\u00e3o de outros tutoriais por\u00e9m avan\u00e7a a onde os outros n\u00e3o foram O tutorial mescla teoria e pr\u00e1tica de maneira aprofundada, mas sem travar o fluxo do mesmo C O tutorial \u00e9 uma jun\u00e7\u00e3o de outros tutoriais ou deriva\u00e7\u00e3o de um exemplo j\u00e1 existente Tutorial \u00e9 reproduz\u00edvel (outra pessoa consegue seguir e chegar nos mesmos resultados) Possui um pouco de teoria, sem aprofundamento Possui refer\u00eancias externas","title":"Rubrica"},{"location":"Projeto-Rubrica/#rubrica","text":"2020-2 Material revisado O tutorial deve ser de autoria do aluno e auto contido, publicado na wiki da disciplina. A rubrica \u00e9 incremental, para tirar A precisa ter alcan\u00e7ado o B antes... Tutoriais em ingl\u00eas s\u00e3o acrescidos de \u00bd conceito. A \u00c9 um tutorial de um tema novo Possui um guia ao final do tutorial em como se aprofundar no tema Possui claro quais s\u00e3o os pontos cr\u00edticos, e o que fazer em caso de erro B O tutorial \u00e9 uma jun\u00e7\u00e3o de outros tutoriais por\u00e9m avan\u00e7a a onde os outros n\u00e3o foram O tutorial mescla teoria e pr\u00e1tica de maneira aprofundada, mas sem travar o fluxo do mesmo C O tutorial \u00e9 uma jun\u00e7\u00e3o de outros tutoriais ou deriva\u00e7\u00e3o de um exemplo j\u00e1 existente Tutorial \u00e9 reproduz\u00edvel (outra pessoa consegue seguir e chegar nos mesmos resultados) Possui um pouco de teoria, sem aprofundamento Possui refer\u00eancias externas","title":"Rubrica"},{"location":"Tutorial-Acelerando-HLS/","text":"Tutorial - Acelerando - HLS \u00b6 HLS (High-Level Synthesis Compiler) \u00e9 uma ferramenta de compila\u00e7\u00e3o que permite criarmos um componente (hardware/ HDL) a partir de uma linguagem de programa\u00e7\u00e3o de alto n\u00edvel (no caso c++). Essa ferramenta facilita muito o desenvolvimento, e abstrai o hardware para software, por\u00e9m ainda \u00e9 preciso ter um conhecimento de hardware para utilizar-lha. Intel \u00b6 The Intel\u00ae HLS Compiler is a high-level synthesis (HLS) tool that takes in untimed C++ as input and generates production-quality register transfer level (RTL) code that is optimized for Intel\u00ae FPGAs. This tool accelerates verification time over RTL by raising the abstraction level for FPGA hardware design. Models developed in C++ are typically verified orders of magnitude faster than RTL. centos \u00b6 Warning Eu s\u00f3 consegui fazer funcionar no centos6, minha solu\u00e7\u00e3o foi a de executar um docker com centos, e instalar as depend\u00eancias nele. Eu executo o HLS via o docker CLI. Note Para facilitar a vida, vamos disponibilizar uma imagem do docker j\u00e1 configurada. Veja com o seu professor como conseguir. HLS \u00b6 Vamos gerar um componente que aplica um offset (proc) em uma imagem, para isso, esse componente ter\u00e1 duas interfaces avalon de acesso a mem\u00f3ria (AVALON-MM), na primeira interface, iremos acessar a imagem original e na outra iremos escrever a imagem processada. O nosso hardware ter\u00e1 o seguinte formato: |-----| AXI | ARM | =========================== |-----| | | | | |-------| |-------| | Min | | Mout | |-------| |-------| AVALON-MM | ^ V | |-------| | | Proc |---------- AVALON-MM | (HLS) | |-------| Min: Mem\u00f3ria da FPGA onde iremos salvar a imagem original Mout: Mem\u00f3ria na FPGA onde iremos salvar a imagem processada TH: Perif\u00e9rico criado pelo HLS Para isso, iremos utilizar um sintax pr\u00f3pria do HLS que define como em C qual tipo de interface ser\u00e1 utilizada no componente (lembre das interfaces AVALON, memmory maped e streaming). O HLS permite que validemos o c\u00f3digo em duas camadas distintas: a primeira \u00e9 compilando o mesmo c\u00f3digo que ser\u00e1 sintetizado para arquitetura x86, com isso conseguimos validar o algor\u00edtimo de forma mais r\u00e1pida, a segunda \u00e9 gerando o HDL do componente e simulando via modelsim, tudo isso \u00e9 feito de forma transparente e autom\u00e1tica pela ferramenta. Note A simula\u00e7\u00e3o do hardware \u00e9 custosa em termos de tempo de processamento e poder computacional, ela deve ser a ultima coisa a ser feita, antes de usar o componente no hardware. Valide antes compilando para x86 e ent\u00e3o simule. Offset \u00b6 A fun\u00e7\u00e3o a ser acelerada \u00e9 a seguinte ( imgOffSet ): #define OFFSET 50 typedef ihc :: mm_master < unsigned char , ihc :: aspace < 1 > , ihc :: awidth < 32 > , ihc :: dwidth < 8 > > Master1 ; typedef ihc :: mm_master < unsigned char , ihc :: aspace < 2 > , ihc :: awidth < 32 > , ihc :: dwidth < 8 > > Master2 ; // just for a NxN image inline uint pxToMem ( uint x , uint y , uint N ){ return ( x + y * N ); } // px + OFFSET hls_avalon_slave_component component void imgOffSet ( Master1 & imgIn , Master2 & imgOut , hls_avalon_slave_register_argument int offSet , hls_avalon_slave_register_argument int N ){ for ( int y = 0 ; y < N ; y ++ ){ #pragma unroll 8 for ( int x = 0 ; x < N ; x ++ ){ int px = pxToMem ( x , y , N ); unsigned int tpx = (( unsigned int ) imgIn [ px ]) + offSet ; if ( tpx > 255 ) imgOut [ px ] = 255 ; else imgOut [ px ] = tpx ; } } } Note que a fun\u00e7\u00e3o imgOffSet possui quatro argumentos: imgIn , imgOut , offSet e N . Os dois primeiros s\u00e3o ponteiros de mem\u00f3ria, que \u00e9 respectivamente onde o componente vai fazer a leitura da imagem e onde ele vai fazer a escrita da imagem. J\u00e1 os argumentos offSet e N s\u00e3o: valor a ser aplicado de offSet no px e o tamanho da imagem em pxs, esse argumentos s\u00e3o do tipo hls_avalon_slave_register_argument , que ser\u00e1 convertido para um banco de registradores. Al\u00e9m dessas entradas e sa\u00eddas, para cada interface do tipo mm_master o HLS vai criar mais um conduit , que ser\u00e1 o offset de endere\u00e7o na qual ele deve acessar o dado (para a fun\u00e7\u00e3o o endere\u00e7o 0 \u00e9 relativo). E mais dois conduits , um para controlar o inicio do processamento (chamada de fun\u00e7\u00e3o/ call ) e outro para informar sobre o status do processamento ( return ). imgIn , imgOut \u00b6 Os dois primeiros argumento s\u00e3o do tipo ihc::mm_master< unsigned char, que significa que ser\u00e3o traduzidos para um barramento do tipo Avalon e que devem ser tradados como unsigned char . ihc::aspace<n> : e um identificador \u00fanico do barramento (1,2,3,4,...) ihc::awidth<32> : Define o tamanho do barramento de endere\u00e7o, nesse caso 32 bits ihc::dwidth<8> : Define o tamanho do barramento de dados, nesse caso 8 (leitura de 8 bits) Existem outras configura\u00e7\u00f5es do barramento que podem ser feitas nessa declara\u00e7\u00e3o: lat\u00eancia/ waitrequest/ burst/ ( , ihc::latency<0>, ihc::maxburst<8>, ihc::waitrequest<true> )... pxToMem() \u00b6 Para facilitar o desenvolvimento, a fun\u00e7\u00e3o pxToMem(x,y,N) traduz um acesso a px por endere\u00e7o na matriz para o endere\u00e7o de mem\u00f3ria do px. printf() \u00b6 Essa fun\u00e7\u00e3o ser\u00e1 removida quando a fun\u00e7\u00e3o for compilada para hardware, ela s\u00f3 est\u00e1 dispon\u00edvel para simula\u00e7\u00e3o e testes. offSet , n \u00b6 Precisamos lembrar que estamos criando um componente que resolver\u00e1 um c\u00f3digo em C, e a maneira de conseguirmos passar argumentos para um componente \u00e9 criando uma mem\u00f3ria interna, que chamamos normalmente de banco de registrador e dando funcionalidade para eles. \u00c9 dessa maneira, que os par\u00e2metros offSet e n ser\u00e3o criados. Na gera\u00e7\u00e3o do componente, uma mem\u00f3ria ser\u00e1 inicializada e endere\u00e7os ser\u00e3o reservados para o offSet e n , como no exemplo a seguir: /******************************************************************************/ /* Memory Map Summary */ /******************************************************************************/ /* Register | Access | Register Contents | Description Address | | (64-bits) | ------------|---------|--------------------------|----------------------------- 0x0 | R | {reserved[62:0], | Read the busy status of | | busy[0:0]} | the component | | | 0 - the component is ready | | | to accept a new start | | | 1 - the component cannot | | | accept a new start ------------|---------|--------------------------|----------------------------- 0x8 | W | {reserved[62:0], | Write 1 to signal start to | | start[0:0]} | the component ------------|---------|--------------------------|----------------------------- 0x10 | R/W | {reserved[62:0], | 0 - Disable interrupt, | | interrupt_enable[0:0]} | 1 - Enable interrupt ------------|---------|--------------------------|----------------------------- 0x18 | R/Wclr | {reserved[61:0], | Signals component completion | | done[0:0], | done is read-only and | | interrupt_status[0:0]} | interrupt_status is write 1 | | | to clear ------------|---------|--------------------------|----------------------------- 0x20 | R/W | {reserved[31:0], | Argument offSet | | offSet[31:0]} | ------------|---------|--------------------------|----------------------------- 0x28 | R/W | {reserved[31:0], | Argument N | | N[31:0]} | */ main.c \u00b6 A fim de validarmos o projeto, devemos criar uma fun\u00e7\u00e3o main (que n\u00e3o ser\u00e1 compilada para o hardware). Nessa fun\u00e7\u00e3o, abrimos um arquivo de imagem no formato .pgm (\"in.pgm\") e geramos outro arquivo de imagem, com a imagem original processada (\"out.pgm\"). A fim de validarmos o componente a ser gerado ( offSetImg() ) devemos alocar duas regi\u00f5es de mem\u00f3rias cont\u00ednuas ( in[M_SIZE] e out[M_SIZE) que ser\u00e3o utilizadas como input do componente (simulando o barramento AVALON). int main ( void ) { int N = IMG_W ; int M_SIZE = N * N ; // create memorys unsigned char in [ M_SIZE ]; unsigned char out [ M_SIZE ]; memset ( out , 0 , sizeof ( out )); /* -------------------------- */ /* reading img to mem */ /* -------------------------- */ printf ( \"loading img \\n \" ); readImgPgm ( IMG_IN , in , M_SIZE ); /* -------------------------- */ /* create fake memorys components*/ /* -------------------------- */ Master1 mm_in ( in , M_SIZE ); Master2 mm_out ( out , M_SIZE ); /* -------------------------- */ /* process with kernel */ /* -------------------------- */ printf ( \"kernel \\n \" ); imgOffSet ( mm_in , mm_out , N ); /* -------------------------- */ /* img out */ /* -------------------------- */ printf ( \"outputing \\n \" ); writeImgPgm ( IMG_OUT , out ) return 0 ; } Note Quando formos executar a fun\u00e7\u00e3o imgOffSet no nosso hardware, n\u00e3o ser\u00e1 t\u00e3o simples quanto apenas uma chamada de fun\u00e7\u00e3o. Testando (x86) \u00b6 Note Deve ser feito no centos (docker) Para testar, vamos compilar o nosso projeto para x86 (n\u00e3o ser\u00e1 um hardware) e validar se nossa l\u00f3gica est\u00e1 correta. Se funcionar, compilamos para hardware. Para compilar basta usarmos o compilador i++ como no exemplo a seguir: $ i++ image.cpp -march = x86-64 -o image_x86 E testar o programa gerado: $ ./image_x86 O resultado deve ser a bel\u00edssima foto img.ppm do seu professor, processada com um offset ( out.ppm ): Tip Para gerar uma imagem do tipo ppm voc\u00ea pode usar o Gimp Note Essa execu\u00e7\u00e3o \u00e9 como se tiv\u00e9ssemos compilado com gcc, s\u00f3 serve para validar l\u00f3gica input output img.pgm image (bin\u00e1rio) image.cpp out.pgm Acelerando na FPGA \u00b6 Para acelerar na FPGA, vamos compilar novamente a aplica\u00e7\u00e3o, por\u00e9m agora com a flag -march=CycloneV que representa a nossa FPGA $ i++ image.cpp -march = CycloneV -o image-CycloneV Note Isso pode bastante tempo, o que ele vai fazer \u00e9: Gerar um HDL a partir da sua fun\u00e7\u00e3o Criar um componente para o Platform Designer input output img.pgm image-CycloneV.prj (pasta) image-CycloneV.prj (pasta) \u00b6 Se reparar na pasta do projeto, deve ter uma pasta nova: image-CycloneV.prj , com o seguinte conte\u00fado: components : Pasta com o componente criado (para ser usado no Platform designer) quartus : Pasta do projeto Quartus utilizado para compilar o componente, n\u00e3o vamos usar report : Pasta com reports gerado pela ferramenta (html) report : Pasta para simular o projeto testando \u00b6 Agora podemos testar nossa aplica\u00e7\u00e3o utilizando o hardware criado pelo HLS, para isso basta executar o novo bin\u00e1rio criado quando compilamos para a arquitetura CycloneV . $ ./image-CycloneV Warning Isso vai levar muito tempo! No monstrinho do lab de Arquitetura, levou mais de 1 hora! Essa simula\u00e7\u00e3o \u00e9 realizada no modelsim! A n\u00edvel de hardware. O resultado ser\u00e1 o esperado quando formos embarcar na FPGA. Com essa simula\u00e7\u00e3o conseguimos verificar erros de arredondamento, acesso a mem\u00f3ria, entre outros. Tipa A imagem out-CycloneV.pgm que est\u00e1 na pasta do projeto, \u00e9 o resultado dessa simula\u00e7\u00e3o. report \u00b6 O HLS gera um relat\u00f3rio da compila\u00e7\u00e3o do hardware, ele pode ser encontrado em: reports/report.html . Um report interessante de se analisar \u00e9 o Loops analysis , que demonstra os loops do programa: Otimizando \u00b6 Podemos aplicar diversas t\u00e9cnicas de paraleliza\u00e7\u00e3o no software que ir\u00e1 impactar no hardware criado (\u00e1rea e performance), no manual do HLS ( Intel High Level Synthesis Compiler: Reference Manual ) tem a documenta\u00e7\u00e3o que descreve cada uma das t\u00e9cnicas. Vamos utilizar a do Loop Unrolling , que permite executarmos um loop paralelo: #pragma unroll <N> for ( int i = 0 ; i < M ; ++ i ) { // Some useful work } Tip N \u00e9 a quantidade de loops a serem executado em //. Vamos paralelizar a varredura da linha em 8 execu\u00e7\u00f5es em paralelo, para isso adicione no for que varre a linha (x): for ( int y = 0 ; y < N ; y ++ ){ #pragma unroll 8 for ( int x = 0 ; x < N ; x ++ ){ Criando um hardware \u00b6 Agora com o componente criado \u00e9 necess\u00e1rio adicionarmos ele no hardware, isso ser\u00e1 feito via Plataform Design. Para facilitar o desenvolvimento, vamos usar o projeto de hw exemplo da Terasic : DE10_Standard_FB e modificar inserindo o componente e duas mem\u00f3rias, como indicado a seguir:","title":"Tutorial - Acelerando - HLS"},{"location":"Tutorial-Acelerando-HLS/#tutorial-acelerando-hls","text":"HLS (High-Level Synthesis Compiler) \u00e9 uma ferramenta de compila\u00e7\u00e3o que permite criarmos um componente (hardware/ HDL) a partir de uma linguagem de programa\u00e7\u00e3o de alto n\u00edvel (no caso c++). Essa ferramenta facilita muito o desenvolvimento, e abstrai o hardware para software, por\u00e9m ainda \u00e9 preciso ter um conhecimento de hardware para utilizar-lha.","title":"Tutorial - Acelerando - HLS"},{"location":"Tutorial-Acelerando-HLS/#intel","text":"The Intel\u00ae HLS Compiler is a high-level synthesis (HLS) tool that takes in untimed C++ as input and generates production-quality register transfer level (RTL) code that is optimized for Intel\u00ae FPGAs. This tool accelerates verification time over RTL by raising the abstraction level for FPGA hardware design. Models developed in C++ are typically verified orders of magnitude faster than RTL.","title":"Intel"},{"location":"Tutorial-Acelerando-HLS/#centos","text":"Warning Eu s\u00f3 consegui fazer funcionar no centos6, minha solu\u00e7\u00e3o foi a de executar um docker com centos, e instalar as depend\u00eancias nele. Eu executo o HLS via o docker CLI. Note Para facilitar a vida, vamos disponibilizar uma imagem do docker j\u00e1 configurada. Veja com o seu professor como conseguir.","title":"centos"},{"location":"Tutorial-Acelerando-HLS/#hls","text":"Vamos gerar um componente que aplica um offset (proc) em uma imagem, para isso, esse componente ter\u00e1 duas interfaces avalon de acesso a mem\u00f3ria (AVALON-MM), na primeira interface, iremos acessar a imagem original e na outra iremos escrever a imagem processada. O nosso hardware ter\u00e1 o seguinte formato: |-----| AXI | ARM | =========================== |-----| | | | | |-------| |-------| | Min | | Mout | |-------| |-------| AVALON-MM | ^ V | |-------| | | Proc |---------- AVALON-MM | (HLS) | |-------| Min: Mem\u00f3ria da FPGA onde iremos salvar a imagem original Mout: Mem\u00f3ria na FPGA onde iremos salvar a imagem processada TH: Perif\u00e9rico criado pelo HLS Para isso, iremos utilizar um sintax pr\u00f3pria do HLS que define como em C qual tipo de interface ser\u00e1 utilizada no componente (lembre das interfaces AVALON, memmory maped e streaming). O HLS permite que validemos o c\u00f3digo em duas camadas distintas: a primeira \u00e9 compilando o mesmo c\u00f3digo que ser\u00e1 sintetizado para arquitetura x86, com isso conseguimos validar o algor\u00edtimo de forma mais r\u00e1pida, a segunda \u00e9 gerando o HDL do componente e simulando via modelsim, tudo isso \u00e9 feito de forma transparente e autom\u00e1tica pela ferramenta. Note A simula\u00e7\u00e3o do hardware \u00e9 custosa em termos de tempo de processamento e poder computacional, ela deve ser a ultima coisa a ser feita, antes de usar o componente no hardware. Valide antes compilando para x86 e ent\u00e3o simule.","title":"HLS"},{"location":"Tutorial-Acelerando-HLS/#offset","text":"A fun\u00e7\u00e3o a ser acelerada \u00e9 a seguinte ( imgOffSet ): #define OFFSET 50 typedef ihc :: mm_master < unsigned char , ihc :: aspace < 1 > , ihc :: awidth < 32 > , ihc :: dwidth < 8 > > Master1 ; typedef ihc :: mm_master < unsigned char , ihc :: aspace < 2 > , ihc :: awidth < 32 > , ihc :: dwidth < 8 > > Master2 ; // just for a NxN image inline uint pxToMem ( uint x , uint y , uint N ){ return ( x + y * N ); } // px + OFFSET hls_avalon_slave_component component void imgOffSet ( Master1 & imgIn , Master2 & imgOut , hls_avalon_slave_register_argument int offSet , hls_avalon_slave_register_argument int N ){ for ( int y = 0 ; y < N ; y ++ ){ #pragma unroll 8 for ( int x = 0 ; x < N ; x ++ ){ int px = pxToMem ( x , y , N ); unsigned int tpx = (( unsigned int ) imgIn [ px ]) + offSet ; if ( tpx > 255 ) imgOut [ px ] = 255 ; else imgOut [ px ] = tpx ; } } } Note que a fun\u00e7\u00e3o imgOffSet possui quatro argumentos: imgIn , imgOut , offSet e N . Os dois primeiros s\u00e3o ponteiros de mem\u00f3ria, que \u00e9 respectivamente onde o componente vai fazer a leitura da imagem e onde ele vai fazer a escrita da imagem. J\u00e1 os argumentos offSet e N s\u00e3o: valor a ser aplicado de offSet no px e o tamanho da imagem em pxs, esse argumentos s\u00e3o do tipo hls_avalon_slave_register_argument , que ser\u00e1 convertido para um banco de registradores. Al\u00e9m dessas entradas e sa\u00eddas, para cada interface do tipo mm_master o HLS vai criar mais um conduit , que ser\u00e1 o offset de endere\u00e7o na qual ele deve acessar o dado (para a fun\u00e7\u00e3o o endere\u00e7o 0 \u00e9 relativo). E mais dois conduits , um para controlar o inicio do processamento (chamada de fun\u00e7\u00e3o/ call ) e outro para informar sobre o status do processamento ( return ).","title":"Offset"},{"location":"Tutorial-Acelerando-HLS/#imgin-imgout","text":"Os dois primeiros argumento s\u00e3o do tipo ihc::mm_master< unsigned char, que significa que ser\u00e3o traduzidos para um barramento do tipo Avalon e que devem ser tradados como unsigned char . ihc::aspace<n> : e um identificador \u00fanico do barramento (1,2,3,4,...) ihc::awidth<32> : Define o tamanho do barramento de endere\u00e7o, nesse caso 32 bits ihc::dwidth<8> : Define o tamanho do barramento de dados, nesse caso 8 (leitura de 8 bits) Existem outras configura\u00e7\u00f5es do barramento que podem ser feitas nessa declara\u00e7\u00e3o: lat\u00eancia/ waitrequest/ burst/ ( , ihc::latency<0>, ihc::maxburst<8>, ihc::waitrequest<true> )...","title":"imgIn , imgOut"},{"location":"Tutorial-Acelerando-HLS/#pxtomem","text":"Para facilitar o desenvolvimento, a fun\u00e7\u00e3o pxToMem(x,y,N) traduz um acesso a px por endere\u00e7o na matriz para o endere\u00e7o de mem\u00f3ria do px.","title":"pxToMem()"},{"location":"Tutorial-Acelerando-HLS/#printf","text":"Essa fun\u00e7\u00e3o ser\u00e1 removida quando a fun\u00e7\u00e3o for compilada para hardware, ela s\u00f3 est\u00e1 dispon\u00edvel para simula\u00e7\u00e3o e testes.","title":"printf()"},{"location":"Tutorial-Acelerando-HLS/#offset-n","text":"Precisamos lembrar que estamos criando um componente que resolver\u00e1 um c\u00f3digo em C, e a maneira de conseguirmos passar argumentos para um componente \u00e9 criando uma mem\u00f3ria interna, que chamamos normalmente de banco de registrador e dando funcionalidade para eles. \u00c9 dessa maneira, que os par\u00e2metros offSet e n ser\u00e3o criados. Na gera\u00e7\u00e3o do componente, uma mem\u00f3ria ser\u00e1 inicializada e endere\u00e7os ser\u00e3o reservados para o offSet e n , como no exemplo a seguir: /******************************************************************************/ /* Memory Map Summary */ /******************************************************************************/ /* Register | Access | Register Contents | Description Address | | (64-bits) | ------------|---------|--------------------------|----------------------------- 0x0 | R | {reserved[62:0], | Read the busy status of | | busy[0:0]} | the component | | | 0 - the component is ready | | | to accept a new start | | | 1 - the component cannot | | | accept a new start ------------|---------|--------------------------|----------------------------- 0x8 | W | {reserved[62:0], | Write 1 to signal start to | | start[0:0]} | the component ------------|---------|--------------------------|----------------------------- 0x10 | R/W | {reserved[62:0], | 0 - Disable interrupt, | | interrupt_enable[0:0]} | 1 - Enable interrupt ------------|---------|--------------------------|----------------------------- 0x18 | R/Wclr | {reserved[61:0], | Signals component completion | | done[0:0], | done is read-only and | | interrupt_status[0:0]} | interrupt_status is write 1 | | | to clear ------------|---------|--------------------------|----------------------------- 0x20 | R/W | {reserved[31:0], | Argument offSet | | offSet[31:0]} | ------------|---------|--------------------------|----------------------------- 0x28 | R/W | {reserved[31:0], | Argument N | | N[31:0]} | */","title":"offSet, n"},{"location":"Tutorial-Acelerando-HLS/#mainc","text":"A fim de validarmos o projeto, devemos criar uma fun\u00e7\u00e3o main (que n\u00e3o ser\u00e1 compilada para o hardware). Nessa fun\u00e7\u00e3o, abrimos um arquivo de imagem no formato .pgm (\"in.pgm\") e geramos outro arquivo de imagem, com a imagem original processada (\"out.pgm\"). A fim de validarmos o componente a ser gerado ( offSetImg() ) devemos alocar duas regi\u00f5es de mem\u00f3rias cont\u00ednuas ( in[M_SIZE] e out[M_SIZE) que ser\u00e3o utilizadas como input do componente (simulando o barramento AVALON). int main ( void ) { int N = IMG_W ; int M_SIZE = N * N ; // create memorys unsigned char in [ M_SIZE ]; unsigned char out [ M_SIZE ]; memset ( out , 0 , sizeof ( out )); /* -------------------------- */ /* reading img to mem */ /* -------------------------- */ printf ( \"loading img \\n \" ); readImgPgm ( IMG_IN , in , M_SIZE ); /* -------------------------- */ /* create fake memorys components*/ /* -------------------------- */ Master1 mm_in ( in , M_SIZE ); Master2 mm_out ( out , M_SIZE ); /* -------------------------- */ /* process with kernel */ /* -------------------------- */ printf ( \"kernel \\n \" ); imgOffSet ( mm_in , mm_out , N ); /* -------------------------- */ /* img out */ /* -------------------------- */ printf ( \"outputing \\n \" ); writeImgPgm ( IMG_OUT , out ) return 0 ; } Note Quando formos executar a fun\u00e7\u00e3o imgOffSet no nosso hardware, n\u00e3o ser\u00e1 t\u00e3o simples quanto apenas uma chamada de fun\u00e7\u00e3o.","title":"main.c"},{"location":"Tutorial-Acelerando-HLS/#testando-x86","text":"Note Deve ser feito no centos (docker) Para testar, vamos compilar o nosso projeto para x86 (n\u00e3o ser\u00e1 um hardware) e validar se nossa l\u00f3gica est\u00e1 correta. Se funcionar, compilamos para hardware. Para compilar basta usarmos o compilador i++ como no exemplo a seguir: $ i++ image.cpp -march = x86-64 -o image_x86 E testar o programa gerado: $ ./image_x86 O resultado deve ser a bel\u00edssima foto img.ppm do seu professor, processada com um offset ( out.ppm ): Tip Para gerar uma imagem do tipo ppm voc\u00ea pode usar o Gimp Note Essa execu\u00e7\u00e3o \u00e9 como se tiv\u00e9ssemos compilado com gcc, s\u00f3 serve para validar l\u00f3gica input output img.pgm image (bin\u00e1rio) image.cpp out.pgm","title":"Testando (x86)"},{"location":"Tutorial-Acelerando-HLS/#acelerando-na-fpga","text":"Para acelerar na FPGA, vamos compilar novamente a aplica\u00e7\u00e3o, por\u00e9m agora com a flag -march=CycloneV que representa a nossa FPGA $ i++ image.cpp -march = CycloneV -o image-CycloneV Note Isso pode bastante tempo, o que ele vai fazer \u00e9: Gerar um HDL a partir da sua fun\u00e7\u00e3o Criar um componente para o Platform Designer input output img.pgm image-CycloneV.prj (pasta)","title":"Acelerando na FPGA"},{"location":"Tutorial-Acelerando-HLS/#image-cyclonevprj-pasta","text":"Se reparar na pasta do projeto, deve ter uma pasta nova: image-CycloneV.prj , com o seguinte conte\u00fado: components : Pasta com o componente criado (para ser usado no Platform designer) quartus : Pasta do projeto Quartus utilizado para compilar o componente, n\u00e3o vamos usar report : Pasta com reports gerado pela ferramenta (html) report : Pasta para simular o projeto","title":"image-CycloneV.prj (pasta)"},{"location":"Tutorial-Acelerando-HLS/#testando","text":"Agora podemos testar nossa aplica\u00e7\u00e3o utilizando o hardware criado pelo HLS, para isso basta executar o novo bin\u00e1rio criado quando compilamos para a arquitetura CycloneV . $ ./image-CycloneV Warning Isso vai levar muito tempo! No monstrinho do lab de Arquitetura, levou mais de 1 hora! Essa simula\u00e7\u00e3o \u00e9 realizada no modelsim! A n\u00edvel de hardware. O resultado ser\u00e1 o esperado quando formos embarcar na FPGA. Com essa simula\u00e7\u00e3o conseguimos verificar erros de arredondamento, acesso a mem\u00f3ria, entre outros. Tipa A imagem out-CycloneV.pgm que est\u00e1 na pasta do projeto, \u00e9 o resultado dessa simula\u00e7\u00e3o.","title":"testando"},{"location":"Tutorial-Acelerando-HLS/#report","text":"O HLS gera um relat\u00f3rio da compila\u00e7\u00e3o do hardware, ele pode ser encontrado em: reports/report.html . Um report interessante de se analisar \u00e9 o Loops analysis , que demonstra os loops do programa:","title":"report"},{"location":"Tutorial-Acelerando-HLS/#otimizando","text":"Podemos aplicar diversas t\u00e9cnicas de paraleliza\u00e7\u00e3o no software que ir\u00e1 impactar no hardware criado (\u00e1rea e performance), no manual do HLS ( Intel High Level Synthesis Compiler: Reference Manual ) tem a documenta\u00e7\u00e3o que descreve cada uma das t\u00e9cnicas. Vamos utilizar a do Loop Unrolling , que permite executarmos um loop paralelo: #pragma unroll <N> for ( int i = 0 ; i < M ; ++ i ) { // Some useful work } Tip N \u00e9 a quantidade de loops a serem executado em //. Vamos paralelizar a varredura da linha em 8 execu\u00e7\u00f5es em paralelo, para isso adicione no for que varre a linha (x): for ( int y = 0 ; y < N ; y ++ ){ #pragma unroll 8 for ( int x = 0 ; x < N ; x ++ ){","title":"Otimizando"},{"location":"Tutorial-Acelerando-HLS/#criando-um-hardware","text":"Agora com o componente criado \u00e9 necess\u00e1rio adicionarmos ele no hardware, isso ser\u00e1 feito via Plataform Design. Para facilitar o desenvolvimento, vamos usar o projeto de hw exemplo da Terasic : DE10_Standard_FB e modificar inserindo o componente e duas mem\u00f3rias, como indicado a seguir:","title":"Criando um hardware"},{"location":"Tutorial-FPGA-NIOS-IP/","text":"Tutorial 3 - FPGA - IP \u00b6 2020-2 Material atualizado. Nesse tutorial iremos desenvolver um perif\u00e9rico customizado para o processador NIOS, esse perif\u00e9rico ser\u00e1 dedicado ao controle dos LEDs da placa. O perif\u00e9rico ter\u00e1 um banco de registradores interno para seu controle, e interface de \"I/O mapeado em mem\u00f3ria\" para que possamos controlar-lo do NIOS (pelo c\u00f3digo em C). Come\u00e7ando \u00b6 Para seguir esse tutorial, \u00e9 necess\u00e1rio: Hardware: DE10-Standard e acess\u00f3rios Softwares: Quartus 18.01 Modelsim Simulator Entrega no git: Pasta: Lab3_FPGA_IP/ IP Cores \u00b6 Intelectual Proprety Core ( IP Core ) s\u00e3o componentes descritos em HDL que podem ser utilizados em m\u00faltiplos projetos de Hardware. O Platform Designer (PD) fornece al\u00e9m da interface visual de conex\u00e3o entre esses IPs um padr\u00e3o de comunica\u00e7\u00e3o entre os componentes, facilitando assim o uso desses IPs. Al\u00e9m das centenas de projetos espalhados pela internet (github), existe um reposit\u00f3rio muito completo de IP cores opensource que concentra grande variedade de projeto: opencores As empresas tamb\u00e9m disponibilizando IPs, pagos e gratuitos: Intel-FPGA IP cores Platform Desginer \u00b6 O PD \u00e9 uma ferramenta integradora de IPs, com ela \u00e9 muito simples inserirmos e criarmos componentes que ser\u00e3o utilizados para formar um sistema mais completo. Como no caso do tutorial passado onde usamos uma s\u00e9rie de componentes para criar nosso projeto. Esses componentes s\u00e3o de certa forma IPs (simples como o PIO e complexo como o NIOS). A integra\u00e7\u00e3o dos IPs no PD se da devido \u00e0 padroniza\u00e7\u00e3o da comunica\u00e7\u00e3o entre esses componentes, que \u00e9 dada via o barramento. Barramentos \u00b6 A Intel-FPGA define duas categorias de barramento de dados para o PD: Avalon e AXI . O barramento Avalon \u00e9 a principal maneira de conectar um perif\u00e9rico ao NIOS (processador), j\u00e1 o AXI \u00e9 o padr\u00e3o de barramento do ARM, que tamb\u00e9m \u00e9 utilizado no platform designer. Avalon \u00b6 Info Documenta\u00e7\u00e3o completa dos barramento AVALON: https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/manual/mnl_avalon_spec.pdf O barramento Avalon define basicamente dois tipos de m\u00f3dulos: Memory Mapped (MM) e Avalon Streaming Interface (ST) , conforme descri\u00e7\u00e3o a seguir extra\u00eddo da documenta\u00e7\u00e3o: Avalon Streaming Interface (Avalon-ST) \u2014 an interface that supports the unidirectional flow of data, including multiplexed streams, packets, and DSP data. Avalon Memory Mapped Interface (Avalon-MM) \u2014 an address-based read/write interface typical of master\u2013slave connections. Avalon Conduit Interfae \u2014 an interface type that accommodates individual signals or groups of signals that do not fit into any of the other Avalon types. You can connect conduit interfaces inside a Platform Designer system. Or, you can export them to make connections to other modules in the design or to FPGA pins. Avalon Tri-State Conduit Interface - (an interface to support connections to off-chip peripherals. Multiple peripherals can share pins through signal multiplexing, reducing the pin count of the FPGA and the number of traces on the PCB. Avalon Interrupt Interface \u2014 an interface that allows components to signal events to other components. Avalon Clock Interface* \u2014 an interface that drives or receives clocks. Avalon Reset Interface \u2014 an interface that provides reset connectivity. Tip Iremos trabalhar com o tipo: Avalon-MM como maneira de conectar o perif\u00e9rico ao NIOS. Projeto \u00b6 Note Vamos melhorar o projeto passado, fa\u00e7a uma c\u00f3pia da pasta do projeto: Lab2_FPGA_NIOS/ e renomeei para: Lab3_FPGA_IP/ . Iremos agora trabalhar nessa nova pasta. Criando um perif\u00e9rico \u00b6 Vamos criar um novo componente que ser\u00e1 capaz de controlar os LEDs com maior autonomia. Roteiro a ser seguido: Especifica\u00e7\u00e3o Gerar HDL que representa o perif\u00e9rico com interface Avalon Criar o componente no Platform Designer Associar arquivos ao componente Defini\u00e7\u00f5es gerais Associar as portas do componente com os sinais do barramento Usar componente no projeto Criar driver ( .c e .h ) Simular Implementar/ Testar Rever especifica\u00e7\u00e3o (1.) Primeiramente precisamos definir o papel principal desse perif\u00e9rico e seu fluxo de dados. Com isso ser\u00e1 poss\u00edvel definir se o perif\u00e9rico \u00e9 do tipo: Master ou Slave e se sua interface \u00e9 do tipo Memory Mapped ou Streaming . Um perif\u00e9rico pode possuir mais de uma interface, por exemplo: Um perif\u00e9rico que ir\u00e1 processar um \u00e1udio em tempo real pode ter at\u00e9 tr\u00eas interfaces: O mesmo ir\u00e1 receber o \u00e1udio via a interface streaming e retornar o dado por outra interface de streaming , por\u00e9m ser\u00e1 necess\u00e1ria uma terceira interface para controle desse perif\u00e9rico, muito provavelmente do tipo Memory Mapped . \u00c9 poss\u00edvel transmitir pacotes de comando pela interface streaming, mas isso torna o projeto mais complexo. O nosso simples perif\u00e9rico ir\u00e1 simplesmente receber configura\u00e7\u00f5es para acionar o LED, sem nenhum fluxo cont\u00ednuo ou intenso de dados, sendo a interface mais apropriada a do perif\u00e9rico mapeado em mem\u00f3ria . Al\u00e9m disso, nosso perif\u00e9rico exclusivo para controle do LED \u00e9 um slave do sistema, j\u00e1 que ele deve ser controlado por outra parte do sistema (no nosso caso o uC) para agir conforme necess\u00e1rio. Avalon Slave Memory Mapped \u00b6 Para nosso perif\u00e9rico se comunicar com o processador precisamos implementar o padr\u00e3o de comunica\u00e7\u00e3o utilizado pelo NIOS. Podemos optar por implementar o padr\u00e3o completo ou apenas uma parte de sua especifica\u00e7\u00e3o. Por exemplo, se nosso perif\u00e9rico n\u00e3o faz uso do waitrequest ou byteenable podemos optar por n\u00e3o implementar esses sinais. A seguir um exemplo dos sinais de um perif\u00e9rico mapeado em mem\u00f3ria que possui como interface com o Avalon-MM-Slave . entity peripheral_MM is port ( -- Gloabals clk : in std_logic := '0' ; reset : in std_logic := '0' ; -- Avalon Memmory Mapped Slave avs_address : in std_logic_vector ( 3 downto 0 ) := ( others => '0' ); avs_read : in std_logic := '0' ; avs_readdata : out std_logic_vector ( 31 downto 0 ) := ( others => '0' ); avs_write : in std_logic := '0' ; avs_writedata : in std_logic_vector ( 31 downto 0 ) := ( others => '0' ) ); end entity peripheral_MM ; Note que a primeira parte do componente define um sinal de clock ( clk ) e um sinal de reset ( reset ), lembre que projetos digitais em FPGA devem ser na maioria das vezes s\u00edncronos. A segunda parte \u00e9 a defini\u00e7\u00e3o dos sinais que ir\u00e3o ser conectados no barramento para acesso de outros perif\u00e9ricos. Lembrem que estamos criando um componente mapeado em mem\u00f3ria, logo o mesmo deve ter comportamento e interface similar ao de uma mem\u00f3ria. avs_address : Endere\u00e7o de acesso ao componente, no caso, 4 bits. avs_read : Indica que \u00e9 um acesso de leitura avs_readdata : Dado que ser\u00e1 retornado ao Master dado um acesso de leitura. avs_write : Indica que \u00e9 um acesso de escrita avs_writedata : Dado que \u00e9 transmitido ao componente dado um acesso de escrita. O tamanho da palavra do avs_readdata e do avs_writadata \u00e9 definido pelo componente e n\u00e3o \u00e9 fixo em 32 bits como no exemplo, pode assumir outros valores. Uma escrita ao perif\u00e9rico \u00e9 dada da seguinte forma: Master endere\u00e7a perif\u00e9rico Endere\u00e7o absoluto \u00e9 traduzido em relativo O endere\u00e7o que o master escreve no perif\u00e9rico \u00e9 composto por: addr offset por\u00e9m o slave s\u00f3 possui acesso ao offset . Perif\u00e9rico recebe: avs_address , avs_write = '1' e avs_writedata . Uma leitura ao perif\u00e9rico \u00e9 dada da seguinte forma: Master endere\u00e7a perif\u00e9rico Endere\u00e7o absoluto \u00e9 traduzido em relativo Perif\u00e9rico recebe: avs_adddress e avs_read = '1' Perif\u00e9rico atualiza: avs_readdata Perguntas O barramento AVALON define outros sinais, responda a seguir sobre alguns desses sinais: waitrequest Qual o papel do waitrequest? Quem aciona o waitrequest (Slave ou Master)? byteenable Qual o papel do byteenable? Quem aciona o byteenable (Slave ou Master)? Especifica\u00e7\u00e3o \u00b6 Nosso perif\u00e9rico ser\u00e1 no come\u00e7o bem simples, apenas para entendermos todo o processo de desenvolvimento de um perif\u00e9rico e o seu uso. O perif\u00e9rico que iremos desenvolver ser\u00e1 um substituto ao perif\u00e9rico PIO fornecido pela Intel-FPGA, utilizado no projeto do pisca LED com o NIOS. Nosso perif\u00e9rico ser\u00e1 mapeado em mem\u00f3ria e possuir\u00e1 um conduit (sa\u00edda) onde ser\u00e1 realizada o acionamento dos LEDs: O acesso ao nosso perif\u00e9rico ser\u00e1 por uma palavra de 32 bits (para mater um padr\u00e3o com o NIOS) e ter\u00e1 dois registradores REG_CONFIG e REG_DATA : REG_CONIFG : Registrador que controla o perif\u00e9rico, no nosso caso, ir\u00e1 ter somente um bit de: Enable / Disable ( bit0 Enable/Disable ) REG_DATA : Registrador que possui o valor de cada LED ( bit0 LED0 ; bit1 LED1 ....). Gerar HDL que representa o perif\u00e9rico com interface Avalon \u00b6 Partindo da entidade fornecida ( peripheral_MM ), podemos criar um componente que implementa parcialmente a especifica\u00e7\u00e3o anterior, nessa implementa\u00e7\u00e3o n\u00e3o temos os dois registradores ( REG_CONFIG e REG_DATA ), temos apenas a funcionalidade do REG_DATA . Note que a implementa\u00e7\u00e3o faz uso de um generic para definir a quantidade de LEDs que esse perif\u00e9rico controla. Esse gen\u00e9rico poder\u00e1 ser configurado pela interface gr\u00e1fica do Plataform Designer, tornando um componente customizado. Info Crie um arquivo chamado: peripheral_LED.vhd e salve na pasta do projeto : Lab3_FPGA_IP/IP/ Ser\u00e1 necess\u00e1rio criar a pasta IP library IEEE ; use IEEE.std_logic_1164. all ; use IEEE.std_logic_unsigned. all ; use IEEE.numeric_std. all ; use work. all ; entity peripheral_LED is generic ( LEN : natural := 4 ); port ( -- Gloabals clk : in std_logic := '0' ; reset : in std_logic := '0' ; -- I/Os LEDs : out std_logic_vector ( LEN - 1 downto 0 ) := ( others => '0' ); -- Avalion Memmory Mapped Slave avs_address : in std_logic_vector ( 3 downto 0 ) := ( others => '0' ); avs_read : in std_logic := '0' ; avs_readdata : out std_logic_vector ( 31 downto 0 ) := ( others => '0' ); avs_write : in std_logic := '0' ; avs_writedata : in std_logic_vector ( 31 downto 0 ) := ( others => '0' ) ); end entity peripheral_LED ; architecture rtl of peripheral_LED is begin process ( clk ) begin if ( reset = '1' ) then LEDs <= ( others => '0' ); elsif ( rising_edge ( clk )) then if ( avs_address = \"0001\" ) then -- REG_DATA if ( avs_write = '1' ) then LEDs <= avs_writedata ( LEN - 1 downto 0 ); end if ; end if ; end if ; end process ; end rtl ; Limita\u00e7\u00f5es dessa implementa\u00e7\u00e3o N\u00e3o possui um registrador de configura\u00e7\u00e3o: REG_CONFIG N\u00e3o \u00e9 poss\u00edvel ler: REG_DATA via barramento Avalon impede a aplica\u00e7\u00e3o de m\u00e1scaras! Poder\u00edamos j\u00e1 nessa etapa testar o componente, criando um testbench para excitar o m\u00f3dulo e verificar seu comportamento. Grande parte do desenvolvimento de um projeto de hardware \u00e9 gasto nos testes, que podem ser t\u00e3o complexos quanto o pr\u00f3prio m\u00f3dulo. Vamos pular essa etapa aqui, iremos simular em um n\u00edvel mais alto. Configurando path \u00b6 Agora iremos adicionar o nosso perif\u00e9rico no Platform Designer , esse novo componente que ser\u00e1 criado ser\u00e1 incorporado na ferramenta, para isso: Precisamos indicar para o PD o local que ele deve buscar para encontrar por c\u00f3digos fonte que n\u00e3o fazem parte do cat\u00e1logo padr\u00e3o, para isso: Tools Options IP Search Path Adicione a pasta IP rec\u00e9m criada. E agora remova o componente PIO: Remova o PIO que controlava os LEDs (agora iremos fazer o controle pelo nosso componente) Criando componente \u00b6 S\u00f3 adicionar o arquivo HDL ( .vhd ou .v ) n\u00e3o \u00e9 suficiente para o PD reconhecer o componente, precisamos criar um segundo arquivo ( *_hw.tcl ) que \u00e9 lido pelo PD, esse arquivo possuir\u00e1 todas as configura\u00e7\u00f5es e descri\u00e7\u00f5es do novo componente. Para isso: File New Component E uma interface gr\u00e1fica de configura\u00e7\u00e3o do componente ser\u00e1 exibida. A primeira parte \u00e9 referente a descri\u00e7\u00e3o do pr\u00f3prio componente. De o nome desse componente de : peripheral_LED e preencha sua descri\u00e7\u00e3o. J\u00e1 na aba Files temos as informa\u00e7\u00f5es de quais arquivos pertencem ao componente. Files \u00b6 Na aba Files adicione o arquivo peripheral_LED.vhd : Files Syntesis Files add file peripheral_LED.vhd Clique em Analyze Synthesis Files : isso far\u00e1 com que a ferramenta fa\u00e7a uma breve an\u00e1lise dos arquivos HDL e detecte as interfaces do componente. Note o atributo do arquivo: Top-level File , isso indica que o peripheral_LED.vhd \u00e9 o arquivo principal desse componente, se tiv\u00e9ssemos um desenvolvimento hier\u00e1rquico do componente, nessa etapa adicionar\u00edamos v\u00e1rios arquivos e dever\u00edamos configurar qual deles \u00e9 o toplevel. Na sec\u00e7\u00e3o VHDL Simulation Files Copy from Synthesis Files Note que se n\u00e3o adicionarmos esse arquivo nessa sec\u00e7\u00e3o, na hora de simular o projeto o componente estaria vazio. Porqu\u00ea o padr\u00e3o n\u00e3o \u00e9 o de automaticamente copiar os arquivos da s\u00edntese para a simula\u00e7\u00e3o? Pois nem sempre conseguimos simular o que ser\u00e1 sintetizado. Pense no caso desse componente ser um controlador de mem\u00f3ria, se formos simular n\u00e3o teremos a mem\u00f3ria f\u00edsica para o controlador acessar e a simula\u00e7\u00e3o n\u00e3o funcionar\u00e1. Uma solu\u00e7\u00e3o seria de ter dois componentes, um para simula\u00e7\u00e3o (que imita a mem\u00f3ria) e outro para s\u00edntese. Signals & Interfaces \u00b6 Nessa sec\u00e7\u00e3o iremos configurar as interfaces do nosso componente, e como o PD ir\u00e1 interpret\u00e1-las quando formos conectar ao resto do sistema. Note que algumas interfaces j\u00e1 foram detectadas pelo PD, por\u00e9m temos um erro que ser\u00e1 corrigido. Nas interfaces padr\u00f5es note que o Component Editor j\u00e1 detectou uma interface: avalon_slave_0 clock reset Isso aconteceu pelos nomes da entidade do peripheral_led . Vamos primeiramente editar o avalon_slave_0 . Clique na interface e note que a ferramenta indica um erro : Failure Error: avalon_slave_0_1: Interface must have an associated reset Vamos associar ter que associar um sinal der reset a interface (parte sequ\u00eancia do IP), para isso : avalon_slave_0 Associated Reset reset Podemos notar ainda pelo diagrama (e pela mensagem de erro) que a ferramenta interpretou de forma errada o nosso sinal LEDs , pertencente a entidade do componente: -- I/Os LEDs : out std_logic_vector(LEN - 1 downto 0) := (others => '0'); Note pelo diagrama de blocos que o PD atribui essa sa\u00edda como sendo parte do barramento Avalon: writerequestvalid_n , o que n\u00e3o \u00e9 verdade. Para corrigir isso, precisamos de uma nova aba que n\u00e3o \u00e9 padr\u00e3o de exibi\u00e7\u00e3o, no component builder clique em: Component builder View Signals Essa nova aba permite verificarmos (e associarmos) as entradas e sa\u00eddas da entidade (toplevel) com sinais e tipos de sinais definido pelo PD. Iremos indicar agora para a ferramenta que o sinal LEDs deve ser interpretado como um conduite , edite os sinais como na figura a seguir : Finalizando \u00b6 Verifique os sinais e o diagrama de bloco antes de continuar e clique em Finish . Quando o componente for gerado, ele automaticamente ir\u00e1 aparecer no cat\u00e1logo de componentes que podem ser inseridos no SoC: Por\u00e9m o arquivo de configura\u00e7\u00e3o desse componente (.tcl) foi salvo na pasta raiz do projeto do Quartus: Lab3_FPGA_IP/peripheral_LED_hw.tcl Esse arquivo .tcl descreve todas as configura\u00e7\u00f5es realizadas anteriormente no componente. O mais natural \u00e9 que esse arquivo esteja na mesma localidade (pasta IP) que os c\u00f3digos HDL. Mova essa arquivo para: Lab3_FPGA_IP/IP/peripheral_LED_hw.tcl Agora precisamos editar o arquivo .tcl para atualizarmos o local do arquivo peripheral_LED.vhd , procure pela sec\u00e7\u00e3o files set : Antes add_fileset_file peripheral_LED.vhd VHDL PATH IP / peripheral_LED.vhd TOP_LEVEL_FILE ... add_fileset_file peripheral_LED.vhd VHDL PATH IP / peripheral_LED.vhd E edite para: add_fileset_file peripheral_LED.vhd VHDL PATH peripheral_LED.vhd TOP_LEVEL_FILE ... add_fileset_file peripheral_LED.vhd VHDL PATH peripheral_LED.vhd Utilizando o componente no PD \u00b6 Agora adicione o componente no projeto e fa\u00e7a as conex\u00f5es corretas (como se fosse outro componente), exporte o sinal dos LEDs, o resultado final deve ser algo como: Gere o componente: Clique em Generate HDL Generate . Marque a op\u00e7\u00e3o: \u2705 Create a Simulation Model Utilizando o componente no topLevel.vhd \u00b6 Precisamos agora modificar o componente inserido no topLevel, para isso no PD gere novamente o template de utiliza\u00e7\u00e3o : No Platform Designer: Generate Show Instatiation Template VHDL No meu caso o resultado foi: component niosHello is port ( buts_export : in std_logic_vector(2 downto 0) := (others => 'X'); -- export clk_clk : in std_logic := 'X'; -- clk reset_reset_n : in std_logic := 'X'; -- reset_n leds_name : out std_logic_vector(3 downto 0) -- name ); end component niosHello; u0 : component niosHello port map ( buts_export => CONNECTED_TO_buts_export, -- buts.export clk_clk => CONNECTED_TO_clk_clk, -- clk.clk reset_reset_n => CONNECTED_TO_reset_reset_n, -- reset.reset_n leds_name => CONNECTED_TO_leds_name -- leds.name ); Devemos inserir agora esse componente com a nova interface ( leds_name ) no Lab3_FPGA_IP.vhd . Voc\u00ea deve fazer essa etapa com cuidado. Esses nomes podem alterar entre vers\u00f5es da ferramenta. Editando o Lab3_FPGA_IP.vhd : Recompile Salve, compile o projeto e programe a FPGA Podemos analisar agora o RTL do projeto e mais especificamente o do componente criado: Verificamos que a ferramenta inferiu um registrador de 4 bits para armazenar o valor dos LEDs, um Mux para indicar se os registradores ser\u00e3o ou n\u00e3o atualizados com um novo valor e um comparador para verificar se o endere\u00e7o \u00e9 equivalente a 0x01 . Firmware \u00b6 Devemos agora escrever um firmware que ser\u00e1 executado no NIOS e que acesse e controle nosso perif\u00e9rico. Para isso ser\u00e1 necess\u00e1rio criarmos um BSP para o projeto. Abra o NIOS II Software Build ... e refa\u00e7a a etapa do tutorial anterior com o novo SoC e adicione o c\u00f3digo a seguir: #include <stdio.h> #include \"system.h\" #include <alt_types.h> #include <io.h> /* Leiutura e escrita no Avalon */ //#define SIM // LED Peripheral #define REG_DATA_OFFSET 1 int main ( void ){ unsigned int led = 0 ; unsigned int * p_led = ( unsigned int * ) PERIPHERAL_LED_0_BASE ; #ifndef SIM printf ( \"Embarcados++ \\n \" ); #endif while ( 1 ){ if ( led < 4 ){ * ( p_led + REG_DATA_OFFSET ) = ( 0x1 << led ++ ); #ifndef SIM usleep ( 500000 ); // remover durante a simula\u00e7\u00e3o #endif } else { led = 0 ; } }; return 0 ; } O firmware utiliza o peripheral_LED para controlar os LEDs da placa, note que o acesso dessa vez \u00e9 feito pelo ponteiro p_led e n\u00e3o mais pela fun\u00e7\u00e3o da Alteara IOWR_32DIRECT (deveria funcionar tamb\u00e9m). Executando \u00b6 Execute o firmware no kit de desenvolvimento e verifique se sua funcionalidade est\u00e1 correta. Lembre que o HW j\u00e1 deve estar programado (via quartus), caso contr\u00e1rio n\u00e3o funcionar\u00e1. Simulando \u00b6 Uma das grandes vantagens de trabalharmos com SoftProcessor \u00e9 que temos acesso ao seu c\u00f3digo fonte (criptografado ou n\u00e3o) e isso possibilita que possamos simular todo o sistema, verificando suas funcionalidades internas, comunica\u00e7\u00e3o da CPU com os perif\u00e9ricos, interface do firmware com o resto do sistema. Vamos nessa etapa simular a interface do NIOS com o nosso perif\u00e9rico e verificar se est\u00e1 tudo certo. Note que no c\u00f3digo anterior, o printf foi comentando, assim como o delay de 50000 us, que no lugar foi inserido um de 1us. Isso foi feito para acelerar a simula\u00e7\u00e3o e verificarmos mais rapidamente o acesso do NIOS ao perif\u00e9rico, que acontece na linha : * ( p_led + REG_DATA_OFFSET ) = ( 0x1 << led ++ ); Nesse momento, o NIOS envia um comando ao barramento no endere\u00e7o PERIPHERAL_LED_0_BASE + REG_DATA_OFFSET , o comando carrega a mensagem: 0x01 << led , gravando no registrador REG_DATA qual LED deve ser acionado. Configurando o bsp \u00b6 Para obtermos um resultado mais r\u00e1pido \u00e9 poss\u00edvel ativarmos uma op\u00e7\u00e3o no bsp chamada de: enable_sim_opitimize . Quando ativada, o bin\u00e1rio compilado s\u00f3 poder\u00e1 ser usado para simula\u00e7\u00e3o, n\u00e3o pode ser embarcado no HW! . Com essa op\u00e7\u00e3o temos um ganho significativo no tempo de execu\u00e7\u00e3o do modelo no modelsim. Al\u00e9m de configurarmos a otimiza\u00e7\u00e3o durante a simula\u00e7\u00e3o, iremos desativar o stdin, stdout, stderr para a simula\u00e7\u00e3o ficar ainda mais r\u00e1pida, caso contr\u00e1rio teremos que esperar por muito tempo at\u00e9 verificarmos o resultado do c\u00f3digo. Note que a simula\u00e7\u00e3o abrange todo o HW desde o processador at\u00e9 o barramento e perif\u00e9ricos. Note Para simularmos 1 ms de execu\u00e7\u00e3o do HW ser\u00e1 necess\u00e1rio muito mais que 1 ms de esfor\u00e7o computacional! O tempo pode chegar a unidades de hora!! ModelSim \u00b6 No Eclipse , ap\u00f3s ter compilado o projeto: Run Run configuration Nios II ModelSim O simulador a ser utilizado \u00e9 o modelsim da Mentor, o mais completo do mercado e fornecido com algumas customiza\u00e7\u00f5es pela Intel-FPGA. No modelsim, iremos adicionar os sinais que desejamos visualizar, para isso, siga o que indica a figura a seguir: Ap\u00f3s adicionar todos os sinais que fazem parte do perif\u00e9rico led_peripheral iremos executar 500 us de simula\u00e7\u00e3o: Ap\u00f3s a simula\u00e7\u00e3o finalizar, note os valore dos sinais avs_write , avs_writedata , avs_LEDs e como eles mudam no tempo em respeito ao que foi feito no c\u00f3digo. Praticando \u00b6 Fa\u00e7a o perif\u00e9rico ter 6 sa\u00eddas (6 LEDs) Fa\u00e7a os LEDs piscarem por HW, adicione um registrador para controlar a frequ\u00eancia. Como colocar as chaves no perif\u00e9rico para que o NIOS tenha acesso a elas? Entrega 3 \u00b6 Siga para a terceira entrega: Entega 3","title":"Tutorial 3 - FPGA - IP"},{"location":"Tutorial-FPGA-NIOS-IP/#tutorial-3-fpga-ip","text":"2020-2 Material atualizado. Nesse tutorial iremos desenvolver um perif\u00e9rico customizado para o processador NIOS, esse perif\u00e9rico ser\u00e1 dedicado ao controle dos LEDs da placa. O perif\u00e9rico ter\u00e1 um banco de registradores interno para seu controle, e interface de \"I/O mapeado em mem\u00f3ria\" para que possamos controlar-lo do NIOS (pelo c\u00f3digo em C).","title":"Tutorial 3 - FPGA - IP"},{"location":"Tutorial-FPGA-NIOS-IP/#comecando","text":"Para seguir esse tutorial, \u00e9 necess\u00e1rio: Hardware: DE10-Standard e acess\u00f3rios Softwares: Quartus 18.01 Modelsim Simulator Entrega no git: Pasta: Lab3_FPGA_IP/","title":"Come\u00e7ando"},{"location":"Tutorial-FPGA-NIOS-IP/#ip-cores","text":"Intelectual Proprety Core ( IP Core ) s\u00e3o componentes descritos em HDL que podem ser utilizados em m\u00faltiplos projetos de Hardware. O Platform Designer (PD) fornece al\u00e9m da interface visual de conex\u00e3o entre esses IPs um padr\u00e3o de comunica\u00e7\u00e3o entre os componentes, facilitando assim o uso desses IPs. Al\u00e9m das centenas de projetos espalhados pela internet (github), existe um reposit\u00f3rio muito completo de IP cores opensource que concentra grande variedade de projeto: opencores As empresas tamb\u00e9m disponibilizando IPs, pagos e gratuitos: Intel-FPGA IP cores","title":"IP Cores"},{"location":"Tutorial-FPGA-NIOS-IP/#platform-desginer","text":"O PD \u00e9 uma ferramenta integradora de IPs, com ela \u00e9 muito simples inserirmos e criarmos componentes que ser\u00e3o utilizados para formar um sistema mais completo. Como no caso do tutorial passado onde usamos uma s\u00e9rie de componentes para criar nosso projeto. Esses componentes s\u00e3o de certa forma IPs (simples como o PIO e complexo como o NIOS). A integra\u00e7\u00e3o dos IPs no PD se da devido \u00e0 padroniza\u00e7\u00e3o da comunica\u00e7\u00e3o entre esses componentes, que \u00e9 dada via o barramento.","title":"Platform Desginer"},{"location":"Tutorial-FPGA-NIOS-IP/#barramentos","text":"A Intel-FPGA define duas categorias de barramento de dados para o PD: Avalon e AXI . O barramento Avalon \u00e9 a principal maneira de conectar um perif\u00e9rico ao NIOS (processador), j\u00e1 o AXI \u00e9 o padr\u00e3o de barramento do ARM, que tamb\u00e9m \u00e9 utilizado no platform designer.","title":"Barramentos"},{"location":"Tutorial-FPGA-NIOS-IP/#avalon","text":"Info Documenta\u00e7\u00e3o completa dos barramento AVALON: https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/manual/mnl_avalon_spec.pdf O barramento Avalon define basicamente dois tipos de m\u00f3dulos: Memory Mapped (MM) e Avalon Streaming Interface (ST) , conforme descri\u00e7\u00e3o a seguir extra\u00eddo da documenta\u00e7\u00e3o: Avalon Streaming Interface (Avalon-ST) \u2014 an interface that supports the unidirectional flow of data, including multiplexed streams, packets, and DSP data. Avalon Memory Mapped Interface (Avalon-MM) \u2014 an address-based read/write interface typical of master\u2013slave connections. Avalon Conduit Interfae \u2014 an interface type that accommodates individual signals or groups of signals that do not fit into any of the other Avalon types. You can connect conduit interfaces inside a Platform Designer system. Or, you can export them to make connections to other modules in the design or to FPGA pins. Avalon Tri-State Conduit Interface - (an interface to support connections to off-chip peripherals. Multiple peripherals can share pins through signal multiplexing, reducing the pin count of the FPGA and the number of traces on the PCB. Avalon Interrupt Interface \u2014 an interface that allows components to signal events to other components. Avalon Clock Interface* \u2014 an interface that drives or receives clocks. Avalon Reset Interface \u2014 an interface that provides reset connectivity. Tip Iremos trabalhar com o tipo: Avalon-MM como maneira de conectar o perif\u00e9rico ao NIOS.","title":"Avalon"},{"location":"Tutorial-FPGA-NIOS-IP/#projeto","text":"Note Vamos melhorar o projeto passado, fa\u00e7a uma c\u00f3pia da pasta do projeto: Lab2_FPGA_NIOS/ e renomeei para: Lab3_FPGA_IP/ . Iremos agora trabalhar nessa nova pasta.","title":"Projeto"},{"location":"Tutorial-FPGA-NIOS-IP/#criando-um-periferico","text":"Vamos criar um novo componente que ser\u00e1 capaz de controlar os LEDs com maior autonomia. Roteiro a ser seguido: Especifica\u00e7\u00e3o Gerar HDL que representa o perif\u00e9rico com interface Avalon Criar o componente no Platform Designer Associar arquivos ao componente Defini\u00e7\u00f5es gerais Associar as portas do componente com os sinais do barramento Usar componente no projeto Criar driver ( .c e .h ) Simular Implementar/ Testar Rever especifica\u00e7\u00e3o (1.) Primeiramente precisamos definir o papel principal desse perif\u00e9rico e seu fluxo de dados. Com isso ser\u00e1 poss\u00edvel definir se o perif\u00e9rico \u00e9 do tipo: Master ou Slave e se sua interface \u00e9 do tipo Memory Mapped ou Streaming . Um perif\u00e9rico pode possuir mais de uma interface, por exemplo: Um perif\u00e9rico que ir\u00e1 processar um \u00e1udio em tempo real pode ter at\u00e9 tr\u00eas interfaces: O mesmo ir\u00e1 receber o \u00e1udio via a interface streaming e retornar o dado por outra interface de streaming , por\u00e9m ser\u00e1 necess\u00e1ria uma terceira interface para controle desse perif\u00e9rico, muito provavelmente do tipo Memory Mapped . \u00c9 poss\u00edvel transmitir pacotes de comando pela interface streaming, mas isso torna o projeto mais complexo. O nosso simples perif\u00e9rico ir\u00e1 simplesmente receber configura\u00e7\u00f5es para acionar o LED, sem nenhum fluxo cont\u00ednuo ou intenso de dados, sendo a interface mais apropriada a do perif\u00e9rico mapeado em mem\u00f3ria . Al\u00e9m disso, nosso perif\u00e9rico exclusivo para controle do LED \u00e9 um slave do sistema, j\u00e1 que ele deve ser controlado por outra parte do sistema (no nosso caso o uC) para agir conforme necess\u00e1rio.","title":"Criando um perif\u00e9rico"},{"location":"Tutorial-FPGA-NIOS-IP/#avalon-slave-memory-mapped","text":"Para nosso perif\u00e9rico se comunicar com o processador precisamos implementar o padr\u00e3o de comunica\u00e7\u00e3o utilizado pelo NIOS. Podemos optar por implementar o padr\u00e3o completo ou apenas uma parte de sua especifica\u00e7\u00e3o. Por exemplo, se nosso perif\u00e9rico n\u00e3o faz uso do waitrequest ou byteenable podemos optar por n\u00e3o implementar esses sinais. A seguir um exemplo dos sinais de um perif\u00e9rico mapeado em mem\u00f3ria que possui como interface com o Avalon-MM-Slave . entity peripheral_MM is port ( -- Gloabals clk : in std_logic := '0' ; reset : in std_logic := '0' ; -- Avalon Memmory Mapped Slave avs_address : in std_logic_vector ( 3 downto 0 ) := ( others => '0' ); avs_read : in std_logic := '0' ; avs_readdata : out std_logic_vector ( 31 downto 0 ) := ( others => '0' ); avs_write : in std_logic := '0' ; avs_writedata : in std_logic_vector ( 31 downto 0 ) := ( others => '0' ) ); end entity peripheral_MM ; Note que a primeira parte do componente define um sinal de clock ( clk ) e um sinal de reset ( reset ), lembre que projetos digitais em FPGA devem ser na maioria das vezes s\u00edncronos. A segunda parte \u00e9 a defini\u00e7\u00e3o dos sinais que ir\u00e3o ser conectados no barramento para acesso de outros perif\u00e9ricos. Lembrem que estamos criando um componente mapeado em mem\u00f3ria, logo o mesmo deve ter comportamento e interface similar ao de uma mem\u00f3ria. avs_address : Endere\u00e7o de acesso ao componente, no caso, 4 bits. avs_read : Indica que \u00e9 um acesso de leitura avs_readdata : Dado que ser\u00e1 retornado ao Master dado um acesso de leitura. avs_write : Indica que \u00e9 um acesso de escrita avs_writedata : Dado que \u00e9 transmitido ao componente dado um acesso de escrita. O tamanho da palavra do avs_readdata e do avs_writadata \u00e9 definido pelo componente e n\u00e3o \u00e9 fixo em 32 bits como no exemplo, pode assumir outros valores. Uma escrita ao perif\u00e9rico \u00e9 dada da seguinte forma: Master endere\u00e7a perif\u00e9rico Endere\u00e7o absoluto \u00e9 traduzido em relativo O endere\u00e7o que o master escreve no perif\u00e9rico \u00e9 composto por: addr offset por\u00e9m o slave s\u00f3 possui acesso ao offset . Perif\u00e9rico recebe: avs_address , avs_write = '1' e avs_writedata . Uma leitura ao perif\u00e9rico \u00e9 dada da seguinte forma: Master endere\u00e7a perif\u00e9rico Endere\u00e7o absoluto \u00e9 traduzido em relativo Perif\u00e9rico recebe: avs_adddress e avs_read = '1' Perif\u00e9rico atualiza: avs_readdata Perguntas O barramento AVALON define outros sinais, responda a seguir sobre alguns desses sinais: waitrequest Qual o papel do waitrequest? Quem aciona o waitrequest (Slave ou Master)? byteenable Qual o papel do byteenable? Quem aciona o byteenable (Slave ou Master)?","title":"Avalon Slave Memory Mapped"},{"location":"Tutorial-FPGA-NIOS-IP/#especificacao","text":"Nosso perif\u00e9rico ser\u00e1 no come\u00e7o bem simples, apenas para entendermos todo o processo de desenvolvimento de um perif\u00e9rico e o seu uso. O perif\u00e9rico que iremos desenvolver ser\u00e1 um substituto ao perif\u00e9rico PIO fornecido pela Intel-FPGA, utilizado no projeto do pisca LED com o NIOS. Nosso perif\u00e9rico ser\u00e1 mapeado em mem\u00f3ria e possuir\u00e1 um conduit (sa\u00edda) onde ser\u00e1 realizada o acionamento dos LEDs: O acesso ao nosso perif\u00e9rico ser\u00e1 por uma palavra de 32 bits (para mater um padr\u00e3o com o NIOS) e ter\u00e1 dois registradores REG_CONFIG e REG_DATA : REG_CONIFG : Registrador que controla o perif\u00e9rico, no nosso caso, ir\u00e1 ter somente um bit de: Enable / Disable ( bit0 Enable/Disable ) REG_DATA : Registrador que possui o valor de cada LED ( bit0 LED0 ; bit1 LED1 ....).","title":"Especifica\u00e7\u00e3o"},{"location":"Tutorial-FPGA-NIOS-IP/#gerar-hdl-que-representa-o-periferico-com-interface-avalon","text":"Partindo da entidade fornecida ( peripheral_MM ), podemos criar um componente que implementa parcialmente a especifica\u00e7\u00e3o anterior, nessa implementa\u00e7\u00e3o n\u00e3o temos os dois registradores ( REG_CONFIG e REG_DATA ), temos apenas a funcionalidade do REG_DATA . Note que a implementa\u00e7\u00e3o faz uso de um generic para definir a quantidade de LEDs que esse perif\u00e9rico controla. Esse gen\u00e9rico poder\u00e1 ser configurado pela interface gr\u00e1fica do Plataform Designer, tornando um componente customizado. Info Crie um arquivo chamado: peripheral_LED.vhd e salve na pasta do projeto : Lab3_FPGA_IP/IP/ Ser\u00e1 necess\u00e1rio criar a pasta IP library IEEE ; use IEEE.std_logic_1164. all ; use IEEE.std_logic_unsigned. all ; use IEEE.numeric_std. all ; use work. all ; entity peripheral_LED is generic ( LEN : natural := 4 ); port ( -- Gloabals clk : in std_logic := '0' ; reset : in std_logic := '0' ; -- I/Os LEDs : out std_logic_vector ( LEN - 1 downto 0 ) := ( others => '0' ); -- Avalion Memmory Mapped Slave avs_address : in std_logic_vector ( 3 downto 0 ) := ( others => '0' ); avs_read : in std_logic := '0' ; avs_readdata : out std_logic_vector ( 31 downto 0 ) := ( others => '0' ); avs_write : in std_logic := '0' ; avs_writedata : in std_logic_vector ( 31 downto 0 ) := ( others => '0' ) ); end entity peripheral_LED ; architecture rtl of peripheral_LED is begin process ( clk ) begin if ( reset = '1' ) then LEDs <= ( others => '0' ); elsif ( rising_edge ( clk )) then if ( avs_address = \"0001\" ) then -- REG_DATA if ( avs_write = '1' ) then LEDs <= avs_writedata ( LEN - 1 downto 0 ); end if ; end if ; end if ; end process ; end rtl ; Limita\u00e7\u00f5es dessa implementa\u00e7\u00e3o N\u00e3o possui um registrador de configura\u00e7\u00e3o: REG_CONFIG N\u00e3o \u00e9 poss\u00edvel ler: REG_DATA via barramento Avalon impede a aplica\u00e7\u00e3o de m\u00e1scaras! Poder\u00edamos j\u00e1 nessa etapa testar o componente, criando um testbench para excitar o m\u00f3dulo e verificar seu comportamento. Grande parte do desenvolvimento de um projeto de hardware \u00e9 gasto nos testes, que podem ser t\u00e3o complexos quanto o pr\u00f3prio m\u00f3dulo. Vamos pular essa etapa aqui, iremos simular em um n\u00edvel mais alto.","title":"Gerar HDL que representa o perif\u00e9rico com interface Avalon"},{"location":"Tutorial-FPGA-NIOS-IP/#configurando-path","text":"Agora iremos adicionar o nosso perif\u00e9rico no Platform Designer , esse novo componente que ser\u00e1 criado ser\u00e1 incorporado na ferramenta, para isso: Precisamos indicar para o PD o local que ele deve buscar para encontrar por c\u00f3digos fonte que n\u00e3o fazem parte do cat\u00e1logo padr\u00e3o, para isso: Tools Options IP Search Path Adicione a pasta IP rec\u00e9m criada. E agora remova o componente PIO: Remova o PIO que controlava os LEDs (agora iremos fazer o controle pelo nosso componente)","title":"Configurando path"},{"location":"Tutorial-FPGA-NIOS-IP/#criando-componente","text":"S\u00f3 adicionar o arquivo HDL ( .vhd ou .v ) n\u00e3o \u00e9 suficiente para o PD reconhecer o componente, precisamos criar um segundo arquivo ( *_hw.tcl ) que \u00e9 lido pelo PD, esse arquivo possuir\u00e1 todas as configura\u00e7\u00f5es e descri\u00e7\u00f5es do novo componente. Para isso: File New Component E uma interface gr\u00e1fica de configura\u00e7\u00e3o do componente ser\u00e1 exibida. A primeira parte \u00e9 referente a descri\u00e7\u00e3o do pr\u00f3prio componente. De o nome desse componente de : peripheral_LED e preencha sua descri\u00e7\u00e3o. J\u00e1 na aba Files temos as informa\u00e7\u00f5es de quais arquivos pertencem ao componente.","title":"Criando componente"},{"location":"Tutorial-FPGA-NIOS-IP/#files","text":"Na aba Files adicione o arquivo peripheral_LED.vhd : Files Syntesis Files add file peripheral_LED.vhd Clique em Analyze Synthesis Files : isso far\u00e1 com que a ferramenta fa\u00e7a uma breve an\u00e1lise dos arquivos HDL e detecte as interfaces do componente. Note o atributo do arquivo: Top-level File , isso indica que o peripheral_LED.vhd \u00e9 o arquivo principal desse componente, se tiv\u00e9ssemos um desenvolvimento hier\u00e1rquico do componente, nessa etapa adicionar\u00edamos v\u00e1rios arquivos e dever\u00edamos configurar qual deles \u00e9 o toplevel. Na sec\u00e7\u00e3o VHDL Simulation Files Copy from Synthesis Files Note que se n\u00e3o adicionarmos esse arquivo nessa sec\u00e7\u00e3o, na hora de simular o projeto o componente estaria vazio. Porqu\u00ea o padr\u00e3o n\u00e3o \u00e9 o de automaticamente copiar os arquivos da s\u00edntese para a simula\u00e7\u00e3o? Pois nem sempre conseguimos simular o que ser\u00e1 sintetizado. Pense no caso desse componente ser um controlador de mem\u00f3ria, se formos simular n\u00e3o teremos a mem\u00f3ria f\u00edsica para o controlador acessar e a simula\u00e7\u00e3o n\u00e3o funcionar\u00e1. Uma solu\u00e7\u00e3o seria de ter dois componentes, um para simula\u00e7\u00e3o (que imita a mem\u00f3ria) e outro para s\u00edntese.","title":"Files"},{"location":"Tutorial-FPGA-NIOS-IP/#signals-interfaces","text":"Nessa sec\u00e7\u00e3o iremos configurar as interfaces do nosso componente, e como o PD ir\u00e1 interpret\u00e1-las quando formos conectar ao resto do sistema. Note que algumas interfaces j\u00e1 foram detectadas pelo PD, por\u00e9m temos um erro que ser\u00e1 corrigido. Nas interfaces padr\u00f5es note que o Component Editor j\u00e1 detectou uma interface: avalon_slave_0 clock reset Isso aconteceu pelos nomes da entidade do peripheral_led . Vamos primeiramente editar o avalon_slave_0 . Clique na interface e note que a ferramenta indica um erro : Failure Error: avalon_slave_0_1: Interface must have an associated reset Vamos associar ter que associar um sinal der reset a interface (parte sequ\u00eancia do IP), para isso : avalon_slave_0 Associated Reset reset Podemos notar ainda pelo diagrama (e pela mensagem de erro) que a ferramenta interpretou de forma errada o nosso sinal LEDs , pertencente a entidade do componente: -- I/Os LEDs : out std_logic_vector(LEN - 1 downto 0) := (others => '0'); Note pelo diagrama de blocos que o PD atribui essa sa\u00edda como sendo parte do barramento Avalon: writerequestvalid_n , o que n\u00e3o \u00e9 verdade. Para corrigir isso, precisamos de uma nova aba que n\u00e3o \u00e9 padr\u00e3o de exibi\u00e7\u00e3o, no component builder clique em: Component builder View Signals Essa nova aba permite verificarmos (e associarmos) as entradas e sa\u00eddas da entidade (toplevel) com sinais e tipos de sinais definido pelo PD. Iremos indicar agora para a ferramenta que o sinal LEDs deve ser interpretado como um conduite , edite os sinais como na figura a seguir :","title":"Signals &amp; Interfaces"},{"location":"Tutorial-FPGA-NIOS-IP/#finalizando","text":"Verifique os sinais e o diagrama de bloco antes de continuar e clique em Finish . Quando o componente for gerado, ele automaticamente ir\u00e1 aparecer no cat\u00e1logo de componentes que podem ser inseridos no SoC: Por\u00e9m o arquivo de configura\u00e7\u00e3o desse componente (.tcl) foi salvo na pasta raiz do projeto do Quartus: Lab3_FPGA_IP/peripheral_LED_hw.tcl Esse arquivo .tcl descreve todas as configura\u00e7\u00f5es realizadas anteriormente no componente. O mais natural \u00e9 que esse arquivo esteja na mesma localidade (pasta IP) que os c\u00f3digos HDL. Mova essa arquivo para: Lab3_FPGA_IP/IP/peripheral_LED_hw.tcl Agora precisamos editar o arquivo .tcl para atualizarmos o local do arquivo peripheral_LED.vhd , procure pela sec\u00e7\u00e3o files set : Antes add_fileset_file peripheral_LED.vhd VHDL PATH IP / peripheral_LED.vhd TOP_LEVEL_FILE ... add_fileset_file peripheral_LED.vhd VHDL PATH IP / peripheral_LED.vhd E edite para: add_fileset_file peripheral_LED.vhd VHDL PATH peripheral_LED.vhd TOP_LEVEL_FILE ... add_fileset_file peripheral_LED.vhd VHDL PATH peripheral_LED.vhd","title":"Finalizando"},{"location":"Tutorial-FPGA-NIOS-IP/#utilizando-o-componente-no-pd","text":"Agora adicione o componente no projeto e fa\u00e7a as conex\u00f5es corretas (como se fosse outro componente), exporte o sinal dos LEDs, o resultado final deve ser algo como: Gere o componente: Clique em Generate HDL Generate . Marque a op\u00e7\u00e3o: \u2705 Create a Simulation Model","title":"Utilizando o componente no PD"},{"location":"Tutorial-FPGA-NIOS-IP/#utilizando-o-componente-no-toplevelvhd","text":"Precisamos agora modificar o componente inserido no topLevel, para isso no PD gere novamente o template de utiliza\u00e7\u00e3o : No Platform Designer: Generate Show Instatiation Template VHDL No meu caso o resultado foi: component niosHello is port ( buts_export : in std_logic_vector(2 downto 0) := (others => 'X'); -- export clk_clk : in std_logic := 'X'; -- clk reset_reset_n : in std_logic := 'X'; -- reset_n leds_name : out std_logic_vector(3 downto 0) -- name ); end component niosHello; u0 : component niosHello port map ( buts_export => CONNECTED_TO_buts_export, -- buts.export clk_clk => CONNECTED_TO_clk_clk, -- clk.clk reset_reset_n => CONNECTED_TO_reset_reset_n, -- reset.reset_n leds_name => CONNECTED_TO_leds_name -- leds.name ); Devemos inserir agora esse componente com a nova interface ( leds_name ) no Lab3_FPGA_IP.vhd . Voc\u00ea deve fazer essa etapa com cuidado. Esses nomes podem alterar entre vers\u00f5es da ferramenta. Editando o Lab3_FPGA_IP.vhd : Recompile Salve, compile o projeto e programe a FPGA Podemos analisar agora o RTL do projeto e mais especificamente o do componente criado: Verificamos que a ferramenta inferiu um registrador de 4 bits para armazenar o valor dos LEDs, um Mux para indicar se os registradores ser\u00e3o ou n\u00e3o atualizados com um novo valor e um comparador para verificar se o endere\u00e7o \u00e9 equivalente a 0x01 .","title":"Utilizando o componente no topLevel.vhd"},{"location":"Tutorial-FPGA-NIOS-IP/#firmware","text":"Devemos agora escrever um firmware que ser\u00e1 executado no NIOS e que acesse e controle nosso perif\u00e9rico. Para isso ser\u00e1 necess\u00e1rio criarmos um BSP para o projeto. Abra o NIOS II Software Build ... e refa\u00e7a a etapa do tutorial anterior com o novo SoC e adicione o c\u00f3digo a seguir: #include <stdio.h> #include \"system.h\" #include <alt_types.h> #include <io.h> /* Leiutura e escrita no Avalon */ //#define SIM // LED Peripheral #define REG_DATA_OFFSET 1 int main ( void ){ unsigned int led = 0 ; unsigned int * p_led = ( unsigned int * ) PERIPHERAL_LED_0_BASE ; #ifndef SIM printf ( \"Embarcados++ \\n \" ); #endif while ( 1 ){ if ( led < 4 ){ * ( p_led + REG_DATA_OFFSET ) = ( 0x1 << led ++ ); #ifndef SIM usleep ( 500000 ); // remover durante a simula\u00e7\u00e3o #endif } else { led = 0 ; } }; return 0 ; } O firmware utiliza o peripheral_LED para controlar os LEDs da placa, note que o acesso dessa vez \u00e9 feito pelo ponteiro p_led e n\u00e3o mais pela fun\u00e7\u00e3o da Alteara IOWR_32DIRECT (deveria funcionar tamb\u00e9m).","title":"Firmware"},{"location":"Tutorial-FPGA-NIOS-IP/#executando","text":"Execute o firmware no kit de desenvolvimento e verifique se sua funcionalidade est\u00e1 correta. Lembre que o HW j\u00e1 deve estar programado (via quartus), caso contr\u00e1rio n\u00e3o funcionar\u00e1.","title":"Executando"},{"location":"Tutorial-FPGA-NIOS-IP/#simulando","text":"Uma das grandes vantagens de trabalharmos com SoftProcessor \u00e9 que temos acesso ao seu c\u00f3digo fonte (criptografado ou n\u00e3o) e isso possibilita que possamos simular todo o sistema, verificando suas funcionalidades internas, comunica\u00e7\u00e3o da CPU com os perif\u00e9ricos, interface do firmware com o resto do sistema. Vamos nessa etapa simular a interface do NIOS com o nosso perif\u00e9rico e verificar se est\u00e1 tudo certo. Note que no c\u00f3digo anterior, o printf foi comentando, assim como o delay de 50000 us, que no lugar foi inserido um de 1us. Isso foi feito para acelerar a simula\u00e7\u00e3o e verificarmos mais rapidamente o acesso do NIOS ao perif\u00e9rico, que acontece na linha : * ( p_led + REG_DATA_OFFSET ) = ( 0x1 << led ++ ); Nesse momento, o NIOS envia um comando ao barramento no endere\u00e7o PERIPHERAL_LED_0_BASE + REG_DATA_OFFSET , o comando carrega a mensagem: 0x01 << led , gravando no registrador REG_DATA qual LED deve ser acionado.","title":"Simulando"},{"location":"Tutorial-FPGA-NIOS-IP/#configurando-o-bsp","text":"Para obtermos um resultado mais r\u00e1pido \u00e9 poss\u00edvel ativarmos uma op\u00e7\u00e3o no bsp chamada de: enable_sim_opitimize . Quando ativada, o bin\u00e1rio compilado s\u00f3 poder\u00e1 ser usado para simula\u00e7\u00e3o, n\u00e3o pode ser embarcado no HW! . Com essa op\u00e7\u00e3o temos um ganho significativo no tempo de execu\u00e7\u00e3o do modelo no modelsim. Al\u00e9m de configurarmos a otimiza\u00e7\u00e3o durante a simula\u00e7\u00e3o, iremos desativar o stdin, stdout, stderr para a simula\u00e7\u00e3o ficar ainda mais r\u00e1pida, caso contr\u00e1rio teremos que esperar por muito tempo at\u00e9 verificarmos o resultado do c\u00f3digo. Note que a simula\u00e7\u00e3o abrange todo o HW desde o processador at\u00e9 o barramento e perif\u00e9ricos. Note Para simularmos 1 ms de execu\u00e7\u00e3o do HW ser\u00e1 necess\u00e1rio muito mais que 1 ms de esfor\u00e7o computacional! O tempo pode chegar a unidades de hora!!","title":"Configurando o bsp"},{"location":"Tutorial-FPGA-NIOS-IP/#modelsim","text":"No Eclipse , ap\u00f3s ter compilado o projeto: Run Run configuration Nios II ModelSim O simulador a ser utilizado \u00e9 o modelsim da Mentor, o mais completo do mercado e fornecido com algumas customiza\u00e7\u00f5es pela Intel-FPGA. No modelsim, iremos adicionar os sinais que desejamos visualizar, para isso, siga o que indica a figura a seguir: Ap\u00f3s adicionar todos os sinais que fazem parte do perif\u00e9rico led_peripheral iremos executar 500 us de simula\u00e7\u00e3o: Ap\u00f3s a simula\u00e7\u00e3o finalizar, note os valore dos sinais avs_write , avs_writedata , avs_LEDs e como eles mudam no tempo em respeito ao que foi feito no c\u00f3digo.","title":"ModelSim"},{"location":"Tutorial-FPGA-NIOS-IP/#praticando","text":"Fa\u00e7a o perif\u00e9rico ter 6 sa\u00eddas (6 LEDs) Fa\u00e7a os LEDs piscarem por HW, adicione um registrador para controlar a frequ\u00eancia. Como colocar as chaves no perif\u00e9rico para que o NIOS tenha acesso a elas?","title":"Praticando"},{"location":"Tutorial-FPGA-NIOS-IP/#entrega-3","text":"Siga para a terceira entrega: Entega 3","title":"Entrega 3"},{"location":"Tutorial-FPGA-NIOS/","text":"Tutorial 2 - FPGA - NIOS \u00b6 2020-2 Material atualizado. Nesse tutorial iremos criar e customizar um soft processor com o NIOS (sistema embarcado com um processador e perif\u00e9rico), embarcar na FPGA e escrever um c\u00f3digo para ele. Ao final, vamos ter os mesmos LEDs que do projeto anterior, com opera\u00e7\u00e3o simular, mas agora sendo controlados por um programa e n\u00e3o por um hardware dedicado. Come\u00e7ando \u00b6 Para seguir esse tutorial \u00e9 necess\u00e1rio: Hardware: DE10-Standard e acess\u00f3rios Softwares: Quartus 18.01 Documentos: DE10-Standard_User_manual.pdf Entrega no git: Pasta: Lab2_FPGA_NIOS Soft processor \u00b6 Projetos em HDL (VHDL, Verilog, ... ) n\u00e3o s\u00e3o muito flex\u00edveis, cada altera\u00e7\u00e3o no projeto implica na modifica\u00e7\u00e3o do Hardware o que n\u00e3o \u00e9 algo t\u00e3o simples. Al\u00e9m da dificuldade de implementar as modifica\u00e7\u00f5es, temos o tempo de teste e compila\u00e7\u00e3o do projeto que n\u00e3o \u00e9 nada imediato. Uma solu\u00e7\u00e3o para tornar o projeto mais flex\u00edvel \u00e9 o de tornar os LEDs controlados n\u00e3o por uma l\u00f3gica dedicada mas sim por um hardware que possa executar uma s\u00e9rie de instru\u00e7\u00f5es: um microcontrolador. Como a FPGA pode implementar circuitos l\u00f3gicos digitais, \u00e9 poss\u00edvel sintetizarmos um microcontrolador na FPGA e fazermos esse uC controlar os LEDS (Sim!! o uC \u00e9 um hardware descrito em HDL). Agora a altera\u00e7\u00e3o na l\u00f3gica de controle depende do programa que ser\u00e1 executado no uC, tornando o projeto muito mais flex\u00edvel. O ARM tamb\u00e9m \u00e9 um hardware em HDL, s\u00f3 que propriet\u00e1rio: https://www.arm.com/about/newsroom/arm-offers-free-access-to-cortex-m0-processor-ip-to-streamline-embedded-soc-design.php Processadores que s\u00e3o sintetiz\u00e1veis em dispositivos l\u00f3gicos program\u00e1veis (FPGA, ...) s\u00e3o chamados de Soft Processor . Diversos s\u00e3o os Soft Processors dispon\u00edveis comercialmente ou open source: NIOS II: Intel MicroBlazer: Xilinx LEON: Gaisler (aerospacial/ SPARCV8) dentre outros A adi\u00e7\u00e3o de perif\u00e9ricos e funcionalidades extras ao Soft Processor (podemos por exemplo colocar um gerenciador de mem\u00f3ria, timers, controlador de rede, ...) faz com que o sistema passe a ser chamado de System On Chip (SoC). Hard Processor s\u00e3o os microprocessadores tradicionais, que n\u00e3o sofrem altera\u00e7\u00e3o de HW. Plataform Designer ( PD ) \u00b6 O Platform Designer era chamado de QSYS , ainda da para achar muitas coisas com essa refer\u00eancia O Platform Designer \u00e9 um software dispon\u00edvel pela Intel e integrado no Quartus que possibilita desenvolvermos sistemas complexos de forma simples e visual. Com ele podemos adicionar e conectar Intellectual property cores (IP Core) para desenvolvermos uma aplica\u00e7\u00e3o de maneira r\u00e1pida e visual. Os IP cores podem ser da pr\u00f3pria Intel , de terceiros ou propriet\u00e1rios. Indo al\u00e9m Tem um curso online que mostra como o PD funciona: Introduction to Platform Designer NIOS \u00b6 NIOS \u00e9 o soft processor fornecido pela Altera-Intel e integrado na ferramenta. O NIOS \u00e9 baseado na arquitetura do MIPS com arquitetura de 32 bits , controle de exce\u00e7\u00f5es, barramento de comunica\u00e7\u00e3o, controle de mem\u00f3ria, ... . A figura a seguir descreve os componentes essenciais do NIOS (azul) e o que \u00e9 customiz\u00e1vel (cinza). Refer\u00eancia: Processor Architecture O NIOS suporta que novas instru\u00e7\u00f5es sejam adicionadas ao seu instruction set, essas instru\u00e7\u00f5es s\u00e3o implementadas em HDL e inseridas no core de forma transparente ao desenvolvedor. Existem graus de instru\u00e7\u00f5es customizadas: combinacional; multiciclo; estendidas; Que faz uso do banco de registradores original ou aquelas que adicionam novos registradores. Indo al\u00e9m Para maiores detalhes de como customizar o NIOS consulte o documento: Nios II Custom Instruction User Guide Criando um simples SoC \u00b6 Come\u00e7ando implementar. Come\u00e7ando tutorial! Nessa etapa iremos adicionar um processador e a infraestrutura m\u00ednima necess\u00e1ria para sua opera\u00e7\u00e3o, iremos incluir no projeto: Uma interface de clock Uma mem\u00f3ria (de dados e programa) O processador (NIOS II) Um perif\u00e9rico PIO (para gerenciar sa\u00eddas digitais) Um JTAG-UART, para suportar debug via print. Para come\u00e7armos: Copie a pasta da Lab1_FPGA_RTL/ renomeando para Lab2_FPGA_NIOS/ Abra o projeto dessa nova pasta Lab1_FPGA_RTL/ no Quartus Abra o Platform Designer: Quartus Tools Platform Designer Adicione os seguintes perif\u00e9ricos e suas configura\u00e7\u00f5es: On-Chip Memory (RAM or ROM Intel FPGA IP) Type: RAM Total Memory size: 32768 bytes JTAG UART Intel FPGA IP Default PIO (Parallel I/O) Intel FPGA IP Width: 6 Direction: Output NIOS II Processor Type: NIOS II/e Voc\u00ea deve obter algo similar a: Cheguei aqui! Conectando Clock e Reset \u00b6 Os perif\u00e9ricos do PD s\u00e3o como sistemas independentes (pensem em cada bloco como um chip), que necessitam ser conectados no m\u00ednimo a um Clock e a um Reset. O sistema pode operar em diversos dom\u00ednios de clocks e resets diferentes, portanto essa conex\u00e3o deve ser feita pelo desenvolvedor. Pense nessa etapa como sendo similar ao port map do VHDL, por\u00e9m em um n\u00edvel de abstra\u00e7\u00e3o superior. O PD ser\u00e1 respons\u00e1vel por fazer a compatibilidade dos sinais para n\u00f3s. Conecte todos os sinais de clocks e reset aos sinais clk e clk_rst do perif\u00e9rico clk_0 e tamb\u00e9m o debug_reset do NIOS, conforme figura a seguir: Cheguei aqui! Conectando barramento \u00b6 A Intel define dois tipos de barramento de dados para o PD : Avalon e AXI (isso \u00e9 heran\u00e7a da Altera). O barramento Avalon \u00e9 a principal maneira de conectar um perif\u00e9rico ao NIOS (processador), j\u00e1 o AXI \u00e9 o padr\u00e3o de barramento do ARM, que ser\u00e1 utilizado posteriormente. O barramento Avalon define basicamente dois tipos de comunica\u00e7\u00e3o: Memory Mapped (MM) e Avalon Streaming Interface (ST) . Indo al\u00e9m Para mais informa\u00e7\u00f5es acesse o documento Avalon Interface Specifications . O principal barramento do NIOS \u00e9 o memory mapped , e todo perif\u00e9rico conectado ao NIOS (processador) dever\u00e1 possuir esse barramento. A Altera disponibiliza conversores e adaptadores para podermos transformar uma forma de comunica\u00e7\u00e3o na outra. No tutorial 3 iremos desenvolver um perif\u00e9rico propriet\u00e1rio que ser\u00e1 conectado nesse barramento. Note que o NIOS possui dois barramentos do tipo MM : data_master e intruction_master . Como o NIOS II \u00e9 um processador baseado na arquitetura harvard ele possui dois caminhos distintos de acesso a mem\u00f3ria: um para dados e outro para o programa (instru\u00e7\u00e3o). Nessa nossa topologia de hardware s\u00f3 possu\u00edmos uma \u00fanica mem\u00f3ria ( on_chip_memory ) que ser\u00e1 a princ\u00edpio compartilhada entre dados e programa (temos uma perda de efici\u00eancia aqui, j\u00e1 que a mem\u00f3ria s\u00f3 poder\u00e1 ser acessada por um barramento por vez), depois vamos melhorar isso! Devemos conectar todos os perif\u00e9ricos ( PIO , UART e OnChip Memory ) ao barramento data_master e conectar somente a mem\u00f3ria ( OnChip Memory ) ao barramento de instru\u00e7\u00e3o ( instruction_master ), resultando na montagem a seguir: Cheguei aqui! Mapa de mem\u00f3ria \u00b6 Ap\u00f3s realizarmos as conex\u00f5es, devemos especificar o endere\u00e7o de mem\u00f3ria de cada perif\u00e9rico. Existem duas maneiras de realizarmos isso: manual ou autom\u00e1tica. Na manual, pode-se alocar os perif\u00e9ricos em endere\u00e7os de mem\u00f3ria a sua escolha, tomando os cuidados para n\u00e3o haver sobreposi\u00e7\u00e3o dos endere\u00e7os. Na autom\u00e1tica, deixamos para a ferramenta alocar os perif\u00e9ricos nos endere\u00e7os corretos. Para realizar a aloca\u00e7\u00e3o autom\u00e1tica: System Assign Base Addrress . Para visualizar o resultado, clique na aba: Address Map Cheguei aqui! Configurando NIOS \u00b6 Agora precisamos configurar o NIOS para utilizar a mem\u00f3ria rec\u00e9m conectada a ele, de um clique duplo no NIOS, para abrir a janela de Parameters . Em Parameters Vector , configure: Reset vector memory: onchip_memory Execption vector memory: onchip_memory Dica O nome onchip_memory pode alterar de acordo com o seu projeto e o endere\u00e7o tamb\u00e9m (isso depende da ordem na qual os componentes foram inseridos). Cheguei aqui! Export \u00b6 A coluna export do Platform Designer indica quais sinais ser\u00e3o exportados do sistema, pense nesses sinais como sendo os que ter\u00e3o contato com o mundo externo (ser\u00e3o mapeados para os pinos no topLevel ). De um clique duplo na coluna export na linha do sinal external_connection do component PIO e de o nome de LEDs para esse sinal. Note Repare que o componente Clock Source tamb\u00e9m possui o export dos sinais: clk e reset , isso foi feito autom\u00e1ticamente na cria\u00e7\u00e3o do projeto. Cheguei aqui! Salvando \u00b6 Ao final de tudo voc\u00ea deve obter algo como a figura a seguir: Salve o projeto com o nome niosLab2.qsys na pasta do projeto e clique em Generate HDL para o PD gerar o projeto. Tip File Save_as : niosLab2.qsys Cheguei aqui! Utilizando o componente \u00b6 Ainda no PD , clique em: Generate Show Instatiation Template , selecione VHDL como linguagem HDL. E voc\u00ea deve obter algo como: Dica Salve isso em algum lugar iremos utilizar na pr\u00f3xima etapa! component niosLab2 is port ( clk_clk : in std_logic := 'X' ; -- clk reset_reset_n : in std_logic := 'X' ; -- reset_n leds_export : out std_logic_vector ( 5 downto 0 ) -- export ); end component niosLab2 ; u0 : component niosLab2 port map ( clk_clk => CONNECTED_TO_clk_clk , -- clk.clk reset_reset_n => CONNECTED_TO_reset_reset_n , -- reset.reset_n leds_export => CONNECTED_TO_leds_export -- leds.export ); Isso \u00e9 um atalho de como devemos utilizar esse componente no nosso projeto. Esse trecho de c\u00f3digo indica que o projeto rec\u00e9m criado no PD possui tr\u00eas interfaces externas: clk_clk , reset_reset_n e leds_export . Esse sinais ter\u00e3o que ser mapeados no topLevel para seus respectivos pinos. Esse nomes podem mudar no seu projeto! O esquem\u00e1tico (gerado pelo Platform Designer View Schematic ) ilustra o SoC rec\u00e9m criado e suas interfaces: Cheguei aqui! Finalizando \u00b6 Clique em finish e deixe tudo como o padr\u00e3o, agora o qsys ir\u00e1 criar o sistema e todos os componentes que nele foram configurados. O Quartus dar\u00e1 uma alerta indicando que \u00e9 necess\u00e1rio incluir alguns arquivos no Quartus para que ele tenha acesso ao projeto rec\u00e9m criado no PD : No Quartus: Project Add/remove files in project e adicione o arquivo: niosLab2/synthesis/niosLab2.qip Resultando em: Cheguei aqui! Criando o toplevel \u00b6 Agora \u00e9 necess\u00e1rio criar um vhdl que vai ser nosso toplevel LAB2_VHDL_NIOS.vhd para incluir o componente niosLab2 rec\u00e9m criado. Crie um novo arquivo VHDL com nome: LAB2_FPGA_NIOS.vhd Insira o VHDL a seguir: Compile o projeto e analise o RTL, verifique se est\u00e1 de acordo com o esperado. Grave o projeto na FPGA. TopLevel library IEEE ; use IEEE.std_logic_1164. all ; entity LAB2_FPGA_NIOS is port ( -- Gloabals fpga_clk_50 : in std_logic ; -- clock.clk -- I/Os fpga_led_pio : out std_logic_vector ( 5 downto 0 ) ); end entity LAB2_FPGA_NIOS ; architecture rtl of LAB2_FPGA_NIOS is component niosLab2 is port ( clk_clk : in std_logic := 'X' ; -- clk reset_reset_n : in std_logic := 'X' ; -- reset_n leds_export : out std_logic_vector ( 5 downto 0 ) -- export ); end component niosLab2 ; begin u0 : component niosLab2 port map ( clk_clk => fpga_clk_50 , -- clk.clk reset_reset_n => '1' , -- reset.reset_n leds_export => fpga_led_pio -- leds.export ); end rtl ; Note Note que n\u00e3o estamos utilizando o sinal de reset (o _n indica que o reset \u00e9 negativo, ou seja, em 0 ). Cheguei aqui! Programando o NIOS - Soft processor \u00b6 Agora que temos o projeto programado na FPGA , com o hardware que inclui o processador NIOS. Precisamos gerar e gravar um programa que realiza o controle dos LEDs. Para isso iremos abrir a IDE NIOS Software Build for Eclipse (SBT) que possui todo o toolchain necess\u00e1rio para desenvolvermos firmware para o NIOS. No Quartus: Tools Nios II Software Build ... e uma interface do eclipse ser\u00e1 aberta. Quando desenvolvemos projetos para sistemas SoCs temos um problema: o hardware n\u00e3o \u00e9 padronizado. Como tudo \u00e9 customizado existe um problema que deve-se ser tratado, a interface entre o hardware criado e o toolchain de software (compilador, linker...). A Altera resolveu isso criando uma camada de abstra\u00e7\u00e3o de hardware ( H ardware A bstraction L ayer - HAL) ou como a Intel chama: B oard S uport P ackage (BSP), na qual extraem-se informa\u00e7\u00f5es do Platform Designer para ser utilizado pela toolchain de compila\u00e7\u00e3o (GCC). Quando formos criar um projeto no NIOS II - Eclipse , dois projetos ser\u00e3o criados: um que cont\u00e9m o firmware a ser gravado no NIOS e outro (BSP) que cont\u00e9m informa\u00e7\u00f5es relevantes sobre o Hardware para uso no firmware e toolchain. Para mais informa\u00e7\u00f5es: https://www.altera.com/products/processors/design-tools.html#SBT Criando o projeto \u00b6 No Quartus Tools Nios II Software Build for Eclipse No NIOS II Software Build for Eclipse File NIOS II Application and BSP from template SOPC Information File Name : Na pasta do projeto, procure pelo arquivo : niosLab2.sopcinfo Esse arquivo \u00e9 criado pelo PD quando o projeto \u00e9 compilado, e est\u00e1 na pasta do projeto. Project name : niosLab2 Project template : Hello World Tip Ap\u00f3s avan\u00e7ar o SBT ir\u00e1 criar duas pastas de projeto : niosLab2 : firmware a ser embarcado niosLab2_bsp : Board support package para o firmware Voc\u00ea deve obter algo como: Cheguei aqui! Analisando e configurando o bsp \u00b6 Vamos analisar o BSP gerado: Project Explorer niosLab2_bsp NIOS II bsp Editor Tip Isso abrir\u00e1 uma interface de configura\u00e7\u00e3o para o bsp. Diversas s\u00e3o as op\u00e7\u00f5es de configura\u00e7\u00f5es, algumas delas: sys_clk_timer : perif\u00e9rico utilizado para bibliotecas de delay (n\u00e3o inserimos no Platform Designer) timestamp_timer : perif\u00e9rico que seria utilizado pelo timestamp stdin , stdout , sterr : perif\u00e9rico utilizado pelo stantard IO do C, no nosso caso: jtat_uart_0 (poderia ser outro). Note Note que a regi\u00e3o de mem\u00f3ria do stack j\u00e1 est\u00e1 configurada para a onchip_memory . Aqui ter\u00edamos a op\u00e7\u00e3o de mapear para outro local (no caso do sistema possuir outras mem\u00f3rias, tais como mem\u00f3rias DDR externas a FPGA). Cheguei aqui! Jtag-UART small driver \u00b6 Note que no nosso projeto no PD o perif\u00e9rico jtag-uart n\u00e3o teve seu sinal de interrup\u00e7\u00e3o conectado no NIOS, isso dificulta o acesso a uart, j\u00e1 que o firmware n\u00e3o ser\u00e1 interrompido caso um novo dado chegue (gets) ou na transmiss\u00e3o (puts). O driver deve ficar fazendo um polling no perif\u00e9rico para verificar o envio e recep\u00e7\u00e3o dos dados. Para isso funcionar, devemos ativar uma op\u00e7\u00e3o no driver do jtag_avalon no bsp: BSP Editor Drivers jtag_uart enable_small_driver Cheguei aqui! Gerando o bsp \u00b6 Toda vez que o bsp for editado ou o hardware alterado ( Platform Designer ) deve-se regenerar o bsp : De volta no eclipse, devemos gerar os arquivos bsp. Para isso clique em: niosLab2_bsp NIOS II Generate BSP Embarcando! \u00b6 Com o bsp editado abra agora a pasta niosLab2 e note que existe inicializada com um arquivo: hello_world.c que imprime via JTAG-UART uma string. Insira o c\u00f3digo a seguir no eclipse: #include <stdio.h> int main () { printf ( \"Hello from Nios II! \\n \" ); return 0 ; } Com o hello_word.c aberto (\u00e9 necess\u00e1rio para o eclipse saber qual projeto voc\u00ea quer embarcar), clique em: Run Run NIOS II Hardware . Isso far\u00e1 com que a aplica\u00e7\u00e3o seja descarregada na mem\u00f3ria do Qsys que alocamos para o Nios e que o hardware seja, reiniciado para executar o firmware. Quando o firmware for executado, abra a aba do eclipse NIOS II console : Cheguei aqui! Programando Blink LED \u00b6 Edite main para conter o c\u00f3digo a seguir: #include <stdio.h> #include \"system.h\" #include <alt_types.h> #include <io.h> /* Leiutura e escrita no Avalon */ int delay ( int n ){ unsigned int delay = 0 ; while ( delay < n ){ delay ++ ; } } int main ( void ){ unsigned int led = 0 ; printf ( \"Embarcados++ \\n \" ); while ( 1 ){ if ( led <= 5 ){ IOWR_32DIRECT ( PIO_0_BASE , 0 , 0x01 << led ++ ); usleep ( 50000 ); } else { led = 0 ; } }; return 0 ; } Embarque no NIOS e veja o resultado nos LEDS! Cheguei aqui!","title":"Tutorial 2 - FPGA - NIOS"},{"location":"Tutorial-FPGA-NIOS/#tutorial-2-fpga-nios","text":"2020-2 Material atualizado. Nesse tutorial iremos criar e customizar um soft processor com o NIOS (sistema embarcado com um processador e perif\u00e9rico), embarcar na FPGA e escrever um c\u00f3digo para ele. Ao final, vamos ter os mesmos LEDs que do projeto anterior, com opera\u00e7\u00e3o simular, mas agora sendo controlados por um programa e n\u00e3o por um hardware dedicado.","title":"Tutorial 2 - FPGA - NIOS"},{"location":"Tutorial-FPGA-NIOS/#comecando","text":"Para seguir esse tutorial \u00e9 necess\u00e1rio: Hardware: DE10-Standard e acess\u00f3rios Softwares: Quartus 18.01 Documentos: DE10-Standard_User_manual.pdf Entrega no git: Pasta: Lab2_FPGA_NIOS","title":"Come\u00e7ando"},{"location":"Tutorial-FPGA-NIOS/#soft-processor","text":"Projetos em HDL (VHDL, Verilog, ... ) n\u00e3o s\u00e3o muito flex\u00edveis, cada altera\u00e7\u00e3o no projeto implica na modifica\u00e7\u00e3o do Hardware o que n\u00e3o \u00e9 algo t\u00e3o simples. Al\u00e9m da dificuldade de implementar as modifica\u00e7\u00f5es, temos o tempo de teste e compila\u00e7\u00e3o do projeto que n\u00e3o \u00e9 nada imediato. Uma solu\u00e7\u00e3o para tornar o projeto mais flex\u00edvel \u00e9 o de tornar os LEDs controlados n\u00e3o por uma l\u00f3gica dedicada mas sim por um hardware que possa executar uma s\u00e9rie de instru\u00e7\u00f5es: um microcontrolador. Como a FPGA pode implementar circuitos l\u00f3gicos digitais, \u00e9 poss\u00edvel sintetizarmos um microcontrolador na FPGA e fazermos esse uC controlar os LEDS (Sim!! o uC \u00e9 um hardware descrito em HDL). Agora a altera\u00e7\u00e3o na l\u00f3gica de controle depende do programa que ser\u00e1 executado no uC, tornando o projeto muito mais flex\u00edvel. O ARM tamb\u00e9m \u00e9 um hardware em HDL, s\u00f3 que propriet\u00e1rio: https://www.arm.com/about/newsroom/arm-offers-free-access-to-cortex-m0-processor-ip-to-streamline-embedded-soc-design.php Processadores que s\u00e3o sintetiz\u00e1veis em dispositivos l\u00f3gicos program\u00e1veis (FPGA, ...) s\u00e3o chamados de Soft Processor . Diversos s\u00e3o os Soft Processors dispon\u00edveis comercialmente ou open source: NIOS II: Intel MicroBlazer: Xilinx LEON: Gaisler (aerospacial/ SPARCV8) dentre outros A adi\u00e7\u00e3o de perif\u00e9ricos e funcionalidades extras ao Soft Processor (podemos por exemplo colocar um gerenciador de mem\u00f3ria, timers, controlador de rede, ...) faz com que o sistema passe a ser chamado de System On Chip (SoC). Hard Processor s\u00e3o os microprocessadores tradicionais, que n\u00e3o sofrem altera\u00e7\u00e3o de HW.","title":"Soft processor"},{"location":"Tutorial-FPGA-NIOS/#plataform-designer-pd","text":"O Platform Designer era chamado de QSYS , ainda da para achar muitas coisas com essa refer\u00eancia O Platform Designer \u00e9 um software dispon\u00edvel pela Intel e integrado no Quartus que possibilita desenvolvermos sistemas complexos de forma simples e visual. Com ele podemos adicionar e conectar Intellectual property cores (IP Core) para desenvolvermos uma aplica\u00e7\u00e3o de maneira r\u00e1pida e visual. Os IP cores podem ser da pr\u00f3pria Intel , de terceiros ou propriet\u00e1rios. Indo al\u00e9m Tem um curso online que mostra como o PD funciona: Introduction to Platform Designer","title":"Plataform Designer (PD)"},{"location":"Tutorial-FPGA-NIOS/#nios","text":"NIOS \u00e9 o soft processor fornecido pela Altera-Intel e integrado na ferramenta. O NIOS \u00e9 baseado na arquitetura do MIPS com arquitetura de 32 bits , controle de exce\u00e7\u00f5es, barramento de comunica\u00e7\u00e3o, controle de mem\u00f3ria, ... . A figura a seguir descreve os componentes essenciais do NIOS (azul) e o que \u00e9 customiz\u00e1vel (cinza). Refer\u00eancia: Processor Architecture O NIOS suporta que novas instru\u00e7\u00f5es sejam adicionadas ao seu instruction set, essas instru\u00e7\u00f5es s\u00e3o implementadas em HDL e inseridas no core de forma transparente ao desenvolvedor. Existem graus de instru\u00e7\u00f5es customizadas: combinacional; multiciclo; estendidas; Que faz uso do banco de registradores original ou aquelas que adicionam novos registradores. Indo al\u00e9m Para maiores detalhes de como customizar o NIOS consulte o documento: Nios II Custom Instruction User Guide","title":"NIOS"},{"location":"Tutorial-FPGA-NIOS/#criando-um-simples-soc","text":"Come\u00e7ando implementar. Come\u00e7ando tutorial! Nessa etapa iremos adicionar um processador e a infraestrutura m\u00ednima necess\u00e1ria para sua opera\u00e7\u00e3o, iremos incluir no projeto: Uma interface de clock Uma mem\u00f3ria (de dados e programa) O processador (NIOS II) Um perif\u00e9rico PIO (para gerenciar sa\u00eddas digitais) Um JTAG-UART, para suportar debug via print. Para come\u00e7armos: Copie a pasta da Lab1_FPGA_RTL/ renomeando para Lab2_FPGA_NIOS/ Abra o projeto dessa nova pasta Lab1_FPGA_RTL/ no Quartus Abra o Platform Designer: Quartus Tools Platform Designer Adicione os seguintes perif\u00e9ricos e suas configura\u00e7\u00f5es: On-Chip Memory (RAM or ROM Intel FPGA IP) Type: RAM Total Memory size: 32768 bytes JTAG UART Intel FPGA IP Default PIO (Parallel I/O) Intel FPGA IP Width: 6 Direction: Output NIOS II Processor Type: NIOS II/e Voc\u00ea deve obter algo similar a: Cheguei aqui!","title":"Criando um simples SoC"},{"location":"Tutorial-FPGA-NIOS/#conectando-clock-e-reset","text":"Os perif\u00e9ricos do PD s\u00e3o como sistemas independentes (pensem em cada bloco como um chip), que necessitam ser conectados no m\u00ednimo a um Clock e a um Reset. O sistema pode operar em diversos dom\u00ednios de clocks e resets diferentes, portanto essa conex\u00e3o deve ser feita pelo desenvolvedor. Pense nessa etapa como sendo similar ao port map do VHDL, por\u00e9m em um n\u00edvel de abstra\u00e7\u00e3o superior. O PD ser\u00e1 respons\u00e1vel por fazer a compatibilidade dos sinais para n\u00f3s. Conecte todos os sinais de clocks e reset aos sinais clk e clk_rst do perif\u00e9rico clk_0 e tamb\u00e9m o debug_reset do NIOS, conforme figura a seguir: Cheguei aqui!","title":"Conectando Clock e Reset"},{"location":"Tutorial-FPGA-NIOS/#conectando-barramento","text":"A Intel define dois tipos de barramento de dados para o PD : Avalon e AXI (isso \u00e9 heran\u00e7a da Altera). O barramento Avalon \u00e9 a principal maneira de conectar um perif\u00e9rico ao NIOS (processador), j\u00e1 o AXI \u00e9 o padr\u00e3o de barramento do ARM, que ser\u00e1 utilizado posteriormente. O barramento Avalon define basicamente dois tipos de comunica\u00e7\u00e3o: Memory Mapped (MM) e Avalon Streaming Interface (ST) . Indo al\u00e9m Para mais informa\u00e7\u00f5es acesse o documento Avalon Interface Specifications . O principal barramento do NIOS \u00e9 o memory mapped , e todo perif\u00e9rico conectado ao NIOS (processador) dever\u00e1 possuir esse barramento. A Altera disponibiliza conversores e adaptadores para podermos transformar uma forma de comunica\u00e7\u00e3o na outra. No tutorial 3 iremos desenvolver um perif\u00e9rico propriet\u00e1rio que ser\u00e1 conectado nesse barramento. Note que o NIOS possui dois barramentos do tipo MM : data_master e intruction_master . Como o NIOS II \u00e9 um processador baseado na arquitetura harvard ele possui dois caminhos distintos de acesso a mem\u00f3ria: um para dados e outro para o programa (instru\u00e7\u00e3o). Nessa nossa topologia de hardware s\u00f3 possu\u00edmos uma \u00fanica mem\u00f3ria ( on_chip_memory ) que ser\u00e1 a princ\u00edpio compartilhada entre dados e programa (temos uma perda de efici\u00eancia aqui, j\u00e1 que a mem\u00f3ria s\u00f3 poder\u00e1 ser acessada por um barramento por vez), depois vamos melhorar isso! Devemos conectar todos os perif\u00e9ricos ( PIO , UART e OnChip Memory ) ao barramento data_master e conectar somente a mem\u00f3ria ( OnChip Memory ) ao barramento de instru\u00e7\u00e3o ( instruction_master ), resultando na montagem a seguir: Cheguei aqui!","title":"Conectando barramento"},{"location":"Tutorial-FPGA-NIOS/#mapa-de-memoria","text":"Ap\u00f3s realizarmos as conex\u00f5es, devemos especificar o endere\u00e7o de mem\u00f3ria de cada perif\u00e9rico. Existem duas maneiras de realizarmos isso: manual ou autom\u00e1tica. Na manual, pode-se alocar os perif\u00e9ricos em endere\u00e7os de mem\u00f3ria a sua escolha, tomando os cuidados para n\u00e3o haver sobreposi\u00e7\u00e3o dos endere\u00e7os. Na autom\u00e1tica, deixamos para a ferramenta alocar os perif\u00e9ricos nos endere\u00e7os corretos. Para realizar a aloca\u00e7\u00e3o autom\u00e1tica: System Assign Base Addrress . Para visualizar o resultado, clique na aba: Address Map Cheguei aqui!","title":"Mapa de mem\u00f3ria"},{"location":"Tutorial-FPGA-NIOS/#configurando-nios","text":"Agora precisamos configurar o NIOS para utilizar a mem\u00f3ria rec\u00e9m conectada a ele, de um clique duplo no NIOS, para abrir a janela de Parameters . Em Parameters Vector , configure: Reset vector memory: onchip_memory Execption vector memory: onchip_memory Dica O nome onchip_memory pode alterar de acordo com o seu projeto e o endere\u00e7o tamb\u00e9m (isso depende da ordem na qual os componentes foram inseridos). Cheguei aqui!","title":"Configurando NIOS"},{"location":"Tutorial-FPGA-NIOS/#export","text":"A coluna export do Platform Designer indica quais sinais ser\u00e3o exportados do sistema, pense nesses sinais como sendo os que ter\u00e3o contato com o mundo externo (ser\u00e3o mapeados para os pinos no topLevel ). De um clique duplo na coluna export na linha do sinal external_connection do component PIO e de o nome de LEDs para esse sinal. Note Repare que o componente Clock Source tamb\u00e9m possui o export dos sinais: clk e reset , isso foi feito autom\u00e1ticamente na cria\u00e7\u00e3o do projeto. Cheguei aqui!","title":"Export"},{"location":"Tutorial-FPGA-NIOS/#salvando","text":"Ao final de tudo voc\u00ea deve obter algo como a figura a seguir: Salve o projeto com o nome niosLab2.qsys na pasta do projeto e clique em Generate HDL para o PD gerar o projeto. Tip File Save_as : niosLab2.qsys Cheguei aqui!","title":"Salvando"},{"location":"Tutorial-FPGA-NIOS/#utilizando-o-componente","text":"Ainda no PD , clique em: Generate Show Instatiation Template , selecione VHDL como linguagem HDL. E voc\u00ea deve obter algo como: Dica Salve isso em algum lugar iremos utilizar na pr\u00f3xima etapa! component niosLab2 is port ( clk_clk : in std_logic := 'X' ; -- clk reset_reset_n : in std_logic := 'X' ; -- reset_n leds_export : out std_logic_vector ( 5 downto 0 ) -- export ); end component niosLab2 ; u0 : component niosLab2 port map ( clk_clk => CONNECTED_TO_clk_clk , -- clk.clk reset_reset_n => CONNECTED_TO_reset_reset_n , -- reset.reset_n leds_export => CONNECTED_TO_leds_export -- leds.export ); Isso \u00e9 um atalho de como devemos utilizar esse componente no nosso projeto. Esse trecho de c\u00f3digo indica que o projeto rec\u00e9m criado no PD possui tr\u00eas interfaces externas: clk_clk , reset_reset_n e leds_export . Esse sinais ter\u00e3o que ser mapeados no topLevel para seus respectivos pinos. Esse nomes podem mudar no seu projeto! O esquem\u00e1tico (gerado pelo Platform Designer View Schematic ) ilustra o SoC rec\u00e9m criado e suas interfaces: Cheguei aqui!","title":"Utilizando o componente"},{"location":"Tutorial-FPGA-NIOS/#finalizando","text":"Clique em finish e deixe tudo como o padr\u00e3o, agora o qsys ir\u00e1 criar o sistema e todos os componentes que nele foram configurados. O Quartus dar\u00e1 uma alerta indicando que \u00e9 necess\u00e1rio incluir alguns arquivos no Quartus para que ele tenha acesso ao projeto rec\u00e9m criado no PD : No Quartus: Project Add/remove files in project e adicione o arquivo: niosLab2/synthesis/niosLab2.qip Resultando em: Cheguei aqui!","title":"Finalizando"},{"location":"Tutorial-FPGA-NIOS/#criando-o-toplevel","text":"Agora \u00e9 necess\u00e1rio criar um vhdl que vai ser nosso toplevel LAB2_VHDL_NIOS.vhd para incluir o componente niosLab2 rec\u00e9m criado. Crie um novo arquivo VHDL com nome: LAB2_FPGA_NIOS.vhd Insira o VHDL a seguir: Compile o projeto e analise o RTL, verifique se est\u00e1 de acordo com o esperado. Grave o projeto na FPGA. TopLevel library IEEE ; use IEEE.std_logic_1164. all ; entity LAB2_FPGA_NIOS is port ( -- Gloabals fpga_clk_50 : in std_logic ; -- clock.clk -- I/Os fpga_led_pio : out std_logic_vector ( 5 downto 0 ) ); end entity LAB2_FPGA_NIOS ; architecture rtl of LAB2_FPGA_NIOS is component niosLab2 is port ( clk_clk : in std_logic := 'X' ; -- clk reset_reset_n : in std_logic := 'X' ; -- reset_n leds_export : out std_logic_vector ( 5 downto 0 ) -- export ); end component niosLab2 ; begin u0 : component niosLab2 port map ( clk_clk => fpga_clk_50 , -- clk.clk reset_reset_n => '1' , -- reset.reset_n leds_export => fpga_led_pio -- leds.export ); end rtl ; Note Note que n\u00e3o estamos utilizando o sinal de reset (o _n indica que o reset \u00e9 negativo, ou seja, em 0 ). Cheguei aqui!","title":"Criando o toplevel"},{"location":"Tutorial-FPGA-NIOS/#programando-o-nios-soft-processor","text":"Agora que temos o projeto programado na FPGA , com o hardware que inclui o processador NIOS. Precisamos gerar e gravar um programa que realiza o controle dos LEDs. Para isso iremos abrir a IDE NIOS Software Build for Eclipse (SBT) que possui todo o toolchain necess\u00e1rio para desenvolvermos firmware para o NIOS. No Quartus: Tools Nios II Software Build ... e uma interface do eclipse ser\u00e1 aberta. Quando desenvolvemos projetos para sistemas SoCs temos um problema: o hardware n\u00e3o \u00e9 padronizado. Como tudo \u00e9 customizado existe um problema que deve-se ser tratado, a interface entre o hardware criado e o toolchain de software (compilador, linker...). A Altera resolveu isso criando uma camada de abstra\u00e7\u00e3o de hardware ( H ardware A bstraction L ayer - HAL) ou como a Intel chama: B oard S uport P ackage (BSP), na qual extraem-se informa\u00e7\u00f5es do Platform Designer para ser utilizado pela toolchain de compila\u00e7\u00e3o (GCC). Quando formos criar um projeto no NIOS II - Eclipse , dois projetos ser\u00e3o criados: um que cont\u00e9m o firmware a ser gravado no NIOS e outro (BSP) que cont\u00e9m informa\u00e7\u00f5es relevantes sobre o Hardware para uso no firmware e toolchain. Para mais informa\u00e7\u00f5es: https://www.altera.com/products/processors/design-tools.html#SBT","title":"Programando o NIOS - Soft processor"},{"location":"Tutorial-FPGA-NIOS/#criando-o-projeto","text":"No Quartus Tools Nios II Software Build for Eclipse No NIOS II Software Build for Eclipse File NIOS II Application and BSP from template SOPC Information File Name : Na pasta do projeto, procure pelo arquivo : niosLab2.sopcinfo Esse arquivo \u00e9 criado pelo PD quando o projeto \u00e9 compilado, e est\u00e1 na pasta do projeto. Project name : niosLab2 Project template : Hello World Tip Ap\u00f3s avan\u00e7ar o SBT ir\u00e1 criar duas pastas de projeto : niosLab2 : firmware a ser embarcado niosLab2_bsp : Board support package para o firmware Voc\u00ea deve obter algo como: Cheguei aqui!","title":"Criando o projeto"},{"location":"Tutorial-FPGA-NIOS/#analisando-e-configurando-o-bsp","text":"Vamos analisar o BSP gerado: Project Explorer niosLab2_bsp NIOS II bsp Editor Tip Isso abrir\u00e1 uma interface de configura\u00e7\u00e3o para o bsp. Diversas s\u00e3o as op\u00e7\u00f5es de configura\u00e7\u00f5es, algumas delas: sys_clk_timer : perif\u00e9rico utilizado para bibliotecas de delay (n\u00e3o inserimos no Platform Designer) timestamp_timer : perif\u00e9rico que seria utilizado pelo timestamp stdin , stdout , sterr : perif\u00e9rico utilizado pelo stantard IO do C, no nosso caso: jtat_uart_0 (poderia ser outro). Note Note que a regi\u00e3o de mem\u00f3ria do stack j\u00e1 est\u00e1 configurada para a onchip_memory . Aqui ter\u00edamos a op\u00e7\u00e3o de mapear para outro local (no caso do sistema possuir outras mem\u00f3rias, tais como mem\u00f3rias DDR externas a FPGA). Cheguei aqui!","title":"Analisando e configurando o bsp"},{"location":"Tutorial-FPGA-NIOS/#jtag-uart-small-driver","text":"Note que no nosso projeto no PD o perif\u00e9rico jtag-uart n\u00e3o teve seu sinal de interrup\u00e7\u00e3o conectado no NIOS, isso dificulta o acesso a uart, j\u00e1 que o firmware n\u00e3o ser\u00e1 interrompido caso um novo dado chegue (gets) ou na transmiss\u00e3o (puts). O driver deve ficar fazendo um polling no perif\u00e9rico para verificar o envio e recep\u00e7\u00e3o dos dados. Para isso funcionar, devemos ativar uma op\u00e7\u00e3o no driver do jtag_avalon no bsp: BSP Editor Drivers jtag_uart enable_small_driver Cheguei aqui!","title":"Jtag-UART small driver"},{"location":"Tutorial-FPGA-NIOS/#gerando-o-bsp","text":"Toda vez que o bsp for editado ou o hardware alterado ( Platform Designer ) deve-se regenerar o bsp : De volta no eclipse, devemos gerar os arquivos bsp. Para isso clique em: niosLab2_bsp NIOS II Generate BSP","title":"Gerando o bsp"},{"location":"Tutorial-FPGA-NIOS/#embarcando","text":"Com o bsp editado abra agora a pasta niosLab2 e note que existe inicializada com um arquivo: hello_world.c que imprime via JTAG-UART uma string. Insira o c\u00f3digo a seguir no eclipse: #include <stdio.h> int main () { printf ( \"Hello from Nios II! \\n \" ); return 0 ; } Com o hello_word.c aberto (\u00e9 necess\u00e1rio para o eclipse saber qual projeto voc\u00ea quer embarcar), clique em: Run Run NIOS II Hardware . Isso far\u00e1 com que a aplica\u00e7\u00e3o seja descarregada na mem\u00f3ria do Qsys que alocamos para o Nios e que o hardware seja, reiniciado para executar o firmware. Quando o firmware for executado, abra a aba do eclipse NIOS II console : Cheguei aqui! Programando","title":"Embarcando!"},{"location":"Tutorial-FPGA-NIOS/#blink-led","text":"Edite main para conter o c\u00f3digo a seguir: #include <stdio.h> #include \"system.h\" #include <alt_types.h> #include <io.h> /* Leiutura e escrita no Avalon */ int delay ( int n ){ unsigned int delay = 0 ; while ( delay < n ){ delay ++ ; } } int main ( void ){ unsigned int led = 0 ; printf ( \"Embarcados++ \\n \" ); while ( 1 ){ if ( led <= 5 ){ IOWR_32DIRECT ( PIO_0_BASE , 0 , 0x01 << led ++ ); usleep ( 50000 ); } else { led = 0 ; } }; return 0 ; } Embarque no NIOS e veja o resultado nos LEDS! Cheguei aqui!","title":"Blink LED"},{"location":"Tutorial-FPGA-RTL/","text":"Tutorial 1 - FPGA - RTL \u00b6 2020-2 Material atualizado. Essa primeira entrega \u00e9 um aquecimento de VHDL e FPGA, iremos criar um hardware dedicado na FPGA para controlar os LEDs com base nos sinais de entradas dos bot\u00f5es. A ideia \u00e9 passarmos por todo o processo de desenvolvimento de um projeto em FPGA e com VHDL. Tip Para quem j\u00e1 fez Design de Computadores isso \u00e9 uma revis\u00e3o, quem ainda n\u00e3o fez vai ver isso l\u00e1. Come\u00e7ando \u00b6 Para seguir esse tutorial \u00e9 necess\u00e1rio: Hardware: DE10-Standard e acess\u00f3rios Softwares: Quartus 18.01 Documentos: DE10-Standard_User_manual.pdf Entrega no git : pasta Lab1_FPGA_RTL Tip Crie um reposit\u00f3rio para a disciplina, voc\u00ea dever\u00e1 fazer as entregas por ele. Quartus \u00b6 Primeiro, devemos criar um novo projeto no software Quartus. No Quartus: File \u27a1\ufe0f New Project Wizard Directory, Name, Top-Level Entity Escolha o destino como sendo seu reposit\u00f3rio. nomeio o projeto como Lab1_FPGA_RTL Project Type Empty Project Add Files N\u00e3o vamos adicionar nenhum arquivo por enquanto. Family, Device & Board Settings Procure pela FPGA: Family: Cyclone V Name: 5CSXFC6D6F31C6 \ud83c\udd97 Finalize o Wizard Wizard Cheguei Aqui! Outras refer\u00eancias Se precisar de outro material como refer\u00eancia, tem um tutorial da Terasic: DE10-Standard_My_First_Fpga.pdf Criando o topLevel \u00b6 TopLevel \u00e9 o nome do m\u00f3dulo mais superior em desenvolvimento hier\u00e1rquico onde, geralmente os sinais da entidade (in/out,...) ser\u00e3o mapeados a pinos do hardware (conex\u00e3o com o mundo externo). Vamos adicionar um arquivo ao projeto rec\u00e9m criado: File New VHDL File File save as name: Lab1_FPGA_RTL.vhd \ud83c\udd97 Inicialize o arquivo com o conte\u00fado a seguir: toplevel source file library IEEE ; use IEEE.std_logic_1164. all ; entity Lab1_FPGA_RTL is port ( -- Gloabals fpga_clk_50 : in std_logic ; -- I/Os fpga_led_pio : out std_logic_vector ( 5 downto 0 ) ); end entity Lab1_FPGA_RTL ; architecture rtl of Lab1_FPGA_RTL is -- signal signal blink : std_logic := '0' ; begin process ( fpga_clk_50 ) variable counter : integer range 0 to 25000000 := 0 ; begin if ( rising_edge ( fpga_clk_50 )) then if ( counter < 10000000 ) then counter := counter + 1 ; else blink <= not blink ; counter := 0 ; end if ; end if ; end process ; fpga_led_pio ( 0 ) <= blink ; fpga_led_pio ( 1 ) <= blink ; fpga_led_pio ( 2 ) <= blink ; fpga_led_pio ( 3 ) <= blink ; fpga_led_pio ( 4 ) <= blink ; fpga_led_pio ( 5 ) <= blink ; end rtl ; Cheguei Aqui! Info Esse c\u00f3digo poderia ser mais elegante, mas vamos deixar assim para facilitar o entendimento. Configurando o topLevel \u00b6 No Quartus devemos dizer qual entidade \u00e9 a topLevel, como o VHDL n\u00e3o define uma padr\u00e3o para isso, qualquer entidade pode ser configurada como top. No quartus: Project Set as Top-Level Entity Esse comando ir\u00e1 configurar o arquivo atual como sendo o topLevel do projeto. Note que o Quartus atribui ao topLevel a entidade como sendo o nome do arquivo, se por algum motivo (que acontece) o nome do arquivo n\u00e3o for igual ao da entidade isso n\u00e3o ir\u00e1 funcionar. Tip Como salvamos o arquivo com o mesmo nome do projeto e a entidade tem o mesmo nome tamb\u00e9m, o Quartus reconhece essa entidade como sendo a TopLevel como padr\u00e3o. Verificando \u00b6 Vamos verificar se est\u00e1 tudo certo por enquanto realizando uma compila\u00e7\u00e3o completa no projeto. Para isso: Processing Start Compilation . Aguarde !! as compila\u00e7\u00f5es de HDL podem demorar bastante tempo. I/Os \u00b6 Lembre que o topLevel \u00e9 a entidade que ser\u00e1 mapeada com o mundo externo, nesse caso os sinais: fpga_clk_50 ; fpga_led_pio ; devem ser conectados aos pinos da FPGA que est\u00e3o conectados nesses dispositivos (clock de 50 MHz; Seis LEDs). Note o erro que o Quartus gerou quando mandamos ele compilar o projeto ( \"Show Critical Warnings Messages\" ): Failure Critical Warning (169085): No exact pin location assignment(s) for 6 pins of 6 total pins. For the list of pins please refer to the I/O Assignment Warnings table in the fitter report. Esse erro indica que do topLevel 6 sinais n\u00e3o foram mapeados para os pinos correspondentes. Pinos \u00b6 Devemos indicar para a ferramenta quais s\u00e3o os pinos e qual padr\u00e3o de sinal ele deve utilizar para cada um dos sinais definidos na entidade do topLevel. LEDs \u00b6 No manual da placa p\u00e1gina 22 temos as defini\u00e7\u00f5es de como os pinos da FPGA foram utilizados na placa: There are also ten user-controllable LEDs connected to the FPGA. Each LED is driven directly and individually by the Cyclone V SoC FPGA; driving its associated pin to a high logic level or low level to turn the LED on or off, respectively. Figure 3-17 shows the connections between LEDs and Cyclone V SoC FPGA. Table 3-6, Table 3-7 and Table 3-8 list the pin assignment of user push-buttons, switches, and LEDs. CLOCK \u00b6 Do manual: Figure 3-13 shows the default frequency of all external clocks to the Cyclone V SoC FPGA. A clock generator is used to distribute clock signals with low jitter. The four 50MHz clock signals connected to the FPGA are used as clock sources for user logic. One 25MHz clock signal is connected to two HPS clock inputs, and the other one is connected to the clock input of Gigabit Ethernet Transceiver. Two 24MHz clock signals are connected to the clock inputs of USB Host/OTG PHY and USB hub controller. The associated pin assignment for clock inputs to FPGA I/O pins is listed in Table 3-5. Pin Assigment \u00b6 Iremos utilizar o Pin Planner para inserir esses pinos, para isso: Assignments Pin Planner . A interface do Pin Planner exibe os pinos/ bancos dispon\u00edveis da FPGA para serem alocados aos sinais do TopLevel. Note que a coluna Fitter Location j\u00e1 possui pinos alocados aos sinais, isso foi gerado automaticamente pelo Quartus na etapa de Filter , por\u00e9m eles n\u00e3o correspondem aos pinos reais que desejamos utilizar. Tarefa Edite a coluna Location utilizando como refer\u00eancia a figura anterior que relaciona os LEDs da placa com os pinos da FPGA. Note: no nosso projeto possu\u00edmos apenas 6 LEDs, do total de 10 dispon\u00edveis. o I/O Standard n\u00e3o reflete o definido no manual que \u00e9 3.3V CMOS . Voc\u00ea deve alterar essa coluna de 2.5V CMOS (Default) para 3.3-V LVTTL . Cheguei Aqui! Flexibilidade FPGA Normalmente atribu\u00edmos a FPGA uma flexibilidade l\u00f3gica, mas note a flexibilidade que ela possui quanto a defini\u00e7\u00e3o de n\u00edvel de sinal de cada pino. Isso permite ao desenvolvedor de hardware in\u00fameras op\u00e7\u00f5es de uso e de novas configura\u00e7\u00f5es. Assignment Editor Feche a ferramenta e abra o Assignment Editor : Assignments Assignments Editor . Note que as mesmas informa\u00e7\u00f5es inseridas anteriormente est\u00e3o nesse editor. Na verdade, todas as configura\u00e7\u00f5es da FPGA s\u00e3o exibidas no Assignments Editor e apenas algumas no Pin Planner . Recompile Recompile o projeto e note que n\u00e3o existe mais erros de aloca\u00e7\u00e3o Timing Requirements not met \u00b6 Ao compilar o projeto ainda possu\u00edmos um erro critico : Failure Critical Warning (332012): Synopsys Design Constraints File file not found. A Synopsys Design Constraints File is required by the TimeQuest Timing Analyzer to get proper timing constraints. Without it, the Compiler will not properly optimize the design. Critical Warning (332148): Timing requirements not met Info (11105): For recommendations on closing timing, run Report Timing Closure Recommendations in the TimeQuest Timing Analyzer. Esse erro \u00e9 referente a n\u00e3o termos indicado para o Quartus qual a frequ\u00eancia de opera\u00e7\u00e3o do nosso sistema. Como a frequ\u00eancia n\u00e3o est\u00e1 definida a etapa de Fitter and Assembler n\u00e3o consegue otimizar o projeto corretamente, resultando nesse erro. Assembler aqui \u00e9 diferente do assembler de um programa como C . De uma olhada nessa refer\u00eancia para maiores detalhes. Synopsys Design Constraints File: .sdc \u00b6 Devemos adicionar um novo arquivo ao projeto que ir\u00e1 indicar para a ferramenta quais s\u00e3o as condi\u00e7\u00f5es de contorno do projeto. Para isso: File New File Synopsys Design Constraints File Save As : Lab1_FPGA_RTL.sdc Adicione ao arquivo o seguinte conte\u00fado: # 50MHz board input clock create_clock -period 20 [get_ports fpga_clk_50] # Automatically apply a generate clock on the output of phase-locked loops (PLLs) derive_pll_clocks Essas linhas indicam para a ferramenta que o sinal fpga_clk_50 \u00e9 um sinal de clock com frequ\u00eancia 50MHz (20 ns de per\u00edodo) e \u00e9 para a inferir outros clocks autom\u00e1ticos (exe: caso um PLL seja utilizado). 1^: https://www.altera.com/support/support-resources/design-examples/design-software/timinganalyzer/exm-tq-basic-sdc-template.html Tarefa Crie e inicialize o arquivo .sdc Compile o projeto Recompile Recompile o projeto e note que n\u00e3o existe mais erros cr\u00edticos no projeto. Cheguei Aqui! RTL Viewer \u00b6 RTL Viewer \u00e9 uma maneira gr\u00e1fica de verificar se o c\u00f3digo em HDL foi interpretado corretamente pela ferramenta, e uma \u00f3tima maneira de verificar se a descri\u00e7\u00e3o do hardware est\u00e1 correta. Para isso v\u00e1 em: Tools NetList Viewers RTL Viewer . Gravando \u00b6 Conecte a FPGA no Host via o conector USB Blaster Com o projeto compilando o Quartus gera um arquivo bin\u00e1rio na pasta output_files com extens\u00e3o *.sof . Esse arquivo \u00e9 o que ser\u00e1 carregado na FPGA para executar o projeto. Para isso abra: Tools Programmmer . Nessa etapa voc\u00ea deve clicar em Auto Detect, essa etapa ir\u00e1 ler via JTAG todos os dispositivos que est\u00e3o conectados no JTAG chain , voc\u00ea ir\u00e1 notar que ir\u00e3o aparecer dois dispositivos: SOCVHPS : ARM Cortex A7 5CSXFC6D6 : FPGA Talvez seja necess\u00e1rio configurar o Linux para reconhecer o JTAG, siga os passos em: Configurando USB Blaster Linux . Cheguei Aqui! Exerc\u00edcios \u00b6 : F\u00e1cil Fa\u00e7a os LEDs piscarem mais devagar Adicione bot\u00f5es ao projeto e fa\u00e7a eles controlarem os LEDs Fa\u00e7a as chaves controlarem a frequ\u00eancia na qual os LEDs piscam Adicione um PWM aos LEDs para controlar sua intensidade Entrega 1 \u00b6 Siga para a Entrega 1","title":"Tutorial 1 - FPGA - RTL"},{"location":"Tutorial-FPGA-RTL/#tutorial-1-fpga-rtl","text":"2020-2 Material atualizado. Essa primeira entrega \u00e9 um aquecimento de VHDL e FPGA, iremos criar um hardware dedicado na FPGA para controlar os LEDs com base nos sinais de entradas dos bot\u00f5es. A ideia \u00e9 passarmos por todo o processo de desenvolvimento de um projeto em FPGA e com VHDL. Tip Para quem j\u00e1 fez Design de Computadores isso \u00e9 uma revis\u00e3o, quem ainda n\u00e3o fez vai ver isso l\u00e1.","title":"Tutorial 1 - FPGA - RTL"},{"location":"Tutorial-FPGA-RTL/#comecando","text":"Para seguir esse tutorial \u00e9 necess\u00e1rio: Hardware: DE10-Standard e acess\u00f3rios Softwares: Quartus 18.01 Documentos: DE10-Standard_User_manual.pdf Entrega no git : pasta Lab1_FPGA_RTL Tip Crie um reposit\u00f3rio para a disciplina, voc\u00ea dever\u00e1 fazer as entregas por ele.","title":"Come\u00e7ando"},{"location":"Tutorial-FPGA-RTL/#quartus","text":"Primeiro, devemos criar um novo projeto no software Quartus. No Quartus: File \u27a1\ufe0f New Project Wizard Directory, Name, Top-Level Entity Escolha o destino como sendo seu reposit\u00f3rio. nomeio o projeto como Lab1_FPGA_RTL Project Type Empty Project Add Files N\u00e3o vamos adicionar nenhum arquivo por enquanto. Family, Device & Board Settings Procure pela FPGA: Family: Cyclone V Name: 5CSXFC6D6F31C6 \ud83c\udd97 Finalize o Wizard Wizard Cheguei Aqui! Outras refer\u00eancias Se precisar de outro material como refer\u00eancia, tem um tutorial da Terasic: DE10-Standard_My_First_Fpga.pdf","title":"Quartus"},{"location":"Tutorial-FPGA-RTL/#criando-o-toplevel","text":"TopLevel \u00e9 o nome do m\u00f3dulo mais superior em desenvolvimento hier\u00e1rquico onde, geralmente os sinais da entidade (in/out,...) ser\u00e3o mapeados a pinos do hardware (conex\u00e3o com o mundo externo). Vamos adicionar um arquivo ao projeto rec\u00e9m criado: File New VHDL File File save as name: Lab1_FPGA_RTL.vhd \ud83c\udd97 Inicialize o arquivo com o conte\u00fado a seguir: toplevel source file library IEEE ; use IEEE.std_logic_1164. all ; entity Lab1_FPGA_RTL is port ( -- Gloabals fpga_clk_50 : in std_logic ; -- I/Os fpga_led_pio : out std_logic_vector ( 5 downto 0 ) ); end entity Lab1_FPGA_RTL ; architecture rtl of Lab1_FPGA_RTL is -- signal signal blink : std_logic := '0' ; begin process ( fpga_clk_50 ) variable counter : integer range 0 to 25000000 := 0 ; begin if ( rising_edge ( fpga_clk_50 )) then if ( counter < 10000000 ) then counter := counter + 1 ; else blink <= not blink ; counter := 0 ; end if ; end if ; end process ; fpga_led_pio ( 0 ) <= blink ; fpga_led_pio ( 1 ) <= blink ; fpga_led_pio ( 2 ) <= blink ; fpga_led_pio ( 3 ) <= blink ; fpga_led_pio ( 4 ) <= blink ; fpga_led_pio ( 5 ) <= blink ; end rtl ; Cheguei Aqui! Info Esse c\u00f3digo poderia ser mais elegante, mas vamos deixar assim para facilitar o entendimento.","title":"Criando o topLevel"},{"location":"Tutorial-FPGA-RTL/#configurando-o-toplevel","text":"No Quartus devemos dizer qual entidade \u00e9 a topLevel, como o VHDL n\u00e3o define uma padr\u00e3o para isso, qualquer entidade pode ser configurada como top. No quartus: Project Set as Top-Level Entity Esse comando ir\u00e1 configurar o arquivo atual como sendo o topLevel do projeto. Note que o Quartus atribui ao topLevel a entidade como sendo o nome do arquivo, se por algum motivo (que acontece) o nome do arquivo n\u00e3o for igual ao da entidade isso n\u00e3o ir\u00e1 funcionar. Tip Como salvamos o arquivo com o mesmo nome do projeto e a entidade tem o mesmo nome tamb\u00e9m, o Quartus reconhece essa entidade como sendo a TopLevel como padr\u00e3o.","title":"Configurando o topLevel"},{"location":"Tutorial-FPGA-RTL/#verificando","text":"Vamos verificar se est\u00e1 tudo certo por enquanto realizando uma compila\u00e7\u00e3o completa no projeto. Para isso: Processing Start Compilation . Aguarde !! as compila\u00e7\u00f5es de HDL podem demorar bastante tempo.","title":"Verificando"},{"location":"Tutorial-FPGA-RTL/#ios","text":"Lembre que o topLevel \u00e9 a entidade que ser\u00e1 mapeada com o mundo externo, nesse caso os sinais: fpga_clk_50 ; fpga_led_pio ; devem ser conectados aos pinos da FPGA que est\u00e3o conectados nesses dispositivos (clock de 50 MHz; Seis LEDs). Note o erro que o Quartus gerou quando mandamos ele compilar o projeto ( \"Show Critical Warnings Messages\" ): Failure Critical Warning (169085): No exact pin location assignment(s) for 6 pins of 6 total pins. For the list of pins please refer to the I/O Assignment Warnings table in the fitter report. Esse erro indica que do topLevel 6 sinais n\u00e3o foram mapeados para os pinos correspondentes.","title":"I/Os"},{"location":"Tutorial-FPGA-RTL/#pinos","text":"Devemos indicar para a ferramenta quais s\u00e3o os pinos e qual padr\u00e3o de sinal ele deve utilizar para cada um dos sinais definidos na entidade do topLevel.","title":"Pinos"},{"location":"Tutorial-FPGA-RTL/#leds","text":"No manual da placa p\u00e1gina 22 temos as defini\u00e7\u00f5es de como os pinos da FPGA foram utilizados na placa: There are also ten user-controllable LEDs connected to the FPGA. Each LED is driven directly and individually by the Cyclone V SoC FPGA; driving its associated pin to a high logic level or low level to turn the LED on or off, respectively. Figure 3-17 shows the connections between LEDs and Cyclone V SoC FPGA. Table 3-6, Table 3-7 and Table 3-8 list the pin assignment of user push-buttons, switches, and LEDs.","title":"LEDs"},{"location":"Tutorial-FPGA-RTL/#clock","text":"Do manual: Figure 3-13 shows the default frequency of all external clocks to the Cyclone V SoC FPGA. A clock generator is used to distribute clock signals with low jitter. The four 50MHz clock signals connected to the FPGA are used as clock sources for user logic. One 25MHz clock signal is connected to two HPS clock inputs, and the other one is connected to the clock input of Gigabit Ethernet Transceiver. Two 24MHz clock signals are connected to the clock inputs of USB Host/OTG PHY and USB hub controller. The associated pin assignment for clock inputs to FPGA I/O pins is listed in Table 3-5.","title":"CLOCK"},{"location":"Tutorial-FPGA-RTL/#pin-assigment","text":"Iremos utilizar o Pin Planner para inserir esses pinos, para isso: Assignments Pin Planner . A interface do Pin Planner exibe os pinos/ bancos dispon\u00edveis da FPGA para serem alocados aos sinais do TopLevel. Note que a coluna Fitter Location j\u00e1 possui pinos alocados aos sinais, isso foi gerado automaticamente pelo Quartus na etapa de Filter , por\u00e9m eles n\u00e3o correspondem aos pinos reais que desejamos utilizar. Tarefa Edite a coluna Location utilizando como refer\u00eancia a figura anterior que relaciona os LEDs da placa com os pinos da FPGA. Note: no nosso projeto possu\u00edmos apenas 6 LEDs, do total de 10 dispon\u00edveis. o I/O Standard n\u00e3o reflete o definido no manual que \u00e9 3.3V CMOS . Voc\u00ea deve alterar essa coluna de 2.5V CMOS (Default) para 3.3-V LVTTL . Cheguei Aqui! Flexibilidade FPGA Normalmente atribu\u00edmos a FPGA uma flexibilidade l\u00f3gica, mas note a flexibilidade que ela possui quanto a defini\u00e7\u00e3o de n\u00edvel de sinal de cada pino. Isso permite ao desenvolvedor de hardware in\u00fameras op\u00e7\u00f5es de uso e de novas configura\u00e7\u00f5es. Assignment Editor Feche a ferramenta e abra o Assignment Editor : Assignments Assignments Editor . Note que as mesmas informa\u00e7\u00f5es inseridas anteriormente est\u00e3o nesse editor. Na verdade, todas as configura\u00e7\u00f5es da FPGA s\u00e3o exibidas no Assignments Editor e apenas algumas no Pin Planner . Recompile Recompile o projeto e note que n\u00e3o existe mais erros de aloca\u00e7\u00e3o","title":"Pin Assigment"},{"location":"Tutorial-FPGA-RTL/#timing-requirements-not-met","text":"Ao compilar o projeto ainda possu\u00edmos um erro critico : Failure Critical Warning (332012): Synopsys Design Constraints File file not found. A Synopsys Design Constraints File is required by the TimeQuest Timing Analyzer to get proper timing constraints. Without it, the Compiler will not properly optimize the design. Critical Warning (332148): Timing requirements not met Info (11105): For recommendations on closing timing, run Report Timing Closure Recommendations in the TimeQuest Timing Analyzer. Esse erro \u00e9 referente a n\u00e3o termos indicado para o Quartus qual a frequ\u00eancia de opera\u00e7\u00e3o do nosso sistema. Como a frequ\u00eancia n\u00e3o est\u00e1 definida a etapa de Fitter and Assembler n\u00e3o consegue otimizar o projeto corretamente, resultando nesse erro. Assembler aqui \u00e9 diferente do assembler de um programa como C . De uma olhada nessa refer\u00eancia para maiores detalhes.","title":"Timing Requirements not met"},{"location":"Tutorial-FPGA-RTL/#synopsys-design-constraints-file-sdc","text":"Devemos adicionar um novo arquivo ao projeto que ir\u00e1 indicar para a ferramenta quais s\u00e3o as condi\u00e7\u00f5es de contorno do projeto. Para isso: File New File Synopsys Design Constraints File Save As : Lab1_FPGA_RTL.sdc Adicione ao arquivo o seguinte conte\u00fado: # 50MHz board input clock create_clock -period 20 [get_ports fpga_clk_50] # Automatically apply a generate clock on the output of phase-locked loops (PLLs) derive_pll_clocks Essas linhas indicam para a ferramenta que o sinal fpga_clk_50 \u00e9 um sinal de clock com frequ\u00eancia 50MHz (20 ns de per\u00edodo) e \u00e9 para a inferir outros clocks autom\u00e1ticos (exe: caso um PLL seja utilizado). 1^: https://www.altera.com/support/support-resources/design-examples/design-software/timinganalyzer/exm-tq-basic-sdc-template.html Tarefa Crie e inicialize o arquivo .sdc Compile o projeto Recompile Recompile o projeto e note que n\u00e3o existe mais erros cr\u00edticos no projeto. Cheguei Aqui!","title":"Synopsys Design Constraints File: .sdc"},{"location":"Tutorial-FPGA-RTL/#rtl-viewer","text":"RTL Viewer \u00e9 uma maneira gr\u00e1fica de verificar se o c\u00f3digo em HDL foi interpretado corretamente pela ferramenta, e uma \u00f3tima maneira de verificar se a descri\u00e7\u00e3o do hardware est\u00e1 correta. Para isso v\u00e1 em: Tools NetList Viewers RTL Viewer .","title":"RTL Viewer"},{"location":"Tutorial-FPGA-RTL/#gravando","text":"Conecte a FPGA no Host via o conector USB Blaster Com o projeto compilando o Quartus gera um arquivo bin\u00e1rio na pasta output_files com extens\u00e3o *.sof . Esse arquivo \u00e9 o que ser\u00e1 carregado na FPGA para executar o projeto. Para isso abra: Tools Programmmer . Nessa etapa voc\u00ea deve clicar em Auto Detect, essa etapa ir\u00e1 ler via JTAG todos os dispositivos que est\u00e3o conectados no JTAG chain , voc\u00ea ir\u00e1 notar que ir\u00e3o aparecer dois dispositivos: SOCVHPS : ARM Cortex A7 5CSXFC6D6 : FPGA Talvez seja necess\u00e1rio configurar o Linux para reconhecer o JTAG, siga os passos em: Configurando USB Blaster Linux . Cheguei Aqui!","title":"Gravando"},{"location":"Tutorial-FPGA-RTL/#exercicios","text":": F\u00e1cil Fa\u00e7a os LEDs piscarem mais devagar Adicione bot\u00f5es ao projeto e fa\u00e7a eles controlarem os LEDs Fa\u00e7a as chaves controlarem a frequ\u00eancia na qual os LEDs piscam Adicione um PWM aos LEDs para controlar sua intensidade","title":"Exerc\u00edcios"},{"location":"Tutorial-FPGA-RTL/#entrega-1","text":"Siga para a Entrega 1","title":"Entrega 1"},{"location":"Tutorial-HPS-BlinkLED/","text":"Tutorial 6 - HPS - BlinkLED \u00b6 2020-2 Material atualizado. Nesse tutorial iremos compilar um programa para o HPS (Arm Cortex A) que ser\u00e1 capaz de controlar os LEDs e ler os bot\u00f5es da placa que est\u00e3o conectados ao HPS. Note pelo diagrama anterior extra\u00eddo do manual do usu\u00e1rio, existem LEDs e bot\u00f5es conectados diretamente ao HPS, e outros conectados a FPGA. Duas s\u00e3o as poss\u00edveis abordagens para programarmos o HPS: baremetal \u00b6 Far\u00edamos um programa que seria executado no ARM HPS sem nenhum sistema operacional. Como detalhado no diagrama: Altera Bare Metal User Guide Nessa maneira a aplica\u00e7\u00e3o deve ser capaz de realizar toda a inicializa\u00e7\u00e3o de HW necess\u00e1ria para que o processador rode corretamente. Se a aplica\u00e7\u00e3o for executada sobre um sistema operacional, toda essa etapa \u00e9 de compila\u00e7\u00e3o \u00e9 responsabilidade do SO. Para isso \u00e9 aconselh\u00e1vel utilizar a IDE da ARM chamada de DS-5 Sistema operacional \u00b6 Diversas s\u00e3o as alternativas de sistema operacional para embarcado, tudo ir\u00e1 depender da especifica\u00e7\u00e3o da aplica\u00e7\u00e3o. \u00c9 necess\u00e1rio saber se existem requisitos de tempo real, se sim, deve-se considerar utilizar um RTOS ou algum sistema operacional com essa funcionalidade (existe um patch no kernel do linux que o torna mais ou menos real time). Se \u00e9 uma aplica\u00e7\u00e3o que demanda rede, v\u00eddeo, processamento de dados, \u00e9 de se considerar utilizar um Linux (Android), j\u00e1 que existem ferramentas que facilitam o desenvolvimento de aplica\u00e7\u00f5es nessa plataforma (j\u00e1 tem muita coisa pronta e uma comunidade gigantesca). Com o uso de um sistema operacional a parte referente ao HW \u00e9 responsabilidade do kernel (ou dos desenvolvedores que est\u00e3o adequando o kernel ao HW, que \u00e9 o nosso caso). Diversos s\u00e3o os ganhos de utilizar um sistema operacional do tipo Linux, podemos listar algumas Device drivers Portabilidade Seguran\u00e7a Rede As perdas tamb\u00e9m s\u00e3o grandes: maior ocupa\u00e7\u00e3o de mem\u00f3ria, maior lat\u00eancias, boot lento ... Software pisca led \u00b6 Iremos compilar um programa e executar no Linux Embarcado. esse programa ser\u00e1 executado no user space . Para isso iremos vamos usar a toolchain do tutorial anterior . Iremos utilizar como base o c\u00f3digo exemplo da Terasic dispon\u00edvel no reposit\u00f3rio: DE10-Standard-v.1.3.0-SystemCD/Demonstration/SoC/my_first_hps . E crosscopilar esse c\u00f3digo para o nosso HPS utilizando o Makefile da pasta. Sobre o programa \u00b6 Esse programa controla um LED que est\u00e1 conectado na parte do ARM do chip: Os pinos s\u00e3o controlados pelo perif\u00e9rico GPIO do HPS (ARM), para isso \u00e9 necess\u00e1rio acessar esse perif\u00e9rico do Linux, isso \u00e9 feito de maneira similar como faz\u00edamos em Computa\u00e7\u00e3o Embarcada, um ponteiro que aponta para a regi\u00e3o de mem\u00f3ria do componente e configura seus registradores: Em sistemas baremetal podemos simplesmente criar um ponteiro que aponta para a regi\u00e3o de mem\u00f3ria que desejamos alterar, no linux n\u00e3o podemos fazer isso de forma direta (via userspace) pois os sistemas operacionais trabalham com mapa de mem\u00f3rias onde o endere\u00e7o 'virtual' n\u00e3o representa o endere\u00e7o real (lembre de Sys-HW-SW). No linux, para termos acesso a mem\u00f3ria real devemos mapear a mem\u00f3ria real na virtual usando o comando mmap : int main ( int argc , char ** argv ) { void * virtual_base ; int fd ; //... // map the address space for the LED registers into user space so we can interact with them. // we'll actually map in the entire CSR span of the HPS since we want to access various registers within that span if ( ( fd = open ( \"/dev/mem\" , ( O_RDWR | O_SYNC ) ) ) == -1 ) { printf ( \"ERROR: could not open \\\" /dev/mem \\\" ... \\n \" ); return ( 1 ); } virtual_base = mmap ( NULL , HW_REGS_SPAN , ( PROT_READ | PROT_WRITE ), MAP_SHARED , fd , HW_REGS_BASE ); Agora o ponteiro virtual_base aponta para o perif\u00e9rico GPIO, e podemos manipular esse endere\u00e7o igual faz\u00edamos em Computa\u00e7\u00e3o Embarcada. while ( 1 ){ scan_input = alt_read_word ( ( virtual_base + ( ( uint32_t )( ALT_GPIO1_EXT_PORTA_ADDR ) & ( uint32_t )( HW_REGS_MASK ) ) ) ); if ( ~ scan_input & BUTTON_MASK ) alt_setbits_word ( ( virtual_base + ( ( uint32_t )( ALT_GPIO1_SWPORTA_DR_ADDR ) & ( uint32_t )( HW_REGS_MASK ) ) ), BIT_LED ); else alt_clrbits_word ( ( virtual_base + ( ( uint32_t )( ALT_GPIO1_SWPORTA_DR_ADDR ) & ( uint32_t )( HW_REGS_MASK ) ) ), BIT_LED ); } Note Esse Makefile s\u00f3 funciona porque configuramos o nosso bashrc com as vari\u00e1veis de sistemas que ele utiliza. Por exemplo, a linha SOCEDS_ROOT ?= $(SOCEDS_DEST_ROOT) usa a vari\u00e1vel SOCEDS_DEST_ROOT que foi configurara no tutorial anterior, assim como o arm-linux-gnueabihf- ... Tarefa clone o reposit\u00f3rio: https://github.com/Insper/DE10-Standard-v.1.3.0-SystemCD entre na pasta Demonstration/SoC/hps_gpio execute o comando make Resultado esperado: arm-linux-gnueabihf-gcc -g -Wall -Dsoc_cv_av -I/media/corsi/dados/intelFPGA/20.1/embedded/ip/altera/hps/altera_hps/hwlib/include/soc_cv_av -I/media/corsi/dados/intelFPGA/20.1/embedded/ip/altera/hps/altera_hps/hwlib/include/ -c main.c -o main.o arm-linux-gnueabihf-gcc -g -Wall main.o -o my_first_hps Se obter algo como: make: arm-linux-gnueabihf-gcc: Command not found Makefile:19: recipe for target 'main.o' failed make: *** [main.o] Error 127 \u00c9 porque voc\u00ea n\u00e3o configurou corretamente o gcc na etapa anterior. Executando no target \u00b6 Agora basta copiar o bin\u00e1rio criado pela compila\u00e7\u00e3o para o cart\u00e3o de mem\u00f3ria e testar o nosso programa no target (HPS). Com o cart\u00e3o de mem\u00f3ria no host (seu computador) copie o arquivo bin\u00e1rio: hps_gpio para a pasta: /home/root/ do cart\u00e3o de mem\u00f3ria. Note que existem duas parti\u00e7\u00f5es, voc\u00ea deve copiar para aquela que possui o root . Note Talvez voc\u00ea tenha que copiar usando sudo, no meu caso eu executo: $ sudo cp hps_gpio /media/corsi/847f4797-311c-4286-8370-9d5573b201d7/home/root Note Sempre que manipular um dispositivo de mem\u00f3ria externo, \u00e9 aconselh\u00e1vel fazer um flush do cache para for\u00e7ar o linux alterar o dispositivo externo, caso contr\u00e1rio a altera\u00e7\u00e3o poder\u00e1 ficar s\u00f3 na mem\u00f3ria local ao PC. $ sync A fun\u00e7\u00e3o sync \u00e9 blocante, ficar\u00e1 travada enquanto o linux faz o flush dos dados. Tarefas coloque o SDCARD de volta na fpga acesse via terminal e execute o programa ( /home/root/hps_gpio ) os leds da placa devem piscar. Praticando \u00b6 Para praticar um pouco. Tarefa Fa\u00e7a o programa ler apenas duas vezes o bot\u00e3o, e depois disso termina a aplica\u00e7\u00e3o! Fluxo de desenvolvimento \u00b6 Esse fluxo de desenvolvimento n\u00e3o \u00e9 dos melhores n\u00e9? \u00c9 bom programar no host , mas esse esquema de ter que ficar tirando e colocando cart\u00e3o de mem\u00f3ria, esperar o linux do target subir, logar e testar n\u00e3o faz bem para ningu\u00e9m. Existem v\u00e1rias solu\u00e7\u00f5es para melhorar isso, cada qual com sua vantagem/desvantagem: build no pr\u00f3prio target (ruim para o programador, \u00f3timo para depend\u00eancias, f\u00e1cil de debugar, lento) criar uma vmw arm e compilar nela (bom para o programador, \u00f3timo para depend\u00eancias, +- f\u00e1cil de debugar, r\u00e1pido, dif\u00edcil de configurar) crosscompilar (bom para o programador, ruim para depend\u00eancias, dif\u00edcil de debugar, r\u00e1pido) Na entrega 4 vamos aprimorar nosso sistema de compila\u00e7\u00e3o e testes.","title":"Tutorial 6 - HPS - BlinkLED"},{"location":"Tutorial-HPS-BlinkLED/#tutorial-6-hps-blinkled","text":"2020-2 Material atualizado. Nesse tutorial iremos compilar um programa para o HPS (Arm Cortex A) que ser\u00e1 capaz de controlar os LEDs e ler os bot\u00f5es da placa que est\u00e3o conectados ao HPS. Note pelo diagrama anterior extra\u00eddo do manual do usu\u00e1rio, existem LEDs e bot\u00f5es conectados diretamente ao HPS, e outros conectados a FPGA. Duas s\u00e3o as poss\u00edveis abordagens para programarmos o HPS:","title":"Tutorial 6 - HPS - BlinkLED"},{"location":"Tutorial-HPS-BlinkLED/#baremetal","text":"Far\u00edamos um programa que seria executado no ARM HPS sem nenhum sistema operacional. Como detalhado no diagrama: Altera Bare Metal User Guide Nessa maneira a aplica\u00e7\u00e3o deve ser capaz de realizar toda a inicializa\u00e7\u00e3o de HW necess\u00e1ria para que o processador rode corretamente. Se a aplica\u00e7\u00e3o for executada sobre um sistema operacional, toda essa etapa \u00e9 de compila\u00e7\u00e3o \u00e9 responsabilidade do SO. Para isso \u00e9 aconselh\u00e1vel utilizar a IDE da ARM chamada de DS-5","title":"baremetal"},{"location":"Tutorial-HPS-BlinkLED/#sistema-operacional","text":"Diversas s\u00e3o as alternativas de sistema operacional para embarcado, tudo ir\u00e1 depender da especifica\u00e7\u00e3o da aplica\u00e7\u00e3o. \u00c9 necess\u00e1rio saber se existem requisitos de tempo real, se sim, deve-se considerar utilizar um RTOS ou algum sistema operacional com essa funcionalidade (existe um patch no kernel do linux que o torna mais ou menos real time). Se \u00e9 uma aplica\u00e7\u00e3o que demanda rede, v\u00eddeo, processamento de dados, \u00e9 de se considerar utilizar um Linux (Android), j\u00e1 que existem ferramentas que facilitam o desenvolvimento de aplica\u00e7\u00f5es nessa plataforma (j\u00e1 tem muita coisa pronta e uma comunidade gigantesca). Com o uso de um sistema operacional a parte referente ao HW \u00e9 responsabilidade do kernel (ou dos desenvolvedores que est\u00e3o adequando o kernel ao HW, que \u00e9 o nosso caso). Diversos s\u00e3o os ganhos de utilizar um sistema operacional do tipo Linux, podemos listar algumas Device drivers Portabilidade Seguran\u00e7a Rede As perdas tamb\u00e9m s\u00e3o grandes: maior ocupa\u00e7\u00e3o de mem\u00f3ria, maior lat\u00eancias, boot lento ...","title":"Sistema operacional"},{"location":"Tutorial-HPS-BlinkLED/#software-pisca-led","text":"Iremos compilar um programa e executar no Linux Embarcado. esse programa ser\u00e1 executado no user space . Para isso iremos vamos usar a toolchain do tutorial anterior . Iremos utilizar como base o c\u00f3digo exemplo da Terasic dispon\u00edvel no reposit\u00f3rio: DE10-Standard-v.1.3.0-SystemCD/Demonstration/SoC/my_first_hps . E crosscopilar esse c\u00f3digo para o nosso HPS utilizando o Makefile da pasta.","title":"Software pisca led"},{"location":"Tutorial-HPS-BlinkLED/#sobre-o-programa","text":"Esse programa controla um LED que est\u00e1 conectado na parte do ARM do chip: Os pinos s\u00e3o controlados pelo perif\u00e9rico GPIO do HPS (ARM), para isso \u00e9 necess\u00e1rio acessar esse perif\u00e9rico do Linux, isso \u00e9 feito de maneira similar como faz\u00edamos em Computa\u00e7\u00e3o Embarcada, um ponteiro que aponta para a regi\u00e3o de mem\u00f3ria do componente e configura seus registradores: Em sistemas baremetal podemos simplesmente criar um ponteiro que aponta para a regi\u00e3o de mem\u00f3ria que desejamos alterar, no linux n\u00e3o podemos fazer isso de forma direta (via userspace) pois os sistemas operacionais trabalham com mapa de mem\u00f3rias onde o endere\u00e7o 'virtual' n\u00e3o representa o endere\u00e7o real (lembre de Sys-HW-SW). No linux, para termos acesso a mem\u00f3ria real devemos mapear a mem\u00f3ria real na virtual usando o comando mmap : int main ( int argc , char ** argv ) { void * virtual_base ; int fd ; //... // map the address space for the LED registers into user space so we can interact with them. // we'll actually map in the entire CSR span of the HPS since we want to access various registers within that span if ( ( fd = open ( \"/dev/mem\" , ( O_RDWR | O_SYNC ) ) ) == -1 ) { printf ( \"ERROR: could not open \\\" /dev/mem \\\" ... \\n \" ); return ( 1 ); } virtual_base = mmap ( NULL , HW_REGS_SPAN , ( PROT_READ | PROT_WRITE ), MAP_SHARED , fd , HW_REGS_BASE ); Agora o ponteiro virtual_base aponta para o perif\u00e9rico GPIO, e podemos manipular esse endere\u00e7o igual faz\u00edamos em Computa\u00e7\u00e3o Embarcada. while ( 1 ){ scan_input = alt_read_word ( ( virtual_base + ( ( uint32_t )( ALT_GPIO1_EXT_PORTA_ADDR ) & ( uint32_t )( HW_REGS_MASK ) ) ) ); if ( ~ scan_input & BUTTON_MASK ) alt_setbits_word ( ( virtual_base + ( ( uint32_t )( ALT_GPIO1_SWPORTA_DR_ADDR ) & ( uint32_t )( HW_REGS_MASK ) ) ), BIT_LED ); else alt_clrbits_word ( ( virtual_base + ( ( uint32_t )( ALT_GPIO1_SWPORTA_DR_ADDR ) & ( uint32_t )( HW_REGS_MASK ) ) ), BIT_LED ); } Note Esse Makefile s\u00f3 funciona porque configuramos o nosso bashrc com as vari\u00e1veis de sistemas que ele utiliza. Por exemplo, a linha SOCEDS_ROOT ?= $(SOCEDS_DEST_ROOT) usa a vari\u00e1vel SOCEDS_DEST_ROOT que foi configurara no tutorial anterior, assim como o arm-linux-gnueabihf- ... Tarefa clone o reposit\u00f3rio: https://github.com/Insper/DE10-Standard-v.1.3.0-SystemCD entre na pasta Demonstration/SoC/hps_gpio execute o comando make Resultado esperado: arm-linux-gnueabihf-gcc -g -Wall -Dsoc_cv_av -I/media/corsi/dados/intelFPGA/20.1/embedded/ip/altera/hps/altera_hps/hwlib/include/soc_cv_av -I/media/corsi/dados/intelFPGA/20.1/embedded/ip/altera/hps/altera_hps/hwlib/include/ -c main.c -o main.o arm-linux-gnueabihf-gcc -g -Wall main.o -o my_first_hps Se obter algo como: make: arm-linux-gnueabihf-gcc: Command not found Makefile:19: recipe for target 'main.o' failed make: *** [main.o] Error 127 \u00c9 porque voc\u00ea n\u00e3o configurou corretamente o gcc na etapa anterior.","title":"Sobre o programa"},{"location":"Tutorial-HPS-BlinkLED/#executando-no-target","text":"Agora basta copiar o bin\u00e1rio criado pela compila\u00e7\u00e3o para o cart\u00e3o de mem\u00f3ria e testar o nosso programa no target (HPS). Com o cart\u00e3o de mem\u00f3ria no host (seu computador) copie o arquivo bin\u00e1rio: hps_gpio para a pasta: /home/root/ do cart\u00e3o de mem\u00f3ria. Note que existem duas parti\u00e7\u00f5es, voc\u00ea deve copiar para aquela que possui o root . Note Talvez voc\u00ea tenha que copiar usando sudo, no meu caso eu executo: $ sudo cp hps_gpio /media/corsi/847f4797-311c-4286-8370-9d5573b201d7/home/root Note Sempre que manipular um dispositivo de mem\u00f3ria externo, \u00e9 aconselh\u00e1vel fazer um flush do cache para for\u00e7ar o linux alterar o dispositivo externo, caso contr\u00e1rio a altera\u00e7\u00e3o poder\u00e1 ficar s\u00f3 na mem\u00f3ria local ao PC. $ sync A fun\u00e7\u00e3o sync \u00e9 blocante, ficar\u00e1 travada enquanto o linux faz o flush dos dados. Tarefas coloque o SDCARD de volta na fpga acesse via terminal e execute o programa ( /home/root/hps_gpio ) os leds da placa devem piscar.","title":"Executando no target"},{"location":"Tutorial-HPS-BlinkLED/#praticando","text":"Para praticar um pouco. Tarefa Fa\u00e7a o programa ler apenas duas vezes o bot\u00e3o, e depois disso termina a aplica\u00e7\u00e3o!","title":"Praticando"},{"location":"Tutorial-HPS-BlinkLED/#fluxo-de-desenvolvimento","text":"Esse fluxo de desenvolvimento n\u00e3o \u00e9 dos melhores n\u00e9? \u00c9 bom programar no host , mas esse esquema de ter que ficar tirando e colocando cart\u00e3o de mem\u00f3ria, esperar o linux do target subir, logar e testar n\u00e3o faz bem para ningu\u00e9m. Existem v\u00e1rias solu\u00e7\u00f5es para melhorar isso, cada qual com sua vantagem/desvantagem: build no pr\u00f3prio target (ruim para o programador, \u00f3timo para depend\u00eancias, f\u00e1cil de debugar, lento) criar uma vmw arm e compilar nela (bom para o programador, \u00f3timo para depend\u00eancias, +- f\u00e1cil de debugar, r\u00e1pido, dif\u00edcil de configurar) crosscompilar (bom para o programador, ruim para depend\u00eancias, dif\u00edcil de debugar, r\u00e1pido) Na entrega 4 vamos aprimorar nosso sistema de compila\u00e7\u00e3o e testes.","title":"Fluxo de desenvolvimento"},{"location":"Tutorial-HPS-BuildSystem/","text":"Tutorial 5 - HPS - Infra \u00b6 2020-2 Material atualizado. Vamos instalar o ferramental (compiladores) que ser\u00e1 utilizado para compilar o kernel e o filesystem. Deveremos instalar o soceds e o linaro-gcc . Intel SOCDES \u00b6 !! ! warning Usando o ssd fornecido? Pode pular essa parte de instalar o soceds, siga para instalar o toolchain Voc\u00ea ir\u00e1 precisar ter o software SOCEDS instalado, e ele precisa ser a mesma vers\u00e3o do Quartus. Link para download: Intel SoC FPGA Embedded Development Suite Vamos precisar inserir no path do bash refer\u00eancia para uma s\u00e9rie de softwares a serem usados, modifique seu .bashrc inserindo: Ao fazer o download do soceds deve-se verificar para ser a mesma vers\u00e3o do Quartus. export ALTERAPATH = ~/intelFPGA/18.1/ export ALTERAPATH = /home/corsi/opt/intelFPGA/18.1 export QUARTUS_ROOTDIR = $ALTERAPATH /quartus/ export PATH = $PATH : ${ ALTERAPATH } /quartus/bin export PATH = $PATH : ${ ALTERAPATH } /modelsim_ase/linuxaloem/ export PATH = $PATH : ${ ALTERAPATH } /quartus/sopc_builder/bin/ export PATH = $PATH : ${ ALTERAPATH } /embedded/ export PATH = $PATH : ${ ALTERAPATH } /embedded/host_tools/altera/preloadergen/ export PATH = $PATH : ${ ALTERAPATH } /hls/bin/ export LD_LIBRARY_PATH = ${ ALTERAPATH } /hls/host/linux64/lib/ export PATH = $PATH : ${ ALTERAPATH } /nios2eds/ export PATH = $PATH : ${ ALTERAPATH } /nios2eds/sdk2/bin/ export SOCEDS_DEST_ROOT = ${ ALTERAPATH } /embedded export SOCEDS_HWLIB = ${ ALTERAPATH } /embedded/ip/altera/hps/altera_hps/hwlib/ Note Lembre de verificar se o ALTERAPATH desse exemplo \u00e9 o caminho correto da instala\u00e7\u00e3o do Quartus outros bashs Se estiver usando outro bash (zsh/ fish) ser\u00e1 necess\u00e1rio editar o arquivo de configura\u00e7\u00e3o referente. Testando \u00b6 Para testar, digite no terminal nios2_command_shell.sh (ap\u00f3s abrir uma nova aba, ou executar source ~/.bashrc ): $ nios2_command_shell.sh ------------------------------------------------ Altera Nios2 Command Shell [ GCC 4 ] Version 16 .1, Build 196 ------------------------------------------------ $ exit Note Isso s\u00f3 testa uma parte da instala\u00e7\u00e3o (soceds) GCC toolchain \u00b6 Iremos utilizar o GCC cross compile fornecido pelo Linaro, esse mesmo GCC ser\u00e1 utilizado para compilar o Kernel, gerar o file system e compilar os programas que executar\u00e3o no Linux. Wikipidia Linaro Linaro is an engineering organization that works on free and open-source software such as the Linux kernel, the GNU Compiler Collection, power management, graphics and multimedia interfaces for the ARM family of instruction sets and implementations thereof as well as for the Heterogeneous System Architecture. https://en.wikipedia.org/wiki/Linaro gcc No site do linaro existem v\u00e1rios GCC diferentes, cada um com uma configura\u00e7\u00e3o diferente. O que vamos usar \u00e9 arm-linux-gnueabihf isso significa: linux : para compilar programas que executar\u00e3o no linux (poderia ser baremetal) eabi : Embedded Application Binary Interface para ser usado pelo sistema operacional. hf : usa multiplica\u00e7\u00e3o de ponto flutuante de hardware Do site de bin\u00e1rios do Linaro abaixe a vers\u00e3o gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf.tar.xz e extra\u00eda para alguma pasta no seu Linux. Quer baixar via terminal? Meus projetos ficam todos dentro da pasta: /home/corsi/work/ , por isso eu extra\u00ed para l\u00e1. Voc\u00ea pode escolher outro local. $ cd ~/work $ wget https://releases.linaro.org/components/toolchain/binaries/latest-7/arm-linux-gnueabihf/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf.tar.xz $ tar xvf gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf.tar.xz De uma olhada na pasta rec\u00e9m extra\u00edda: $ cd gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf $ tree -L 1 ... + arm-linux-gnueabihf + bin + arm-linux-gnueabihf-addr2line + arm-linux-gnueabihf-ar + ... + arm-linux-gnueabihf-c++ + arm-linux-gnueabihf-g++ + arm-linux-gnueabihf-gcc + include + lib + libexec + share Temos todas as ferramentas necess\u00e1rias para compilar e linkar c\u00f3digos em C e C++ para o ARM. Note que no path do gcc temos o prefixo : gnueabihf . Pesquisa Qual a diferen\u00e7a entre eabi e hf Criando um atalho no bash \u00b6 Vamos criar um atalho para essa pasta no bash. Edite o arquivo ~/.bashrc para incluir a pasta ~/work/gcc-linaro.../bin/ na vari\u00e1vel do sistema: GCC_Linaro . # GCC Linaro on path export GCC_Linaro = /home/corsi/work/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf/bin export PATH = $PATH : ${ GCC_Linaro } Note Edite o comando para a pasta correta de onde Linaro foi extra\u00eddo: /home/... Agora temos um atalho para o gcc-arm , vamos testar : $ $GCC_Linaro /arm-linux-gnueabihf-gcc -v ... Using built-in specs. COLLECT_GCC = /home/corsi/work/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-gcc COLLECT_LTO_WRAPPER = /home/corsi/work/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf/bin/../libexec/gcc/arm-linux-gnueabihf/7.4.1/lto-wrapper E ele tamb\u00e9m deve estar no path, como arm-linux-* : Note \u00c9 poss\u00edvel instalar o arm-linux via apt install , mas n\u00e3o vamos fazer isso pois queremos ter controle da vers\u00e3o do compilador que estamos utilizando. bashrc ao final Eu n\u00e3o modifico meu bashrc , o que eu fa\u00e7o \u00e9 criar um arquivo com o nome: Quartus18.sh e coloco toda essa configura\u00e7\u00e3o nele, e quando eu quero trabalhar na disciplina eu s\u00f3 preciso executar source ~/Quartus18.sh e tenho meu ambiente configurado. Com isso, eu tenho a vantagem de ter 'v\u00e1rias' vers\u00f5es instaladas e selecionar a que quero trabalhar. Isso tamb\u00e9m funciona pois eu tenho ambientes diferentes, com base nas disciplinas: Elementos tem um e Avan\u00e7ados outro. Meu Quartus18.sh \u00e9 o seguinte: echo \"INTEL FPGA QUARTUS 18.1\" export MGLS_LICENSE_FILE=/home/corsi/opt/intelFPGA/1-MBTRJ3_License.dat export LM_LICENSE_FILE=/home/corsi/opt/intelFPGA/1-MBTRJ3_License.dat export ALTERAPATH=/home/corsi/opt/intelFPGA/18.1 export QUARTUS_ROOTDIR=$ALTERAPATH/quartus/ export PATH=$PATH:${ALTERAPATH}/quartus/bin export PATH=$PATH:${ALTERAPATH}/modelsim_ase/linuxaloem/ export PATH=$PATH:${ALTERAPATH}/quartus/sopc_builder/bin/ export PATH=$PATH:${ALTERAPATH}/embedded/ export PATH=$PATH:${ALTERAPATH}/embedded/host_tools/altera/preloadergen/ export PATH=$PATH:${ALTERAPATH}/hls/bin/ export LD_LIBRARY_PATH=${ALTERAPATH}/hls/host/linux64/lib/ export PATH=$PATH:${ALTERAPATH}/nios2eds/ export PATH=$PATH:${ALTERAPATH}/nios2eds/sdk2/bin/ export SOCEDS_DEST_ROOT=${ALTERAPATH}/embedded export SOCEDS_HWLIB=${ALTERAPATH}/embedded/ip/altera/hps/altera_hps/hwlib/ export GCC_Linaro=/home/corsi/work/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf/bin export PATH=$PATH:${GCC_Linaro}","title":"Tutorial 5 - HPS - Infra"},{"location":"Tutorial-HPS-BuildSystem/#tutorial-5-hps-infra","text":"2020-2 Material atualizado. Vamos instalar o ferramental (compiladores) que ser\u00e1 utilizado para compilar o kernel e o filesystem. Deveremos instalar o soceds e o linaro-gcc .","title":"Tutorial 5 - HPS - Infra"},{"location":"Tutorial-HPS-BuildSystem/#intel-socdes","text":"!! ! warning Usando o ssd fornecido? Pode pular essa parte de instalar o soceds, siga para instalar o toolchain Voc\u00ea ir\u00e1 precisar ter o software SOCEDS instalado, e ele precisa ser a mesma vers\u00e3o do Quartus. Link para download: Intel SoC FPGA Embedded Development Suite Vamos precisar inserir no path do bash refer\u00eancia para uma s\u00e9rie de softwares a serem usados, modifique seu .bashrc inserindo: Ao fazer o download do soceds deve-se verificar para ser a mesma vers\u00e3o do Quartus. export ALTERAPATH = ~/intelFPGA/18.1/ export ALTERAPATH = /home/corsi/opt/intelFPGA/18.1 export QUARTUS_ROOTDIR = $ALTERAPATH /quartus/ export PATH = $PATH : ${ ALTERAPATH } /quartus/bin export PATH = $PATH : ${ ALTERAPATH } /modelsim_ase/linuxaloem/ export PATH = $PATH : ${ ALTERAPATH } /quartus/sopc_builder/bin/ export PATH = $PATH : ${ ALTERAPATH } /embedded/ export PATH = $PATH : ${ ALTERAPATH } /embedded/host_tools/altera/preloadergen/ export PATH = $PATH : ${ ALTERAPATH } /hls/bin/ export LD_LIBRARY_PATH = ${ ALTERAPATH } /hls/host/linux64/lib/ export PATH = $PATH : ${ ALTERAPATH } /nios2eds/ export PATH = $PATH : ${ ALTERAPATH } /nios2eds/sdk2/bin/ export SOCEDS_DEST_ROOT = ${ ALTERAPATH } /embedded export SOCEDS_HWLIB = ${ ALTERAPATH } /embedded/ip/altera/hps/altera_hps/hwlib/ Note Lembre de verificar se o ALTERAPATH desse exemplo \u00e9 o caminho correto da instala\u00e7\u00e3o do Quartus outros bashs Se estiver usando outro bash (zsh/ fish) ser\u00e1 necess\u00e1rio editar o arquivo de configura\u00e7\u00e3o referente.","title":"Intel SOCDES"},{"location":"Tutorial-HPS-BuildSystem/#testando","text":"Para testar, digite no terminal nios2_command_shell.sh (ap\u00f3s abrir uma nova aba, ou executar source ~/.bashrc ): $ nios2_command_shell.sh ------------------------------------------------ Altera Nios2 Command Shell [ GCC 4 ] Version 16 .1, Build 196 ------------------------------------------------ $ exit Note Isso s\u00f3 testa uma parte da instala\u00e7\u00e3o (soceds)","title":"Testando"},{"location":"Tutorial-HPS-BuildSystem/#gcc-toolchain","text":"Iremos utilizar o GCC cross compile fornecido pelo Linaro, esse mesmo GCC ser\u00e1 utilizado para compilar o Kernel, gerar o file system e compilar os programas que executar\u00e3o no Linux. Wikipidia Linaro Linaro is an engineering organization that works on free and open-source software such as the Linux kernel, the GNU Compiler Collection, power management, graphics and multimedia interfaces for the ARM family of instruction sets and implementations thereof as well as for the Heterogeneous System Architecture. https://en.wikipedia.org/wiki/Linaro gcc No site do linaro existem v\u00e1rios GCC diferentes, cada um com uma configura\u00e7\u00e3o diferente. O que vamos usar \u00e9 arm-linux-gnueabihf isso significa: linux : para compilar programas que executar\u00e3o no linux (poderia ser baremetal) eabi : Embedded Application Binary Interface para ser usado pelo sistema operacional. hf : usa multiplica\u00e7\u00e3o de ponto flutuante de hardware Do site de bin\u00e1rios do Linaro abaixe a vers\u00e3o gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf.tar.xz e extra\u00eda para alguma pasta no seu Linux. Quer baixar via terminal? Meus projetos ficam todos dentro da pasta: /home/corsi/work/ , por isso eu extra\u00ed para l\u00e1. Voc\u00ea pode escolher outro local. $ cd ~/work $ wget https://releases.linaro.org/components/toolchain/binaries/latest-7/arm-linux-gnueabihf/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf.tar.xz $ tar xvf gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf.tar.xz De uma olhada na pasta rec\u00e9m extra\u00edda: $ cd gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf $ tree -L 1 ... + arm-linux-gnueabihf + bin + arm-linux-gnueabihf-addr2line + arm-linux-gnueabihf-ar + ... + arm-linux-gnueabihf-c++ + arm-linux-gnueabihf-g++ + arm-linux-gnueabihf-gcc + include + lib + libexec + share Temos todas as ferramentas necess\u00e1rias para compilar e linkar c\u00f3digos em C e C++ para o ARM. Note que no path do gcc temos o prefixo : gnueabihf . Pesquisa Qual a diferen\u00e7a entre eabi e hf","title":"GCC toolchain"},{"location":"Tutorial-HPS-BuildSystem/#criando-um-atalho-no-bash","text":"Vamos criar um atalho para essa pasta no bash. Edite o arquivo ~/.bashrc para incluir a pasta ~/work/gcc-linaro.../bin/ na vari\u00e1vel do sistema: GCC_Linaro . # GCC Linaro on path export GCC_Linaro = /home/corsi/work/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf/bin export PATH = $PATH : ${ GCC_Linaro } Note Edite o comando para a pasta correta de onde Linaro foi extra\u00eddo: /home/... Agora temos um atalho para o gcc-arm , vamos testar : $ $GCC_Linaro /arm-linux-gnueabihf-gcc -v ... Using built-in specs. COLLECT_GCC = /home/corsi/work/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-gcc COLLECT_LTO_WRAPPER = /home/corsi/work/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf/bin/../libexec/gcc/arm-linux-gnueabihf/7.4.1/lto-wrapper E ele tamb\u00e9m deve estar no path, como arm-linux-* : Note \u00c9 poss\u00edvel instalar o arm-linux via apt install , mas n\u00e3o vamos fazer isso pois queremos ter controle da vers\u00e3o do compilador que estamos utilizando. bashrc ao final Eu n\u00e3o modifico meu bashrc , o que eu fa\u00e7o \u00e9 criar um arquivo com o nome: Quartus18.sh e coloco toda essa configura\u00e7\u00e3o nele, e quando eu quero trabalhar na disciplina eu s\u00f3 preciso executar source ~/Quartus18.sh e tenho meu ambiente configurado. Com isso, eu tenho a vantagem de ter 'v\u00e1rias' vers\u00f5es instaladas e selecionar a que quero trabalhar. Isso tamb\u00e9m funciona pois eu tenho ambientes diferentes, com base nas disciplinas: Elementos tem um e Avan\u00e7ados outro. Meu Quartus18.sh \u00e9 o seguinte: echo \"INTEL FPGA QUARTUS 18.1\" export MGLS_LICENSE_FILE=/home/corsi/opt/intelFPGA/1-MBTRJ3_License.dat export LM_LICENSE_FILE=/home/corsi/opt/intelFPGA/1-MBTRJ3_License.dat export ALTERAPATH=/home/corsi/opt/intelFPGA/18.1 export QUARTUS_ROOTDIR=$ALTERAPATH/quartus/ export PATH=$PATH:${ALTERAPATH}/quartus/bin export PATH=$PATH:${ALTERAPATH}/modelsim_ase/linuxaloem/ export PATH=$PATH:${ALTERAPATH}/quartus/sopc_builder/bin/ export PATH=$PATH:${ALTERAPATH}/embedded/ export PATH=$PATH:${ALTERAPATH}/embedded/host_tools/altera/preloadergen/ export PATH=$PATH:${ALTERAPATH}/hls/bin/ export LD_LIBRARY_PATH=${ALTERAPATH}/hls/host/linux64/lib/ export PATH=$PATH:${ALTERAPATH}/nios2eds/ export PATH=$PATH:${ALTERAPATH}/nios2eds/sdk2/bin/ export SOCEDS_DEST_ROOT=${ALTERAPATH}/embedded export SOCEDS_HWLIB=${ALTERAPATH}/embedded/ip/altera/hps/altera_hps/hwlib/ export GCC_Linaro=/home/corsi/work/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf/bin export PATH=$PATH:${GCC_Linaro}","title":"Criando um atalho no bash"},{"location":"Tutorial-HPS-Buildroot/","text":"Tutorial 8 - HPS -Buildroot \u00b6 Buildroot wikipidia Buildroot is a set of Makefiles and patches that simplifies and automates the process of building a complete and bootable Linux environment for an embedded system, while using cross-compilation to allow building for multiple target platforms on a single Linux-based development system. Buildroot can automatically build the required cross-compilation toolchain, create a root file system, compile a Linux kernel image, and generate a boot loader for the targeted embedded system, or it can perform any independent combination of these steps. For example, an already installed cross-compilation toolchain can be used independently, while Buildroot only creates the root file system ref: https://en.wikipedia.org/wiki/Buildroot Iremos utilizar o buildroot para gerar o filesystem ( /bin , /etc , ...) do nosso sistema embarcado. No buildroot teremos a op\u00e7\u00e3o de configurar quais softwares queremos no dispositivo. Por exemplo, se desejarmos acessar o HPS via ssh, teremos que no buildroot adicionar um ssh server para ser compilado e adicionado ao filesystem e executado no boot. O buildroot \u00e9 uma alternativa a outro projeto bem conhecido: Yocto. O v\u00eddeo a seguir s\u00e3o dois desenvolvedores, um de cada projeto, fazendo a compara\u00e7\u00e3o entre as duas ferramentas: Note O Yocto est\u00e1 se consolidando como ferramenta padr\u00e3o da industria, tomando o lugar do buildroot. A escolha pelo buildroot na eletiva \u00e9 pela facilidade de criar um sistema, o yocto \u00e9 mais complexo e cheio de terminologias. Nessa eletiva iremos trabalhar com o buildroot, mas para quem quer se aprofundar/especializar no tema, tem que aprender o yocto. buildroot \u00b6 Leitura recomendada https://buildroot.org/downloads/manual/manual.html#_getting_started Download \u00b6 Primeiramente devemos fazer o download do buildroot : $ git clone https://github.com/buildroot/buildroot $ cd buildroot/ O buildroot possui uma ferramenta de configura\u00e7\u00e3o similar ao do kernel do linux ( menuconfig / nconfig ) iremos utilizar-la para configurar o filesystem assim como quais programas ser\u00e3o compilados e inseridos no /root/ . Lembre que j\u00e1 possu\u00edmos um toolchain (o que compilamos o kernel) configurado no .bashrc , iremos o utilizar para a compila\u00e7\u00e3o de todos os programas que iremos carregar no embarcado. O buildroot tem a op\u00e7\u00e3o de fazer o download do toolchain (ele tamb\u00e9m pode compilar o kernel e gerar o uboot, \u00e9 uma ferramenta bem completa), mas dessa vez iremos utilizar o que j\u00e1 temos (para manter a compatibilidade). Configurando \u00b6 Na pasta do buildroot rec\u00e9m clonada, execute o seguinte comando: $ make ARCH = arm menuconfig Tip Se ser algum erro, talvez seja necess\u00e1rio instalar o libncurses-dev via apt. Ele ir\u00e1 abrir uma tela de configura\u00e7\u00e3o a seguir: para voltar para essa tela, basta aperta duas vezes a tecla <ESC> 1. Target Options \u00b6 A primeira parte que iremos configurar \u00e9 o alvo da gera\u00e7\u00e3o do filesystem ( Target options ), devemos informar para o buildroot que ele est\u00e1 gerando arquivos para um ARM e indicar algumas op\u00e7\u00f5es do nosso compilador. Para isso: Config. final Menu principal Target Options Target Architecture: ARM (little endian) Essa op\u00e7\u00e3o j\u00e1 deve estar certa pois passamos via a chamada do make (make ARCH=ARM ...) Target Architecture Variant: cortex-A9 Enable NEON SIMD extension support Enable VFP extension support Floating point strategy: NEON https://developer.arm.com/technologies/neon Target ABI: EABIhf Indicamos ao buildroot que nossa arquitetura possui ponto flutuante em HW. 2. Build options \u00b6 Config. Final Deixe padr\u00e3o como o padr\u00e3o. 3. Toolchain \u00b6 config. Final Vamos indicar agora para o buildroot qual toolchain que ele deve utilizar e suas configura\u00e7\u00f5es: Menu principal Toolchain Toolchain type: External toolchain o buildroot ir\u00e1 usar o toolchain que especificarmos. Note que dentro dessa op\u00e7\u00e3o existe a : Buildroot toolchain , que se ativada faria com que o buildroot baixasse de forma autom\u00e1tica todo o toolchain. Toolchain: Custom toolchain Toolchain path: $(ARM_GCC) o buildroot ir\u00e1 usar essa vari\u00e1vel do sistema como path do toolchain. Temos duas op\u00e7\u00f5es aqui : Podemos declarar essa vari\u00e1vel no bash Podemos editar essa op\u00e7\u00e3o j\u00e1 com o path do nosso toolchain Vamos escolher por hora a op\u00e7\u00e3o 1. Toolchain prefix: $(ARCH)-linux-gnueabihf o prefix \u00e9 como o toolchain ir\u00e1 ser chamado, por exemplo para acessar o gcc: $(ARM_GCC)/bin/$(ARCH)-linux-gnueabihf-gcc Sendo : ARM_GCC = /home/corsi/work/gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabihf ARCH = arm (passado no call do make) Resulta em: /home/corsi/work/gcc-linaro-7.1-2017.11-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-gcc Toolchain gcc version: 7.x Toolchain kernel headers series: 4.10.x External toolchain C library: glibc/eglibc Ativar : Toolchain has SSP support Ativar : Toolchain has SSP support Ativar : Toolchain has RCP support Ativar : Toolchain has C++ support 4. System Configuration \u00b6 config. Final Nessa etapa vamos configurar informa\u00e7\u00f5es como: hostname, user, password gerenciador de inicializa\u00e7\u00e3o (init)... Menu principal System Configuration System hostname: SoC-Corsi (escolha o que preferir) System banner: Embarcados Avancados!! SoC Cyclone V Init system: BusyBox systemd \u00e9 uma alternativa, s\u00f3 que mais complexa! Root password: 1234 (escolha o que preferir) /bin/sh: busybox O shell a ser inserido no sistema, temos v\u00e1rias outras op\u00e7\u00f5es: bash, zsh. Todas elas ir\u00e3o aumentar o tamanho e a complexidade da imagem. 5. Kernel / bootloader \u00b6 O busybox pode baixar e compilar o kernel e o uboot para n\u00f3s. Nonte N\u00e3o vamos usar essa configura\u00e7\u00e3o. Deixe n\u00e3o checado! Menu principal Kernel 6. Target packages \u00b6 Nesse menu temos a op\u00e7\u00e3o de quais programas e sistemas ser\u00e3o inseridos na imagem para o target. Se quisermos por exemplo inserir um webserver (apache ?) no nosso linux embarcado, devemos selecionar aqui. Vamos deixar como padr\u00e3o por hora. Mais tarde iremos voltar a essa etapa mais tarde. 7. Filesystem images \u00b6 Menu principal Filesystem images Selecionar: tar the root filesystem Esse menu descreve para o busybox como deve ser a sa\u00edda final da imagem do filesystem gerada. O busybox necessita gerar filesystem que \u00e9 capaz de configurar as permiss\u00f5es dos arquivos corretamente (ele n\u00e3o pode simplesmente gerar uma pasta com todos os arquivos e programas). 8. Finalizando \u00b6 Salve a sua configura\u00e7\u00e3o (ESC ESC save) e volte ao terminal. Vamos agora gerar a imagem do nosso filesystem. Compilando \u00b6 Para compilar e gerar o filesystem : $ make ARCH = arm all -j 4 Nessa etapa o buildroot ir\u00e1 baixar da web todos os pacotes e programas que foram selecionados no menu de configura\u00e7\u00e3o, e ir\u00e1 compilar o source code com o toolchain que passamos para ele. Isso pode levar um tempinho . Gr\u00e1ficos ! \u00b6 Uma vez acabado o processo de gera\u00e7\u00e3o do FS, podemos gerar alguns gr\u00e1ficos muito importantes: https://buildroot.org/downloads/manual/manual.html#_graphing_the_filesystem_size_contribution_of_packages Depend\u00eancia dos pacotes: make graph-depends Tempo de compila\u00e7\u00e3o: make graph-build Contribui\u00e7\u00e3o do tamanho do FS de cada pacote: make graph-size Os gr\u00e1ficos s\u00e3o salvos na pasta: output/graphs/ Tip Instale as depend\u00eancias sudo apt install graphviz python-matplotlib python-numpy Gere os tr\u00eas gr\u00e1ficos e analise os resultados Exemplo do gr\u00e1fico do tamanho dos pacotes no fs: Outputs \u00b6 Existem duas sa\u00eddas do buildroot na pasta: buildroot/output/** O arquivo ./images/rootfs.tar : que cont\u00e9m o fileSystem do target (com as permiss\u00f5es corretas) A pasta ./images/target/ : com os arquivos contidos no .tar mas sem as permiss\u00f5es corretas para executar no target. Inclusive essa pasta possui um arquivo: Warning THIS_IS_NOT_YOUR_ROOT_FILESYSTEM Warning! This directory does not contain the root filesystem that you can use on your embedded system. Since Buildroot does not run as root, it cannot create device files and set the permissions and ownership of files correctly in this directory to make it usable as a root filesystem. .... Para testarmos no nosso sistema embarcados, temos que extrair o arquivo rootfs.tar para o nosso cart\u00e3o de mem\u00f3ria. Testando \u00b6 Siga o tutorial em SDCard - FileSystem . L\u00e1 est\u00e1 comentando como extrair o rootfs.tar para o nosso cart\u00e3o de mem\u00f3ria. o boot ficou mais r\u00e1pido? Tente plugar um pendrive, funciona? Estudando \u00b6 Responda: descreva o que \u00e9 o root file system initd process para que serve e como funciona o /linuxrc para que serve o /proc Refer\u00eancias \u00b6 dtb : https://rocketboards.org/foswiki/Documentation/HOWTOCreateADeviceTree Generating and Compiling the Preloader : https://rocketboards.org/foswiki/Documentation/GSRD141Preloader Compilando o kernel : https://rocketboards.org/foswiki/Documentation/EmbeddedLinuxBeginnerSGuide#8","title":"Tutorial 8 - HPS -Buildroot"},{"location":"Tutorial-HPS-Buildroot/#tutorial-8-hps-buildroot","text":"Buildroot wikipidia Buildroot is a set of Makefiles and patches that simplifies and automates the process of building a complete and bootable Linux environment for an embedded system, while using cross-compilation to allow building for multiple target platforms on a single Linux-based development system. Buildroot can automatically build the required cross-compilation toolchain, create a root file system, compile a Linux kernel image, and generate a boot loader for the targeted embedded system, or it can perform any independent combination of these steps. For example, an already installed cross-compilation toolchain can be used independently, while Buildroot only creates the root file system ref: https://en.wikipedia.org/wiki/Buildroot Iremos utilizar o buildroot para gerar o filesystem ( /bin , /etc , ...) do nosso sistema embarcado. No buildroot teremos a op\u00e7\u00e3o de configurar quais softwares queremos no dispositivo. Por exemplo, se desejarmos acessar o HPS via ssh, teremos que no buildroot adicionar um ssh server para ser compilado e adicionado ao filesystem e executado no boot. O buildroot \u00e9 uma alternativa a outro projeto bem conhecido: Yocto. O v\u00eddeo a seguir s\u00e3o dois desenvolvedores, um de cada projeto, fazendo a compara\u00e7\u00e3o entre as duas ferramentas: Note O Yocto est\u00e1 se consolidando como ferramenta padr\u00e3o da industria, tomando o lugar do buildroot. A escolha pelo buildroot na eletiva \u00e9 pela facilidade de criar um sistema, o yocto \u00e9 mais complexo e cheio de terminologias. Nessa eletiva iremos trabalhar com o buildroot, mas para quem quer se aprofundar/especializar no tema, tem que aprender o yocto.","title":"Tutorial 8 - HPS -Buildroot"},{"location":"Tutorial-HPS-Buildroot/#buildroot","text":"Leitura recomendada https://buildroot.org/downloads/manual/manual.html#_getting_started","title":"buildroot"},{"location":"Tutorial-HPS-Buildroot/#download","text":"Primeiramente devemos fazer o download do buildroot : $ git clone https://github.com/buildroot/buildroot $ cd buildroot/ O buildroot possui uma ferramenta de configura\u00e7\u00e3o similar ao do kernel do linux ( menuconfig / nconfig ) iremos utilizar-la para configurar o filesystem assim como quais programas ser\u00e3o compilados e inseridos no /root/ . Lembre que j\u00e1 possu\u00edmos um toolchain (o que compilamos o kernel) configurado no .bashrc , iremos o utilizar para a compila\u00e7\u00e3o de todos os programas que iremos carregar no embarcado. O buildroot tem a op\u00e7\u00e3o de fazer o download do toolchain (ele tamb\u00e9m pode compilar o kernel e gerar o uboot, \u00e9 uma ferramenta bem completa), mas dessa vez iremos utilizar o que j\u00e1 temos (para manter a compatibilidade).","title":"Download"},{"location":"Tutorial-HPS-Buildroot/#configurando","text":"Na pasta do buildroot rec\u00e9m clonada, execute o seguinte comando: $ make ARCH = arm menuconfig Tip Se ser algum erro, talvez seja necess\u00e1rio instalar o libncurses-dev via apt. Ele ir\u00e1 abrir uma tela de configura\u00e7\u00e3o a seguir: para voltar para essa tela, basta aperta duas vezes a tecla <ESC>","title":"Configurando"},{"location":"Tutorial-HPS-Buildroot/#1-target-options","text":"A primeira parte que iremos configurar \u00e9 o alvo da gera\u00e7\u00e3o do filesystem ( Target options ), devemos informar para o buildroot que ele est\u00e1 gerando arquivos para um ARM e indicar algumas op\u00e7\u00f5es do nosso compilador. Para isso: Config. final Menu principal Target Options Target Architecture: ARM (little endian) Essa op\u00e7\u00e3o j\u00e1 deve estar certa pois passamos via a chamada do make (make ARCH=ARM ...) Target Architecture Variant: cortex-A9 Enable NEON SIMD extension support Enable VFP extension support Floating point strategy: NEON https://developer.arm.com/technologies/neon Target ABI: EABIhf Indicamos ao buildroot que nossa arquitetura possui ponto flutuante em HW.","title":"1. Target Options"},{"location":"Tutorial-HPS-Buildroot/#2-build-options","text":"Config. Final Deixe padr\u00e3o como o padr\u00e3o.","title":"2. Build options"},{"location":"Tutorial-HPS-Buildroot/#3-toolchain","text":"config. Final Vamos indicar agora para o buildroot qual toolchain que ele deve utilizar e suas configura\u00e7\u00f5es: Menu principal Toolchain Toolchain type: External toolchain o buildroot ir\u00e1 usar o toolchain que especificarmos. Note que dentro dessa op\u00e7\u00e3o existe a : Buildroot toolchain , que se ativada faria com que o buildroot baixasse de forma autom\u00e1tica todo o toolchain. Toolchain: Custom toolchain Toolchain path: $(ARM_GCC) o buildroot ir\u00e1 usar essa vari\u00e1vel do sistema como path do toolchain. Temos duas op\u00e7\u00f5es aqui : Podemos declarar essa vari\u00e1vel no bash Podemos editar essa op\u00e7\u00e3o j\u00e1 com o path do nosso toolchain Vamos escolher por hora a op\u00e7\u00e3o 1. Toolchain prefix: $(ARCH)-linux-gnueabihf o prefix \u00e9 como o toolchain ir\u00e1 ser chamado, por exemplo para acessar o gcc: $(ARM_GCC)/bin/$(ARCH)-linux-gnueabihf-gcc Sendo : ARM_GCC = /home/corsi/work/gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabihf ARCH = arm (passado no call do make) Resulta em: /home/corsi/work/gcc-linaro-7.1-2017.11-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-gcc Toolchain gcc version: 7.x Toolchain kernel headers series: 4.10.x External toolchain C library: glibc/eglibc Ativar : Toolchain has SSP support Ativar : Toolchain has SSP support Ativar : Toolchain has RCP support Ativar : Toolchain has C++ support","title":"3. Toolchain"},{"location":"Tutorial-HPS-Buildroot/#4-system-configuration","text":"config. Final Nessa etapa vamos configurar informa\u00e7\u00f5es como: hostname, user, password gerenciador de inicializa\u00e7\u00e3o (init)... Menu principal System Configuration System hostname: SoC-Corsi (escolha o que preferir) System banner: Embarcados Avancados!! SoC Cyclone V Init system: BusyBox systemd \u00e9 uma alternativa, s\u00f3 que mais complexa! Root password: 1234 (escolha o que preferir) /bin/sh: busybox O shell a ser inserido no sistema, temos v\u00e1rias outras op\u00e7\u00f5es: bash, zsh. Todas elas ir\u00e3o aumentar o tamanho e a complexidade da imagem.","title":"4. System Configuration"},{"location":"Tutorial-HPS-Buildroot/#5-kernel-bootloader","text":"O busybox pode baixar e compilar o kernel e o uboot para n\u00f3s. Nonte N\u00e3o vamos usar essa configura\u00e7\u00e3o. Deixe n\u00e3o checado! Menu principal Kernel","title":"5. Kernel / bootloader"},{"location":"Tutorial-HPS-Buildroot/#6-target-packages","text":"Nesse menu temos a op\u00e7\u00e3o de quais programas e sistemas ser\u00e3o inseridos na imagem para o target. Se quisermos por exemplo inserir um webserver (apache ?) no nosso linux embarcado, devemos selecionar aqui. Vamos deixar como padr\u00e3o por hora. Mais tarde iremos voltar a essa etapa mais tarde.","title":"6. Target packages"},{"location":"Tutorial-HPS-Buildroot/#7-filesystem-images","text":"Menu principal Filesystem images Selecionar: tar the root filesystem Esse menu descreve para o busybox como deve ser a sa\u00edda final da imagem do filesystem gerada. O busybox necessita gerar filesystem que \u00e9 capaz de configurar as permiss\u00f5es dos arquivos corretamente (ele n\u00e3o pode simplesmente gerar uma pasta com todos os arquivos e programas).","title":"7. Filesystem images"},{"location":"Tutorial-HPS-Buildroot/#8-finalizando","text":"Salve a sua configura\u00e7\u00e3o (ESC ESC save) e volte ao terminal. Vamos agora gerar a imagem do nosso filesystem.","title":"8. Finalizando"},{"location":"Tutorial-HPS-Buildroot/#compilando","text":"Para compilar e gerar o filesystem : $ make ARCH = arm all -j 4 Nessa etapa o buildroot ir\u00e1 baixar da web todos os pacotes e programas que foram selecionados no menu de configura\u00e7\u00e3o, e ir\u00e1 compilar o source code com o toolchain que passamos para ele. Isso pode levar um tempinho .","title":"Compilando"},{"location":"Tutorial-HPS-Buildroot/#graficos","text":"Uma vez acabado o processo de gera\u00e7\u00e3o do FS, podemos gerar alguns gr\u00e1ficos muito importantes: https://buildroot.org/downloads/manual/manual.html#_graphing_the_filesystem_size_contribution_of_packages Depend\u00eancia dos pacotes: make graph-depends Tempo de compila\u00e7\u00e3o: make graph-build Contribui\u00e7\u00e3o do tamanho do FS de cada pacote: make graph-size Os gr\u00e1ficos s\u00e3o salvos na pasta: output/graphs/ Tip Instale as depend\u00eancias sudo apt install graphviz python-matplotlib python-numpy Gere os tr\u00eas gr\u00e1ficos e analise os resultados Exemplo do gr\u00e1fico do tamanho dos pacotes no fs:","title":"Gr\u00e1ficos !"},{"location":"Tutorial-HPS-Buildroot/#outputs","text":"Existem duas sa\u00eddas do buildroot na pasta: buildroot/output/** O arquivo ./images/rootfs.tar : que cont\u00e9m o fileSystem do target (com as permiss\u00f5es corretas) A pasta ./images/target/ : com os arquivos contidos no .tar mas sem as permiss\u00f5es corretas para executar no target. Inclusive essa pasta possui um arquivo: Warning THIS_IS_NOT_YOUR_ROOT_FILESYSTEM Warning! This directory does not contain the root filesystem that you can use on your embedded system. Since Buildroot does not run as root, it cannot create device files and set the permissions and ownership of files correctly in this directory to make it usable as a root filesystem. .... Para testarmos no nosso sistema embarcados, temos que extrair o arquivo rootfs.tar para o nosso cart\u00e3o de mem\u00f3ria.","title":"Outputs"},{"location":"Tutorial-HPS-Buildroot/#testando","text":"Siga o tutorial em SDCard - FileSystem . L\u00e1 est\u00e1 comentando como extrair o rootfs.tar para o nosso cart\u00e3o de mem\u00f3ria. o boot ficou mais r\u00e1pido? Tente plugar um pendrive, funciona?","title":"Testando"},{"location":"Tutorial-HPS-Buildroot/#estudando","text":"Responda: descreva o que \u00e9 o root file system initd process para que serve e como funciona o /linuxrc para que serve o /proc","title":"Estudando"},{"location":"Tutorial-HPS-Buildroot/#referencias","text":"dtb : https://rocketboards.org/foswiki/Documentation/HOWTOCreateADeviceTree Generating and Compiling the Preloader : https://rocketboards.org/foswiki/Documentation/GSRD141Preloader Compilando o kernel : https://rocketboards.org/foswiki/Documentation/EmbeddedLinuxBeginnerSGuide#8","title":"Refer\u00eancias"},{"location":"Tutorial-HPS-DeviceDriver1/","text":"Device Driver \u00b6 Iremos nesse tutorial desenvolver um device driver para o kernel do linux, esse device ir\u00e1 abstrair o controle do LED e o acesso a chave SW do kit de desenvolvimento. Kernel \u00b6 O Linux \u00e9 um kernel monolitico , onde todo c\u00f3digo referente ao sistema operacional acontece no kernel space. O kernel do Linux \u00e9 respons\u00e1vel, dentre outras coisas, por: gerenciar processos e tar\u00e9fas scheduling virtualiza\u00e7\u00e3o, controle de grupos/ usu\u00e1rios gerenciamento de mem\u00f3ria/ pagina\u00e7\u00e3o comunica\u00e7\u00e3o inter-processos entrada/sa\u00edda gerenciamento de arquivos device drivers abstra\u00e7\u00e3o de hardware Mapa da arquitetura interna do kernel do linux Microkernel O microkernel \u00e9 uma alternativa ao kernel monolitico, nessa arquitetura o kernel implementa o m\u00ednimo necess\u00e1rio. GNU O kernel do linux faz uso de diversos softwares criados e dispon\u00edveis pela comunidade GNU (como o gcc, gdb, make, e muitos outros por isso \u00e9 muitas vezes conhecido como GNU/Linux. Userspace vs Kernel Space \u00b6 Grande parte dessa sec\u00e7\u00e3o foi traduzida de https://www.ctrlinux.com/blog/?p=40 Userspace \u00e9 uma regi\u00e3o de mem\u00f3ria virtual onde todos os programas do usu\u00e1rio s\u00e3o executados. Os programas que fazem parte do userspace s\u00e3o executados em um modo de opera\u00e7\u00e3o da CPU chamado de unprivileged , onde nem todas instru\u00e7\u00f5es e registradores est\u00e3o dispon\u00edveis. O ARM suporta um total de 7 modos de execu\u00e7\u00e3o, sendo que apenas o usermode \u00e9 n\u00e3o privilegiado: User mode \u2013 All user level applications run in this mode. FIQ Fast Interrupt Mode \u2013 Used to handle interrupts classified as \u201cfast\u201d, get in and get out type of interrupts. IRQ Mode \u2013 Used to handle device interrupts and non FIQ interrupts. Supervisor mode (default CPU boot mode). Used by the OS and software interrupts (SWIs). Abort \u2013 Used to handle violations caused by erroneous memory accesses Undefined \u2013 Used to handle undefined instructions System \u2013 A privileged mode with the same register set as usermode, used to run exceptions handlers. Material retirado de: https://www.ctrlinux.com/blog/?p=40 userspace \u00b6 Para entender melhor o userspace, vamos imaginar o que acontece quando um programa tenta acessar uma regi\u00e3o de mem\u00f3ria que pertence a ao kernel (modo privilegiado). Quando criamos um ponteiro e acessamos uma mem\u00f3ria, esse comando \u00e9 traduzindo para uma instru\u00e7\u00e3o do tipo LOAD em assembly. A instru\u00e7\u00e3o LOAD entra no pipeline da CPU e no est\u00e1gio de execu\u00e7\u00e3o a CPU passa o endere\u00e7o da instru\u00e7\u00e3o para o hardware respons\u00e1vel por gerenciar a mem\u00f3ria: Memory Management Unit (MMU). O MMU traduz o endere\u00e7o de mem\u00f3ria virtual para o endere\u00e7o f\u00edsico (pagina de mem\u00f3ria), nesse ponto o MMU verifica o modo de execu\u00e7\u00e3o atual da CPU e se a regi\u00e3o de mem\u00f3ria pode ser acessada pelo modo atual. No nosso caso a CPU ir\u00e1 mudar o modo do processador para Abort e tratar o acesso ao endere\u00e7o de mem\u00f3ria n\u00e3o autorizado, causando o encerramento do programa com seg fault . Programas no userspace se comunicam com o kernel via chamadas de sistema 1 ( system calls ), essas chamadas viram interrup\u00e7\u00f5es de software que ser\u00e3o processadas pelo kernel. Kernel Space \u00b6 As vantagens de trabalhar com o kernel space s\u00e3o: Poder manipular diretamente os perif\u00e9ricos do hardware, poder tratar interrup\u00e7\u00f5es de hw. Com grandes poderes v\u00eam grandes responsabilidades, erros nesse modo podem causar kernel panic e travar todo o sistema. Kernel Module / Device driver \u00b6 https://lwn.net/Kernel/LDD3/ Um m\u00f3dulo do kernel \u00e9 um c\u00f3digo compilado que pode ser lincado com o kernel em tempo de execu\u00e7\u00e3o (como alterar a asa de um avi\u00e3o em movimento), um m\u00f3dulo pode ser um driver de dispositivo, mas n\u00e3o necessariamente. Device driver \u00b6 Refer\u00eancias: https://linux-kernel-labs.github.io/refs/heads/master/ https://tldp.org/LDP/tlk/dd/drivers.html https://www.kernel.org/doc/html/v4.11/driver-api/index.html linux/Documentation/driver-model/* Drivers de dispositivos s\u00e3o respons\u00e1veis por implementar a parte de baixo n\u00edvel de configura\u00e7\u00e3o, comunica\u00e7\u00e3o e gerenciamento do hardware (perif\u00e9ricos, mem\u00f3ria, CPU). No reposit\u00f3rio do kernel do Linux, os drivers est\u00e3o localizados em: linux/drivers/ e est\u00e3o organizados por categoria: accessibility dca ide mfd pnp spmi acpi devfreq idle misc power ssb amba dio iio mmc powercap staging android dma infiniband modules.builtin pps target ata dma-buf input mtd ps3 tc atm edac iommu net ptp thermal auxdisplay eisa ipack nfc pwm thunderbolt base extcon irqchip ntb rapidio tty bcma firewire isdn nubus ras uio block firmware Kconfig nvdimm regulator usb bluetooth fmc leds nvme remoteproc uwb built-in.a fpga lguest nvmem reset vfio built-in.o gpio lightnvm of rpmsg vhost bus gpu macintosh oprofile rtc video cdrom hid mailbox parisc s390 virt char hsi Makefile parport sbus virtio clk hv mcb pci scsi vlynq clocksource hwmon md pcmcia sfi vme connector hwspinlock media perf sh w1 cpufreq hwtracing memory phy sn watchdog cpuidle i2c memstick pinctrl soc xen crypto i3c message platform spi zorro No linux os drivers podem ser desenvolvidos/classificados em basicamente tr\u00eas tipos : char module , block module , network module . character device : \u00c9 usado no caso que o driver pode ser acessado com um strem de bytes (como um arquivo). Deve implementar no m\u00ednimo as seguintes chamadas de sistema: open/close/read/write . O /dev/console e /dev/tty s\u00e3o exemplos desse tipo de device. Uma diferen\u00e7a entre um arquivo e um char dev \u00e9 que no arquivo voc\u00ea pode mover o ponteiro para frente e para traz, mas nesse tipo de device n\u00e3o, voc\u00ea s\u00f3 pode ir para frente. block device : Usado para implementar acesso a disco f\u00edsico, esse tipo de driver opera com blocos de bytes (normalmente 512 bytes). network device : Utilizado para implementar uma interface de rede (como o loopback/ wlan0/ ... ). Essa interface \u00e9 capaz de receber e enviar pacotes de dados, controlado pelo sistema de rede do kernel. Device Tree (dts) \u00b6 Info Isso acontece apenas em sistemas embarcados. Para saber como o Kernel do linux sabe quais s\u00e3o os dispositivos dispon\u00edveis acesse: https://unix.stackexchange.com/questions/399619/why-do-embedded-systems-need-device-tree-while-pcs-dont Como o kernel do linux sabe quais s\u00e3o os dispositivos e drivers associados a eles? Um arquivo de configura\u00e7\u00e3o chamado de device tree \u00e9 passado pelo boot para o kernel do Linux indicando os perif\u00e9ricos, e quais s\u00e3o os drivers associados a eles. u-boot \u00b6 A programa\u00e7\u00e3o da FPGA \u00e9 realizada pelo u-boot, antes da inicializa\u00e7\u00e3o do Kernel do Linux. No nosso caso, o u-boot foi pr\u00e9 configurado para ler o arquivo soc_system.rbf que est\u00e1 na parti\u00e7\u00e3o do SDCARD junto com o kernel ( zImage ). Explica\u00e7\u00e3o do processo de boot - at\u00e9 1:50 minutos O u-boot antes de inicializar o kernel do Linux, busca esse arquivo na parti\u00e7\u00e3o do SDCARD, o extra\u00ed e programa \"magicamente\" a FPGA. Nessa mesma parti\u00e7\u00e3o temos mais dois arquivos: u-boot.scr e socfpga.dtb . O primeiro \u00e9 um script de inicializa\u00e7\u00e3o do boot na qual o u-boot l\u00ea para saber quais passos ele deve executar (se precisa carregar a fpga, onde est\u00e1 o kernel, ..., s\u00e3o os passos de inicializa\u00e7\u00e3o), j\u00e1 o socfpga.dtb \u00e9 o device tree do Linux , o dtb \u00e9 um bin\u00e1rio, que foi criado a partir de outro arquivo, o .dts , e ele cont\u00e9m informa\u00e7\u00f5es sobre o hardware que \u00e9 passado para o kernel no momento de inicializa\u00e7\u00e3o. Device Tree for Dummies! - Thomas Petazzoni, Free Electrons dtb (dts compilado) \u00b6 O dtb \u00e9 utilizado como ferramenta para indicar ao kernel quais s\u00e3o as configura\u00e7\u00f5es de hardware dispon\u00edveis, voc\u00ea n\u00e3o precisa recompilar o kernel caso o endere\u00e7o de mem\u00f3ria de algum perif\u00e9rico muder, basta informar no dts . Essa ferramenta \u00e9 muito importante para sistemas embarcados, na qual, cada hardware possui sua especificidade. O dtb \u00e9 gerado a partir de arquivo texto no formato dts que \u00e9 ent\u00e3o gerado pelas informa\u00e7\u00f5es de hardware extra\u00edda do Platform Designer que s\u00e3o salvas no arquivo: .sopcinfo , o mesmo arquivo que \u00e9 utilizado pelo Eclipse-NIOS para gerar o BSP nos tutoriais passados. O BSP no Linux \u00e9 chamado de dts e possui um formato padr\u00e3o que deve ser seguido! entendendo o dts \u00b6 ref: https://developer.toradex.com/device-tree-customization O come\u00e7o do nosso .dts tem a defini\u00e7\u00e3o das CPUs que est\u00e3o dispon\u00edveis no CHIP: cpus { #address-cells = < 1 > ; #size-cells = < 0 > ; enable-method = \"altr,socfpga-smp\" ; /* appended from boardinfo */ hps_0_arm_a9_0 : cpu @ 0x0 { device_type = \"cpu\" ; compatible = \"arm,cortex-a9-16.1\" , \"arm,cortex-a9\" ; reg = < 0x00000000 > ; next-level-cache = <& hps_0_L2 > ; /* appended from boardinfo */ }; //end cpu@0x0 (hps_0_arm_a9_0) hps_0_arm_a9_1 : cpu @ 0x1 { device_type = \"cpu\" ; compatible = \"arm,cortex-a9-16.1\" , \"arm,cortex-a9\" ; reg = < 0x00000001 > ; next-level-cache = <& hps_0_L2 > ; /* appended from boardinfo */ }; //end cpu@0x1 (hps_0_arm_a9_1) }; //end cpus Vamos ver em mais detalhes o hps_0_uart0 do nosso dts : hps_0_uart0 : serial @ 0xffc02000 { compatible = \"snps,dw-apb-uart-16.1\" , \"snps,dw-apb-uart\" ; reg = < 0xffc02000 0x00000100 > ; interrupt-parent = <& hps_0_arm_gic_0 > ; interrupts = < 0 162 4 > ; clocks = <& l4_sp_clk > ; reg - io-width = < 4 > ; /* embeddedsw.dts.params.reg-io-width type NUMBER */ reg - shift = < 2 > ; /* embeddedsw.dts.params.reg-shift type NUMBER */ status = \"okay\" ; /* embeddedsw.dts.params.status type STRING */ }; //end serial@0xffc02000 (hps_0_uart0) }; //end serial@0x100020000 (jtag_uart) Ele indica que no nosso hardware, temos um componente serial no endere\u00e7o 0xffc02000 que \u00e9 compat\u00edvel com os drivers: snps,dw-apb-uart-16.1 e.ou snps,dw-apb-uart , que \u00e9 implementado no Driver: 8250 no kernel do Linux: https://github.com/torvalds/linux/blob/master/drivers/tty/serial/8250/8250_dw.c . E esse driver est\u00e1 configurado como ativo no nosso kernel: E \u00e9 por conta disso que conseguimos acessar o kit com USB (screen). Par\u00e2metro CONFIG_SERIAL_8250_CONSOLE CONFIG_SERIAL_8250_CONSOLE: \u2502 \u2502 \u2502 \u2502 If you say Y here, it will be possible to use a serial port as the \u2502 \u2502 system console (the system console is the device which receives all \u2502 \u2502 kernel messages and warnings and which allows logins in single user \u2502 \u2502 mode). This could be useful if some terminal or printer is connected \u2502 \u2502 to that serial port. \u2502 \u2502 \u2502 \u2502 Even if you say Y here, the currently visible virtual console \u2502 \u2502 (/dev/tty0) will still be used as the system console by default, but \u2502 \u2502 you can alter that using a kernel command line option such as \u2502 \u2502 \"console=ttyS1\". (Try \"man bootparam\" or see the documentation of \u2502 \u2502 your boot loader (grub or lilo or loadlin) about how to pass options \u2502 \u2502 to the kernel at boot time.) \u2502 \u2502 \u2502 \u2502 If you don't have a VGA card installed and you say Y here, the \u2502 \u2502 kernel will automatically use the first serial line, /dev/ttyS0, as \u2502 \u2502 system console. \u2502 \u2502 \u2502 \u2502 You can set that using a kernel command line option such as \u2502 \u2502 \"console=uart8250,io,0x3f8,9600n8\" \u2502 \u2502 \"console=uart8250,mmio,0xff5e0000,115200n8\". \u2502 \u2502 and it will switch to normal serial console when the corresponding \u2502 \u2502 port is ready. \u2502 \u2502 \"earlycon=uart8250,io,0x3f8,9600n8\" \u2502 \u2502 \"earlycon=uart8250,mmio,0xff5e0000,115200n8\". \u2502 \u2502 it will not only setup early console. \u2502 \u2502 \u2502 \u2502 If unsure, say N. \u2502 \u2502 \u2502 \u2502 Symbol: SERIAL_8250_CONSOLE [=y] \u2502 \u2502 Type : boolean \u2502 \u2502 Prompt: Console on 8250/16550 and compatible serial port \u2502 Location: \u2502 \u2502 -> Device Drivers \u2502 \u2502 -> Character devices \u2502 \u2502 -> Serial drivers \u2502 \u2502 -> 8250/16550 and compatible serial support (SERIAL_8250 [=y]) \u2502 \u2502 Defined at drivers/tty/serial/8250/Kconfig:60 \u2502 \u2502 Depends on: TTY [=y] && HAS_IOMEM [=y] && SERIAL_8250 [=y]=y \u2502 \u2502 Selects: SERIAL_CORE_CONSOLE [=y] && SERIAL_EARLYCON [=y] \u2502 \u2502 Para mais informa\u00e7\u00f5es sobre o dts : https://elinux.org/Device_Tree_Usage https://elinux.org/Device_Tree_Reference https://developer.toradex.com/device-tree-customization#Device_Tree_Anatomy https://bootlin.com/pub/conferences/2014/elc/petazzoni-device-tree-dummies/petazzoni-device-tree-dummies.pdf http://www.linux.it/~rubini/docs/ksys/ \u21a9","title":"Device Driver"},{"location":"Tutorial-HPS-DeviceDriver1/#device-driver","text":"Iremos nesse tutorial desenvolver um device driver para o kernel do linux, esse device ir\u00e1 abstrair o controle do LED e o acesso a chave SW do kit de desenvolvimento.","title":"Device Driver"},{"location":"Tutorial-HPS-DeviceDriver1/#kernel","text":"O Linux \u00e9 um kernel monolitico , onde todo c\u00f3digo referente ao sistema operacional acontece no kernel space. O kernel do Linux \u00e9 respons\u00e1vel, dentre outras coisas, por: gerenciar processos e tar\u00e9fas scheduling virtualiza\u00e7\u00e3o, controle de grupos/ usu\u00e1rios gerenciamento de mem\u00f3ria/ pagina\u00e7\u00e3o comunica\u00e7\u00e3o inter-processos entrada/sa\u00edda gerenciamento de arquivos device drivers abstra\u00e7\u00e3o de hardware Mapa da arquitetura interna do kernel do linux Microkernel O microkernel \u00e9 uma alternativa ao kernel monolitico, nessa arquitetura o kernel implementa o m\u00ednimo necess\u00e1rio. GNU O kernel do linux faz uso de diversos softwares criados e dispon\u00edveis pela comunidade GNU (como o gcc, gdb, make, e muitos outros por isso \u00e9 muitas vezes conhecido como GNU/Linux.","title":"Kernel"},{"location":"Tutorial-HPS-DeviceDriver1/#userspace-vs-kernel-space","text":"Grande parte dessa sec\u00e7\u00e3o foi traduzida de https://www.ctrlinux.com/blog/?p=40 Userspace \u00e9 uma regi\u00e3o de mem\u00f3ria virtual onde todos os programas do usu\u00e1rio s\u00e3o executados. Os programas que fazem parte do userspace s\u00e3o executados em um modo de opera\u00e7\u00e3o da CPU chamado de unprivileged , onde nem todas instru\u00e7\u00f5es e registradores est\u00e3o dispon\u00edveis. O ARM suporta um total de 7 modos de execu\u00e7\u00e3o, sendo que apenas o usermode \u00e9 n\u00e3o privilegiado: User mode \u2013 All user level applications run in this mode. FIQ Fast Interrupt Mode \u2013 Used to handle interrupts classified as \u201cfast\u201d, get in and get out type of interrupts. IRQ Mode \u2013 Used to handle device interrupts and non FIQ interrupts. Supervisor mode (default CPU boot mode). Used by the OS and software interrupts (SWIs). Abort \u2013 Used to handle violations caused by erroneous memory accesses Undefined \u2013 Used to handle undefined instructions System \u2013 A privileged mode with the same register set as usermode, used to run exceptions handlers. Material retirado de: https://www.ctrlinux.com/blog/?p=40","title":"Userspace vs Kernel Space"},{"location":"Tutorial-HPS-DeviceDriver1/#userspace","text":"Para entender melhor o userspace, vamos imaginar o que acontece quando um programa tenta acessar uma regi\u00e3o de mem\u00f3ria que pertence a ao kernel (modo privilegiado). Quando criamos um ponteiro e acessamos uma mem\u00f3ria, esse comando \u00e9 traduzindo para uma instru\u00e7\u00e3o do tipo LOAD em assembly. A instru\u00e7\u00e3o LOAD entra no pipeline da CPU e no est\u00e1gio de execu\u00e7\u00e3o a CPU passa o endere\u00e7o da instru\u00e7\u00e3o para o hardware respons\u00e1vel por gerenciar a mem\u00f3ria: Memory Management Unit (MMU). O MMU traduz o endere\u00e7o de mem\u00f3ria virtual para o endere\u00e7o f\u00edsico (pagina de mem\u00f3ria), nesse ponto o MMU verifica o modo de execu\u00e7\u00e3o atual da CPU e se a regi\u00e3o de mem\u00f3ria pode ser acessada pelo modo atual. No nosso caso a CPU ir\u00e1 mudar o modo do processador para Abort e tratar o acesso ao endere\u00e7o de mem\u00f3ria n\u00e3o autorizado, causando o encerramento do programa com seg fault . Programas no userspace se comunicam com o kernel via chamadas de sistema 1 ( system calls ), essas chamadas viram interrup\u00e7\u00f5es de software que ser\u00e3o processadas pelo kernel.","title":"userspace"},{"location":"Tutorial-HPS-DeviceDriver1/#kernel-space","text":"As vantagens de trabalhar com o kernel space s\u00e3o: Poder manipular diretamente os perif\u00e9ricos do hardware, poder tratar interrup\u00e7\u00f5es de hw. Com grandes poderes v\u00eam grandes responsabilidades, erros nesse modo podem causar kernel panic e travar todo o sistema.","title":"Kernel Space"},{"location":"Tutorial-HPS-DeviceDriver1/#kernel-module-device-driver","text":"https://lwn.net/Kernel/LDD3/ Um m\u00f3dulo do kernel \u00e9 um c\u00f3digo compilado que pode ser lincado com o kernel em tempo de execu\u00e7\u00e3o (como alterar a asa de um avi\u00e3o em movimento), um m\u00f3dulo pode ser um driver de dispositivo, mas n\u00e3o necessariamente.","title":"Kernel Module / Device driver"},{"location":"Tutorial-HPS-DeviceDriver1/#device-driver_1","text":"Refer\u00eancias: https://linux-kernel-labs.github.io/refs/heads/master/ https://tldp.org/LDP/tlk/dd/drivers.html https://www.kernel.org/doc/html/v4.11/driver-api/index.html linux/Documentation/driver-model/* Drivers de dispositivos s\u00e3o respons\u00e1veis por implementar a parte de baixo n\u00edvel de configura\u00e7\u00e3o, comunica\u00e7\u00e3o e gerenciamento do hardware (perif\u00e9ricos, mem\u00f3ria, CPU). No reposit\u00f3rio do kernel do Linux, os drivers est\u00e3o localizados em: linux/drivers/ e est\u00e3o organizados por categoria: accessibility dca ide mfd pnp spmi acpi devfreq idle misc power ssb amba dio iio mmc powercap staging android dma infiniband modules.builtin pps target ata dma-buf input mtd ps3 tc atm edac iommu net ptp thermal auxdisplay eisa ipack nfc pwm thunderbolt base extcon irqchip ntb rapidio tty bcma firewire isdn nubus ras uio block firmware Kconfig nvdimm regulator usb bluetooth fmc leds nvme remoteproc uwb built-in.a fpga lguest nvmem reset vfio built-in.o gpio lightnvm of rpmsg vhost bus gpu macintosh oprofile rtc video cdrom hid mailbox parisc s390 virt char hsi Makefile parport sbus virtio clk hv mcb pci scsi vlynq clocksource hwmon md pcmcia sfi vme connector hwspinlock media perf sh w1 cpufreq hwtracing memory phy sn watchdog cpuidle i2c memstick pinctrl soc xen crypto i3c message platform spi zorro No linux os drivers podem ser desenvolvidos/classificados em basicamente tr\u00eas tipos : char module , block module , network module . character device : \u00c9 usado no caso que o driver pode ser acessado com um strem de bytes (como um arquivo). Deve implementar no m\u00ednimo as seguintes chamadas de sistema: open/close/read/write . O /dev/console e /dev/tty s\u00e3o exemplos desse tipo de device. Uma diferen\u00e7a entre um arquivo e um char dev \u00e9 que no arquivo voc\u00ea pode mover o ponteiro para frente e para traz, mas nesse tipo de device n\u00e3o, voc\u00ea s\u00f3 pode ir para frente. block device : Usado para implementar acesso a disco f\u00edsico, esse tipo de driver opera com blocos de bytes (normalmente 512 bytes). network device : Utilizado para implementar uma interface de rede (como o loopback/ wlan0/ ... ). Essa interface \u00e9 capaz de receber e enviar pacotes de dados, controlado pelo sistema de rede do kernel.","title":"Device driver"},{"location":"Tutorial-HPS-DeviceDriver1/#device-tree-dts","text":"Info Isso acontece apenas em sistemas embarcados. Para saber como o Kernel do linux sabe quais s\u00e3o os dispositivos dispon\u00edveis acesse: https://unix.stackexchange.com/questions/399619/why-do-embedded-systems-need-device-tree-while-pcs-dont Como o kernel do linux sabe quais s\u00e3o os dispositivos e drivers associados a eles? Um arquivo de configura\u00e7\u00e3o chamado de device tree \u00e9 passado pelo boot para o kernel do Linux indicando os perif\u00e9ricos, e quais s\u00e3o os drivers associados a eles.","title":"Device Tree (dts)"},{"location":"Tutorial-HPS-DeviceDriver1/#u-boot","text":"A programa\u00e7\u00e3o da FPGA \u00e9 realizada pelo u-boot, antes da inicializa\u00e7\u00e3o do Kernel do Linux. No nosso caso, o u-boot foi pr\u00e9 configurado para ler o arquivo soc_system.rbf que est\u00e1 na parti\u00e7\u00e3o do SDCARD junto com o kernel ( zImage ). Explica\u00e7\u00e3o do processo de boot - at\u00e9 1:50 minutos O u-boot antes de inicializar o kernel do Linux, busca esse arquivo na parti\u00e7\u00e3o do SDCARD, o extra\u00ed e programa \"magicamente\" a FPGA. Nessa mesma parti\u00e7\u00e3o temos mais dois arquivos: u-boot.scr e socfpga.dtb . O primeiro \u00e9 um script de inicializa\u00e7\u00e3o do boot na qual o u-boot l\u00ea para saber quais passos ele deve executar (se precisa carregar a fpga, onde est\u00e1 o kernel, ..., s\u00e3o os passos de inicializa\u00e7\u00e3o), j\u00e1 o socfpga.dtb \u00e9 o device tree do Linux , o dtb \u00e9 um bin\u00e1rio, que foi criado a partir de outro arquivo, o .dts , e ele cont\u00e9m informa\u00e7\u00f5es sobre o hardware que \u00e9 passado para o kernel no momento de inicializa\u00e7\u00e3o. Device Tree for Dummies! - Thomas Petazzoni, Free Electrons","title":"u-boot"},{"location":"Tutorial-HPS-DeviceDriver1/#dtb-dts-compilado","text":"O dtb \u00e9 utilizado como ferramenta para indicar ao kernel quais s\u00e3o as configura\u00e7\u00f5es de hardware dispon\u00edveis, voc\u00ea n\u00e3o precisa recompilar o kernel caso o endere\u00e7o de mem\u00f3ria de algum perif\u00e9rico muder, basta informar no dts . Essa ferramenta \u00e9 muito importante para sistemas embarcados, na qual, cada hardware possui sua especificidade. O dtb \u00e9 gerado a partir de arquivo texto no formato dts que \u00e9 ent\u00e3o gerado pelas informa\u00e7\u00f5es de hardware extra\u00edda do Platform Designer que s\u00e3o salvas no arquivo: .sopcinfo , o mesmo arquivo que \u00e9 utilizado pelo Eclipse-NIOS para gerar o BSP nos tutoriais passados. O BSP no Linux \u00e9 chamado de dts e possui um formato padr\u00e3o que deve ser seguido!","title":"dtb (dts compilado)"},{"location":"Tutorial-HPS-DeviceDriver1/#entendendo-o-dts","text":"ref: https://developer.toradex.com/device-tree-customization O come\u00e7o do nosso .dts tem a defini\u00e7\u00e3o das CPUs que est\u00e3o dispon\u00edveis no CHIP: cpus { #address-cells = < 1 > ; #size-cells = < 0 > ; enable-method = \"altr,socfpga-smp\" ; /* appended from boardinfo */ hps_0_arm_a9_0 : cpu @ 0x0 { device_type = \"cpu\" ; compatible = \"arm,cortex-a9-16.1\" , \"arm,cortex-a9\" ; reg = < 0x00000000 > ; next-level-cache = <& hps_0_L2 > ; /* appended from boardinfo */ }; //end cpu@0x0 (hps_0_arm_a9_0) hps_0_arm_a9_1 : cpu @ 0x1 { device_type = \"cpu\" ; compatible = \"arm,cortex-a9-16.1\" , \"arm,cortex-a9\" ; reg = < 0x00000001 > ; next-level-cache = <& hps_0_L2 > ; /* appended from boardinfo */ }; //end cpu@0x1 (hps_0_arm_a9_1) }; //end cpus Vamos ver em mais detalhes o hps_0_uart0 do nosso dts : hps_0_uart0 : serial @ 0xffc02000 { compatible = \"snps,dw-apb-uart-16.1\" , \"snps,dw-apb-uart\" ; reg = < 0xffc02000 0x00000100 > ; interrupt-parent = <& hps_0_arm_gic_0 > ; interrupts = < 0 162 4 > ; clocks = <& l4_sp_clk > ; reg - io-width = < 4 > ; /* embeddedsw.dts.params.reg-io-width type NUMBER */ reg - shift = < 2 > ; /* embeddedsw.dts.params.reg-shift type NUMBER */ status = \"okay\" ; /* embeddedsw.dts.params.status type STRING */ }; //end serial@0xffc02000 (hps_0_uart0) }; //end serial@0x100020000 (jtag_uart) Ele indica que no nosso hardware, temos um componente serial no endere\u00e7o 0xffc02000 que \u00e9 compat\u00edvel com os drivers: snps,dw-apb-uart-16.1 e.ou snps,dw-apb-uart , que \u00e9 implementado no Driver: 8250 no kernel do Linux: https://github.com/torvalds/linux/blob/master/drivers/tty/serial/8250/8250_dw.c . E esse driver est\u00e1 configurado como ativo no nosso kernel: E \u00e9 por conta disso que conseguimos acessar o kit com USB (screen). Par\u00e2metro CONFIG_SERIAL_8250_CONSOLE CONFIG_SERIAL_8250_CONSOLE: \u2502 \u2502 \u2502 \u2502 If you say Y here, it will be possible to use a serial port as the \u2502 \u2502 system console (the system console is the device which receives all \u2502 \u2502 kernel messages and warnings and which allows logins in single user \u2502 \u2502 mode). This could be useful if some terminal or printer is connected \u2502 \u2502 to that serial port. \u2502 \u2502 \u2502 \u2502 Even if you say Y here, the currently visible virtual console \u2502 \u2502 (/dev/tty0) will still be used as the system console by default, but \u2502 \u2502 you can alter that using a kernel command line option such as \u2502 \u2502 \"console=ttyS1\". (Try \"man bootparam\" or see the documentation of \u2502 \u2502 your boot loader (grub or lilo or loadlin) about how to pass options \u2502 \u2502 to the kernel at boot time.) \u2502 \u2502 \u2502 \u2502 If you don't have a VGA card installed and you say Y here, the \u2502 \u2502 kernel will automatically use the first serial line, /dev/ttyS0, as \u2502 \u2502 system console. \u2502 \u2502 \u2502 \u2502 You can set that using a kernel command line option such as \u2502 \u2502 \"console=uart8250,io,0x3f8,9600n8\" \u2502 \u2502 \"console=uart8250,mmio,0xff5e0000,115200n8\". \u2502 \u2502 and it will switch to normal serial console when the corresponding \u2502 \u2502 port is ready. \u2502 \u2502 \"earlycon=uart8250,io,0x3f8,9600n8\" \u2502 \u2502 \"earlycon=uart8250,mmio,0xff5e0000,115200n8\". \u2502 \u2502 it will not only setup early console. \u2502 \u2502 \u2502 \u2502 If unsure, say N. \u2502 \u2502 \u2502 \u2502 Symbol: SERIAL_8250_CONSOLE [=y] \u2502 \u2502 Type : boolean \u2502 \u2502 Prompt: Console on 8250/16550 and compatible serial port \u2502 Location: \u2502 \u2502 -> Device Drivers \u2502 \u2502 -> Character devices \u2502 \u2502 -> Serial drivers \u2502 \u2502 -> 8250/16550 and compatible serial support (SERIAL_8250 [=y]) \u2502 \u2502 Defined at drivers/tty/serial/8250/Kconfig:60 \u2502 \u2502 Depends on: TTY [=y] && HAS_IOMEM [=y] && SERIAL_8250 [=y]=y \u2502 \u2502 Selects: SERIAL_CORE_CONSOLE [=y] && SERIAL_EARLYCON [=y] \u2502 \u2502 Para mais informa\u00e7\u00f5es sobre o dts : https://elinux.org/Device_Tree_Usage https://elinux.org/Device_Tree_Reference https://developer.toradex.com/device-tree-customization#Device_Tree_Anatomy https://bootlin.com/pub/conferences/2014/elc/petazzoni-device-tree-dummies/petazzoni-device-tree-dummies.pdf http://www.linux.it/~rubini/docs/ksys/ \u21a9","title":"entendendo o dts"},{"location":"Tutorial-HPS-FPGA-BlinkLED/","text":"Tutorial - HPS + FPGA - Blink LED \u00b6 Nesse tutorial vamos ver como interfacear o ARM com a FPGA (fabric). Nesse tutorial, optei por deixar voc\u00eas seguirem o tutorial oficial da Terasic: Examples for using both HPS SoC and FGPA [cap\u00edtulo 7], que se encontra no manual do usu\u00e1rio, no CD do kit. Note Retomar a essa p\u00e1gina quando acabar o tutorial da Terasic, ele n\u00e3o cobre tudo. https://github.com/Insper/DE10-Standard-v.1.3.0-SystemCD/tree/master/Manual Execute Copie o bin\u00e1rio compilado no tutorial HPS_FPGA_LED para o SDCard Entendendo o HW \u00b6 Muito importante voc\u00ea parar e refletir o que aconteceu, para isso segue algumas perguntas: Quais s\u00e3o as interfaces ente o ARM e a FPGA? (s\u00e3o 4 no total) Qual a diferen\u00e7a entre elas? Como o HPS aparece no Platform Designer (PD)? Voc\u00ea abriu as configura\u00e7\u00f5es do HPS no PD? O que pode ser configurado? Como essa interface \u00e9 utilizada no Platform Designer? Porque no projeto ele utilizou um clock bridge? Parte 2 \u00b6 Esse tutorial n\u00e3o \u00e9 completo, ele pula uma coisa muito importante: Como programar a FPGA automaticamente para quando o Linux inicializar, o hardware j\u00e1 estar programando para poder executar o programa HPS_FPGA_LED . Como o Kernel do linux sabe em qual hardware ele est\u00e1 sendo executado? (Possui v\u00eddeo? Ethernet? ...) A programa\u00e7\u00e3o da FPGA \u00e9 realizada pelo u-boot, antes da inicializa\u00e7\u00e3o do Kernel do Linux. No nosso caso, o u-boot foi pr\u00e9 configurado para ler o arquivo soc_system.rbf que est\u00e1 na parti\u00e7\u00e3o do SDCARD junto com o kernel ( zImage ). Explica\u00e7\u00e3o do processo de boot - at\u00e9 1:50 minutos O u-boot antes de inicializar o kernel do Linux, busca esse arquivo na parti\u00e7\u00e3o do SDCARD, o extra\u00ed e programa \"magicamente\" a FPGA. Nessa mesma parti\u00e7\u00e3o temos mais dois arquivos: u-boot.scr e socfpga.dtb . O primeiro \u00e9 um script de inicializa\u00e7\u00e3o do boot na qual o u-boot l\u00ea para saber quais passos ele deve executar (se precisa carregar a fpga, onde est\u00e1 o kernel, ..., s\u00e3o os passos de inicializa\u00e7\u00e3o), j\u00e1 o socfpga.dtb \u00e9 o device tree do Linux , o dtb \u00e9 um bin\u00e1rio, que foi criado a partir de outro arquivo, o .dts , e ele cont\u00e9m informa\u00e7\u00f5es sobre o hardware que \u00e9 passado para o kernel no momento de inicializa\u00e7\u00e3o. Device Tree for Dummies! - Thomas Petazzoni, Free Electrons Gerando o .rbf (imagem da FPGA) \u00b6 O rbf \u00e9 o arquivo .sof gerado pelo Quartus na compila\u00e7\u00e3o s\u00f3 que comprimido e com algumas modifica\u00e7\u00f5es. Para gerar o arquivo .rbf a partir do .sof basta executarmos na pasta output_files : Note Voc\u00ea deve executar esse comando na pasta output_files do seu projeto Quartus! $ cd output_files $ quartus_cpf -c DE10_Standard_FB.sof -o bitstream_compression = on soc_system.rbf Note note que o arquivo gerado pelo Quartus chama DE10_Standard_FB.sof , voc\u00ea deve editar para o seu caso. Com o arquivo soc_system.rbf criado, \u00e9 s\u00f3 copiarmos ele para o SDCARD, substituindo o anterior. Execute Gere o soc_system.rbf do projeto (COMPILAR O QUARTUS!) Grave o novo rbf no SDCard (mesma parti\u00e7\u00e3o do kernel) dtb (informa\u00e7\u00f5es de hardware para o Kernel) \u00b6 O dtb \u00e9 utilizado como ferramenta para indicar ao kernel quais s\u00e3o as configura\u00e7\u00f5es de hardware dispon\u00edveis, voc\u00ea n\u00e3o precisa recompilar o kernel caso o endere\u00e7o de mem\u00f3ria de algum perif\u00e9rico mudar, basta informar no dts . Essa ferramenta \u00e9 muito importante para sistemas embarcados, na qual, cada hardware possui sua especificidade. O dtb \u00e9 gerado a partir de arquivo texto no formato dts que \u00e9 ent\u00e3o gerado pelas informa\u00e7\u00f5es de hardware extra\u00edda do Platform Designer que s\u00e3o salvas no arquivo: .sopcinfo , o mesmo arquivo que \u00e9 utilizado pelo Eclipse-NIOS para gerar o BSP nos tutoriais passados. O BSP no Linux \u00e9 chamado de dts e possui um formato padr\u00e3o que deve ser seguido! Ser\u00e1 necess\u00e1rio seguir os passos a seguir: Gere o .sopcinfo (platform designer) ( j\u00e1 est\u00e1 pronto, n\u00e3o precisa mexer ) Gere o dts Compile o dts para dtb Gerando o dts \u00b6 Eu consegui esse comando via trocado com engenheiros da Terasic, os exemplos que encontrava nos tutorias da internet n\u00e3o funcionavam. Note Para funcionar \u00e9 necess\u00e1rio realizar o comando via o shell do oembedded Execute os seguintes comandos: $ # Devemos executar os comandos dentro do shell do embedded (quartus) $ embedded_command_shell.sh $ sopc2dts --input soc_system.sopcinfo --output soc_system.dts --type dts --board soc_system_board_info.xml --board hps_common_board_info.xml --bridge-removal all --clocks Note Voc\u00ea deve executar esse comando na pasta raiz do seu projeto Quartus! Agora com o .dts gerado, vamos dar uma olhada em seu conte\u00fado e como o interpretar. O dts possui a anatomia a seguir: ref: https://developer.toradex.com/device-tree-customization O come\u00e7o do nosso .dts tem a defini\u00e7\u00e3o das CPUs que est\u00e3o dispon\u00edveis no CHIP: cpus { #address-cells = < 1 > ; #size-cells = < 0 > ; enable-method = \"altr,socfpga-smp\" ; /* appended from boardinfo */ hps_0_arm_a9_0 : cpu @ 0x0 { device_type = \"cpu\" ; compatible = \"arm,cortex-a9-16.1\" , \"arm,cortex-a9\" ; reg = < 0x00000000 > ; next-level-cache = <& hps_0_L2 > ; /* appended from boardinfo */ }; //end cpu@0x0 (hps_0_arm_a9_0) hps_0_arm_a9_1 : cpu @ 0x1 { device_type = \"cpu\" ; compatible = \"arm,cortex-a9-16.1\" , \"arm,cortex-a9\" ; reg = < 0x00000001 > ; next-level-cache = <& hps_0_L2 > ; /* appended from boardinfo */ }; //end cpu@0x1 (hps_0_arm_a9_1) }; //end cpus Vamos ver em mais detalhes o hps_0_uart0 do nosso dts : hps_0_uart0 : serial @ 0xffc02000 { compatible = \"snps,dw-apb-uart-16.1\" , \"snps,dw-apb-uart\" ; reg = < 0xffc02000 0x00000100 > ; interrupt-parent = <& hps_0_arm_gic_0 > ; interrupts = < 0 162 4 > ; clocks = <& l4_sp_clk > ; reg - io-width = < 4 > ; /* embeddedsw.dts.params.reg-io-width type NUMBER */ reg - shift = < 2 > ; /* embeddedsw.dts.params.reg-shift type NUMBER */ status = \"okay\" ; /* embeddedsw.dts.params.status type STRING */ }; //end serial@0xffc02000 (hps_0_uart0) }; //end serial@0x100020000 (jtag_uart) Ele indica que no nosso hardware, temos um componente serial no endere\u00e7o 0xffc02000 que \u00e9 compat\u00edvel com os drivers: snps,dw-apb-uart-16.1 e.ou snps,dw-apb-uart , que \u00e9 implementado no Driver: 8250 no kernel do Linux: https://github.com/torvalds/linux/blob/master/drivers/tty/serial/8250/8250_dw.c . E esse driver est\u00e1 configurado como ativo no nosso kernel: E \u00e9 por conta disso que conseguimos acessar o kit com USB (screen). Par\u00e2metro CONFIG_SERIAL_8250_CONSOLE CONFIG_SERIAL_8250_CONSOLE: \u2502 \u2502 \u2502 \u2502 If you say Y here, it will be possible to use a serial port as the \u2502 \u2502 system console (the system console is the device which receives all \u2502 \u2502 kernel messages and warnings and which allows logins in single user \u2502 \u2502 mode). This could be useful if some terminal or printer is connected \u2502 \u2502 to that serial port. \u2502 \u2502 \u2502 \u2502 Even if you say Y here, the currently visible virtual console \u2502 \u2502 (/dev/tty0) will still be used as the system console by default, but \u2502 \u2502 you can alter that using a kernel command line option such as \u2502 \u2502 \"console=ttyS1\". (Try \"man bootparam\" or see the documentation of \u2502 \u2502 your boot loader (grub or lilo or loadlin) about how to pass options \u2502 \u2502 to the kernel at boot time.) \u2502 \u2502 \u2502 \u2502 If you don't have a VGA card installed and you say Y here, the \u2502 \u2502 kernel will automatically use the first serial line, /dev/ttyS0, as \u2502 \u2502 system console. \u2502 \u2502 \u2502 \u2502 You can set that using a kernel command line option such as \u2502 \u2502 \"console=uart8250,io,0x3f8,9600n8\" \u2502 \u2502 \"console=uart8250,mmio,0xff5e0000,115200n8\". \u2502 \u2502 and it will switch to normal serial console when the corresponding \u2502 \u2502 port is ready. \u2502 \u2502 \"earlycon=uart8250,io,0x3f8,9600n8\" \u2502 \u2502 \"earlycon=uart8250,mmio,0xff5e0000,115200n8\". \u2502 \u2502 it will not only setup early console. \u2502 \u2502 \u2502 \u2502 If unsure, say N. \u2502 \u2502 \u2502 \u2502 Symbol: SERIAL_8250_CONSOLE [=y] \u2502 \u2502 Type : boolean \u2502 \u2502 Prompt: Console on 8250/16550 and compatible serial port \u2502 Location: \u2502 \u2502 -> Device Drivers \u2502 \u2502 -> Character devices \u2502 \u2502 -> Serial drivers \u2502 \u2502 -> 8250/16550 and compatible serial support (SERIAL_8250 [=y]) \u2502 \u2502 Defined at drivers/tty/serial/8250/Kconfig:60 \u2502 \u2502 Depends on: TTY [=y] && HAS_IOMEM [=y] && SERIAL_8250 [=y]=y \u2502 \u2502 Selects: SERIAL_CORE_CONSOLE [=y] && SERIAL_EARLYCON [=y] \u2502 \u2502 Para mais informa\u00e7\u00f5es sobre o dts : https://elinux.org/Device_Tree_Usage https://elinux.org/Device_Tree_Reference https://developer.toradex.com/device-tree-customization#Device_Tree_Anatomy https://bootlin.com/pub/conferences/2014/elc/petazzoni-device-tree-dummies/petazzoni-device-tree-dummies.pdf Gerando o dtb \u00b6 Execute os seguintes comandos (ainda dentro do embedded shell) $ dtc -I dts -O dtb -o soc_system.dtb soc_system.dts $ #Agora voc\u00ea pode sair do embedded shell: $ exit Execute Gere o soc_system.dtb do projeto Grave o novo soc_system.dtb no SDCard (mesma parti\u00e7\u00e3o do kernel) Testando \u00b6 Agora plugue o SDcard no kit de desenvolvimento, e ap\u00f3s inicializa\u00e7\u00e3o do kernel execute o programa blink led e veja os LEDs da FPGA piscarem! Interessante n\u00e9? Agora vamos fazer algo mais \u00fatil com isso..","title":"Tutorial - HPS + FPGA - Blink LED"},{"location":"Tutorial-HPS-FPGA-BlinkLED/#tutorial-hps-fpga-blink-led","text":"Nesse tutorial vamos ver como interfacear o ARM com a FPGA (fabric). Nesse tutorial, optei por deixar voc\u00eas seguirem o tutorial oficial da Terasic: Examples for using both HPS SoC and FGPA [cap\u00edtulo 7], que se encontra no manual do usu\u00e1rio, no CD do kit. Note Retomar a essa p\u00e1gina quando acabar o tutorial da Terasic, ele n\u00e3o cobre tudo. https://github.com/Insper/DE10-Standard-v.1.3.0-SystemCD/tree/master/Manual Execute Copie o bin\u00e1rio compilado no tutorial HPS_FPGA_LED para o SDCard","title":"Tutorial - HPS + FPGA - Blink LED"},{"location":"Tutorial-HPS-FPGA-BlinkLED/#entendendo-o-hw","text":"Muito importante voc\u00ea parar e refletir o que aconteceu, para isso segue algumas perguntas: Quais s\u00e3o as interfaces ente o ARM e a FPGA? (s\u00e3o 4 no total) Qual a diferen\u00e7a entre elas? Como o HPS aparece no Platform Designer (PD)? Voc\u00ea abriu as configura\u00e7\u00f5es do HPS no PD? O que pode ser configurado? Como essa interface \u00e9 utilizada no Platform Designer? Porque no projeto ele utilizou um clock bridge?","title":"Entendendo o HW"},{"location":"Tutorial-HPS-FPGA-BlinkLED/#parte-2","text":"Esse tutorial n\u00e3o \u00e9 completo, ele pula uma coisa muito importante: Como programar a FPGA automaticamente para quando o Linux inicializar, o hardware j\u00e1 estar programando para poder executar o programa HPS_FPGA_LED . Como o Kernel do linux sabe em qual hardware ele est\u00e1 sendo executado? (Possui v\u00eddeo? Ethernet? ...) A programa\u00e7\u00e3o da FPGA \u00e9 realizada pelo u-boot, antes da inicializa\u00e7\u00e3o do Kernel do Linux. No nosso caso, o u-boot foi pr\u00e9 configurado para ler o arquivo soc_system.rbf que est\u00e1 na parti\u00e7\u00e3o do SDCARD junto com o kernel ( zImage ). Explica\u00e7\u00e3o do processo de boot - at\u00e9 1:50 minutos O u-boot antes de inicializar o kernel do Linux, busca esse arquivo na parti\u00e7\u00e3o do SDCARD, o extra\u00ed e programa \"magicamente\" a FPGA. Nessa mesma parti\u00e7\u00e3o temos mais dois arquivos: u-boot.scr e socfpga.dtb . O primeiro \u00e9 um script de inicializa\u00e7\u00e3o do boot na qual o u-boot l\u00ea para saber quais passos ele deve executar (se precisa carregar a fpga, onde est\u00e1 o kernel, ..., s\u00e3o os passos de inicializa\u00e7\u00e3o), j\u00e1 o socfpga.dtb \u00e9 o device tree do Linux , o dtb \u00e9 um bin\u00e1rio, que foi criado a partir de outro arquivo, o .dts , e ele cont\u00e9m informa\u00e7\u00f5es sobre o hardware que \u00e9 passado para o kernel no momento de inicializa\u00e7\u00e3o. Device Tree for Dummies! - Thomas Petazzoni, Free Electrons","title":"Parte 2"},{"location":"Tutorial-HPS-FPGA-BlinkLED/#gerando-o-rbf-imagem-da-fpga","text":"O rbf \u00e9 o arquivo .sof gerado pelo Quartus na compila\u00e7\u00e3o s\u00f3 que comprimido e com algumas modifica\u00e7\u00f5es. Para gerar o arquivo .rbf a partir do .sof basta executarmos na pasta output_files : Note Voc\u00ea deve executar esse comando na pasta output_files do seu projeto Quartus! $ cd output_files $ quartus_cpf -c DE10_Standard_FB.sof -o bitstream_compression = on soc_system.rbf Note note que o arquivo gerado pelo Quartus chama DE10_Standard_FB.sof , voc\u00ea deve editar para o seu caso. Com o arquivo soc_system.rbf criado, \u00e9 s\u00f3 copiarmos ele para o SDCARD, substituindo o anterior. Execute Gere o soc_system.rbf do projeto (COMPILAR O QUARTUS!) Grave o novo rbf no SDCard (mesma parti\u00e7\u00e3o do kernel)","title":"Gerando o .rbf (imagem da FPGA)"},{"location":"Tutorial-HPS-FPGA-BlinkLED/#dtb-informacoes-de-hardware-para-o-kernel","text":"O dtb \u00e9 utilizado como ferramenta para indicar ao kernel quais s\u00e3o as configura\u00e7\u00f5es de hardware dispon\u00edveis, voc\u00ea n\u00e3o precisa recompilar o kernel caso o endere\u00e7o de mem\u00f3ria de algum perif\u00e9rico mudar, basta informar no dts . Essa ferramenta \u00e9 muito importante para sistemas embarcados, na qual, cada hardware possui sua especificidade. O dtb \u00e9 gerado a partir de arquivo texto no formato dts que \u00e9 ent\u00e3o gerado pelas informa\u00e7\u00f5es de hardware extra\u00edda do Platform Designer que s\u00e3o salvas no arquivo: .sopcinfo , o mesmo arquivo que \u00e9 utilizado pelo Eclipse-NIOS para gerar o BSP nos tutoriais passados. O BSP no Linux \u00e9 chamado de dts e possui um formato padr\u00e3o que deve ser seguido! Ser\u00e1 necess\u00e1rio seguir os passos a seguir: Gere o .sopcinfo (platform designer) ( j\u00e1 est\u00e1 pronto, n\u00e3o precisa mexer ) Gere o dts Compile o dts para dtb","title":"dtb (informa\u00e7\u00f5es de hardware para o Kernel)"},{"location":"Tutorial-HPS-FPGA-BlinkLED/#gerando-o-dts","text":"Eu consegui esse comando via trocado com engenheiros da Terasic, os exemplos que encontrava nos tutorias da internet n\u00e3o funcionavam. Note Para funcionar \u00e9 necess\u00e1rio realizar o comando via o shell do oembedded Execute os seguintes comandos: $ # Devemos executar os comandos dentro do shell do embedded (quartus) $ embedded_command_shell.sh $ sopc2dts --input soc_system.sopcinfo --output soc_system.dts --type dts --board soc_system_board_info.xml --board hps_common_board_info.xml --bridge-removal all --clocks Note Voc\u00ea deve executar esse comando na pasta raiz do seu projeto Quartus! Agora com o .dts gerado, vamos dar uma olhada em seu conte\u00fado e como o interpretar. O dts possui a anatomia a seguir: ref: https://developer.toradex.com/device-tree-customization O come\u00e7o do nosso .dts tem a defini\u00e7\u00e3o das CPUs que est\u00e3o dispon\u00edveis no CHIP: cpus { #address-cells = < 1 > ; #size-cells = < 0 > ; enable-method = \"altr,socfpga-smp\" ; /* appended from boardinfo */ hps_0_arm_a9_0 : cpu @ 0x0 { device_type = \"cpu\" ; compatible = \"arm,cortex-a9-16.1\" , \"arm,cortex-a9\" ; reg = < 0x00000000 > ; next-level-cache = <& hps_0_L2 > ; /* appended from boardinfo */ }; //end cpu@0x0 (hps_0_arm_a9_0) hps_0_arm_a9_1 : cpu @ 0x1 { device_type = \"cpu\" ; compatible = \"arm,cortex-a9-16.1\" , \"arm,cortex-a9\" ; reg = < 0x00000001 > ; next-level-cache = <& hps_0_L2 > ; /* appended from boardinfo */ }; //end cpu@0x1 (hps_0_arm_a9_1) }; //end cpus Vamos ver em mais detalhes o hps_0_uart0 do nosso dts : hps_0_uart0 : serial @ 0xffc02000 { compatible = \"snps,dw-apb-uart-16.1\" , \"snps,dw-apb-uart\" ; reg = < 0xffc02000 0x00000100 > ; interrupt-parent = <& hps_0_arm_gic_0 > ; interrupts = < 0 162 4 > ; clocks = <& l4_sp_clk > ; reg - io-width = < 4 > ; /* embeddedsw.dts.params.reg-io-width type NUMBER */ reg - shift = < 2 > ; /* embeddedsw.dts.params.reg-shift type NUMBER */ status = \"okay\" ; /* embeddedsw.dts.params.status type STRING */ }; //end serial@0xffc02000 (hps_0_uart0) }; //end serial@0x100020000 (jtag_uart) Ele indica que no nosso hardware, temos um componente serial no endere\u00e7o 0xffc02000 que \u00e9 compat\u00edvel com os drivers: snps,dw-apb-uart-16.1 e.ou snps,dw-apb-uart , que \u00e9 implementado no Driver: 8250 no kernel do Linux: https://github.com/torvalds/linux/blob/master/drivers/tty/serial/8250/8250_dw.c . E esse driver est\u00e1 configurado como ativo no nosso kernel: E \u00e9 por conta disso que conseguimos acessar o kit com USB (screen). Par\u00e2metro CONFIG_SERIAL_8250_CONSOLE CONFIG_SERIAL_8250_CONSOLE: \u2502 \u2502 \u2502 \u2502 If you say Y here, it will be possible to use a serial port as the \u2502 \u2502 system console (the system console is the device which receives all \u2502 \u2502 kernel messages and warnings and which allows logins in single user \u2502 \u2502 mode). This could be useful if some terminal or printer is connected \u2502 \u2502 to that serial port. \u2502 \u2502 \u2502 \u2502 Even if you say Y here, the currently visible virtual console \u2502 \u2502 (/dev/tty0) will still be used as the system console by default, but \u2502 \u2502 you can alter that using a kernel command line option such as \u2502 \u2502 \"console=ttyS1\". (Try \"man bootparam\" or see the documentation of \u2502 \u2502 your boot loader (grub or lilo or loadlin) about how to pass options \u2502 \u2502 to the kernel at boot time.) \u2502 \u2502 \u2502 \u2502 If you don't have a VGA card installed and you say Y here, the \u2502 \u2502 kernel will automatically use the first serial line, /dev/ttyS0, as \u2502 \u2502 system console. \u2502 \u2502 \u2502 \u2502 You can set that using a kernel command line option such as \u2502 \u2502 \"console=uart8250,io,0x3f8,9600n8\" \u2502 \u2502 \"console=uart8250,mmio,0xff5e0000,115200n8\". \u2502 \u2502 and it will switch to normal serial console when the corresponding \u2502 \u2502 port is ready. \u2502 \u2502 \"earlycon=uart8250,io,0x3f8,9600n8\" \u2502 \u2502 \"earlycon=uart8250,mmio,0xff5e0000,115200n8\". \u2502 \u2502 it will not only setup early console. \u2502 \u2502 \u2502 \u2502 If unsure, say N. \u2502 \u2502 \u2502 \u2502 Symbol: SERIAL_8250_CONSOLE [=y] \u2502 \u2502 Type : boolean \u2502 \u2502 Prompt: Console on 8250/16550 and compatible serial port \u2502 Location: \u2502 \u2502 -> Device Drivers \u2502 \u2502 -> Character devices \u2502 \u2502 -> Serial drivers \u2502 \u2502 -> 8250/16550 and compatible serial support (SERIAL_8250 [=y]) \u2502 \u2502 Defined at drivers/tty/serial/8250/Kconfig:60 \u2502 \u2502 Depends on: TTY [=y] && HAS_IOMEM [=y] && SERIAL_8250 [=y]=y \u2502 \u2502 Selects: SERIAL_CORE_CONSOLE [=y] && SERIAL_EARLYCON [=y] \u2502 \u2502 Para mais informa\u00e7\u00f5es sobre o dts : https://elinux.org/Device_Tree_Usage https://elinux.org/Device_Tree_Reference https://developer.toradex.com/device-tree-customization#Device_Tree_Anatomy https://bootlin.com/pub/conferences/2014/elc/petazzoni-device-tree-dummies/petazzoni-device-tree-dummies.pdf","title":"Gerando o dts"},{"location":"Tutorial-HPS-FPGA-BlinkLED/#gerando-o-dtb","text":"Execute os seguintes comandos (ainda dentro do embedded shell) $ dtc -I dts -O dtb -o soc_system.dtb soc_system.dts $ #Agora voc\u00ea pode sair do embedded shell: $ exit Execute Gere o soc_system.dtb do projeto Grave o novo soc_system.dtb no SDCard (mesma parti\u00e7\u00e3o do kernel)","title":"Gerando o dtb"},{"location":"Tutorial-HPS-FPGA-BlinkLED/#testando","text":"Agora plugue o SDcard no kit de desenvolvimento, e ap\u00f3s inicializa\u00e7\u00e3o do kernel execute o programa blink led e veja os LEDs da FPGA piscarem! Interessante n\u00e9? Agora vamos fazer algo mais \u00fatil com isso..","title":"Testando"},{"location":"Tutorial-HPS-FPGA-VGA/","text":"Tutorial - HPS + FPGA - VGA \u00b6 Se repararem em nosso hardware verificamos que o mesmo possui uma sa\u00edda de v\u00eddeo VGA, por\u00e9m os sinais do VGA foram conectados nos pinos da FPGA! Tornando necess\u00e1rio a cria\u00e7\u00e3o de um hardware e sua conex\u00e3o com o HPS para que possamos fazer com que nosso Linux tenha uma sa\u00edda de v\u00eddeo. Diagrama Para conseguirmos ter uma sa\u00edda de v\u00eddeo no nosso sistema embarcado, teremos que realizar os seguintes passos: Configurar um hw que gerencie VGA alt_vip_* pense que vamos adicionar na FPGA uma 'placa de v\u00eddeo' muito simples Adicionar ao kernel um device driver para gerenciar esse hardware Configurar o kernel adicionando a parte de FB compilar o kernel Configurar no buildroot um programa capaz de manipular o FB e exibir uma imagem Frame Buffer \u00b6 Antes de mexermos com o hardware, vamos ver como o Linux trata uma sa\u00edda de v\u00eddeo! Voc\u00ea j\u00e1 ouviu falar de frame buffer (FB)? Verifique que o seu PC possui um: $ ls /dev | grep fb O FB \u00e9 uma regi\u00e3o da mem\u00f3ria RAM reservada e que cont\u00e9m um bitmap (se tiver uma placa de v\u00eddeo, essa mem\u00f3ria pode estar localizada nela), esse bitmap \u00e9 convertido (por hardware ou software) para a sa\u00edda de v\u00eddeo em quest\u00e3o. Essa convers\u00e3o de bitmap para sa\u00edda de v\u00eddeo depende do driver de v\u00eddeo que foi carregado para gerenciar (e criar) o FB, no caso de placas de v\u00eddeo intel, \u00e9 utilizado o driver vesa . Por\u00e9m nem tudo que \u00e9 exibido passa diretamente pelo FB, alguns programas podem querer maior performance e podem acessar o display direto ( Direct Graphics Access ), como demonstrado no diagrama a seguir: Framebuffer Console O Linux possui um driver (fbcon) que exibe um console em um framebuffer, para usar, basta ativar na configura\u00e7\u00e3o do kernel: Device Drivers Graphics Support->Frame buffer Devices->Console display driver support Framebuffer Console Support Para mais detalhes: https://www.kernel.org/doc/html/latest/fb/fbcon.html Hardware \u00b6 Como no exemplo anterior (para ganhar tempo), vamos utilizar um hardware da Terasic que j\u00e1 possui a parte da FPGA configurada para trabalharmos com o VGA. Copie a pasta DE10-Standard-v.1.3.0-SystemCD/Demonstration/SoC_FPGA/DE10_Standard_FB/ para o seu reposit\u00f3rio. Com o projeto DE10_Standard_FB copiado, abra o projeto no quartus e analise o soc_system.qsys no Platform Designer, voc\u00ea deve ver algo como: Eu deixei a mostra somente as partes referentes ao v\u00eddeo! Entendo o HW \u00b6 O projeto de HW possui dois componentes para tratar o VGA: alt_vip_vfr_vga e alt_vip_itc_0 , ambos fazem parte do pacote de IPs: 'Video and Image Processing Suite Intel FPGA' espec\u00edfico para processamento de v\u00eddeo (j\u00e1 suporta 8K e +60Hz) Video and Image Process ( VIP ) Suite Intel FPGA Retirado do site da Intel: The Intel\u00ae FPGA Video and Image Processing Suite is a collection of Intel FPGA IP functions that you can use to facilitate the development of custom video and image processing (VIP) designs. These Intel FPGA IP functions are suitable for use in a wide variety of image processing and display applications, such as video surveillance, broadcast, video conferencing, and medical and military imaging. The Video and Image Processing Suite features cores that range from simple building block functions, such as color space conversion to sophisticated video scaling functions that can implement programmable polyphase scaling. All the VIP cores use an open, low-overhead Avalon\u00ae Streaming (Avalon-ST) interface standard so that they can be easily connected You can use VIP cores to quickly build a custom video processing signal chain using the Intel Quartus\u00ae Prime Lite or Standard Edition software and the associated Platform Designer You can mix and match VIP cores with your own proprietary intellectual property (IP) You can use the Platform Designer to automatically integrate embedded processors and peripherals and generate arbitration logic Capable of supporting 8K video at 60fps and above https://www.intel.com.br/content/www/br/pt/programmable/products/intellectual-property/ip/dsp/m-alt-vipsuite.html alt_vip_vfr_vga \u00b6 \u00c9 um perif\u00e9rico do tipo Frame Reader e \u00e9 respons\u00e1vel por fazer a leitura de um Frame Buffer alocado em mem\u00f3ria ( avalon_master ) e o transformar em um Streaming ( avalon_streaming ). A maioria dos IP do VIP operam no barramento de dados do tipo: avalon_streaming , por isso \u00e9 necess\u00e1rio fazer a leitura do FB (que est\u00e1 alocado na mem\u00f3ria DDR3, conectada ao ARM). Os dados da DDR3 s\u00e3o transferidos para o alt_vip_vfr_vga via DMA pelo ARM/Linux, inicializado pelo device driver carregado no Linux! alt_vip_itc \u00b6 \u00c9 um perif\u00e9rico de v\u00eddeo que faz a convers\u00e3o do streaming de pixels para a sa\u00edda de v\u00eddeo em quest\u00e3o (VGA). O VGA \u00e9 um formato de sa\u00edda de v\u00eddeo DIGITA que possui 5 sinais: HSYNC/ VSYNC/ R/G/B. HSYNC: indica o fim da linha VSYNC: indica o fim da tela R/G/B: s\u00e3o os valores dos pixels. Note O sinal VGA \u00e9 simples. que at\u00e9 da para gerar via arduino: - http://labdegaragem.com/profiles/blogs/gerando-sinal-vga-colorido-com-arduino-completo Compilando \u00b6 Agora que analisamos o HW, podemos compilar e utilizar no nosso SoC! Execute Gere o soc_system.dtb do projeto Grave o novo soc_system.dtb no SDCard (mesma parti\u00e7\u00e3o do kernel) Gere o soc_system.rbf do projeto (COMPILAR O QUARTUS!) Grave o novo rbf no SDCard (mesma parti\u00e7\u00e3o do kernel) Driver \u00b6 Ser\u00e1 necess\u00e1rio carregarmos um device driver no kernel do linux para que possamos utilizar essa sa\u00edda de v\u00eddeo rec\u00e9m criada. Por\u00e9m o driver do IP alt_vip_vfr_vga n\u00e3o \u00e9 oficial do kernel, vamos ter que adicionar manualmente! dts \u00b6 Mas como o linux sabe que existe uma sa\u00edda de v\u00eddeo? No nosso caso ser\u00e1 via o device tree (.dtb) que \u00e9 passado pelo u-boot na inicializa\u00e7\u00e3o do kernel, se repararmos no novo .dts gerado com o hardware, existe um novo componente chamado de alt_vip_vfr_vga , que \u00e9 compat\u00edvel com o driver vip-frame-reader-9.1 : alt_vip_vfr_vga : vip @ 0x100031000 { compatible = \"ALTR,vip-frame-reader-14.0\" , \"ALTR,vip-frame-reader-9.1\" ; reg = < 0x00000001 0x00031000 0x00000080 > ; clocks = <& clk_0 > ; max-width = < 1024 > ; /* MAX_IMAGE_WIDTH type NUMBER */ max-height = < 768 > ; /* MAX_IMAGE_HEIGHT type NUMBER */ bits-per-color = < 8 > ; /* BITS_PER_PIXEL_PER_COLOR_PLANE type NUMBER */ colors-per-beat = < 4 > ; /* NUMBER_OF_CHANNELS_IN_PARALLEL type NUMBER */ beats-per-pixel = < 1 > ; /* NUMBER_OF_CHANNELS_IN_SEQUENCE type NUMBER */ mem-word-width = < 128 > ; /* MEM_PORT_WIDTH type NUMBER */ }; //end vip@0x100031000 (alt_vip_vfr_vga) driver \u00b6 O driver vip-frame-reader-9.1 n\u00e3o \u00e9 oficial do linux, vamos ter que pegar uma implementa\u00e7\u00e3o realizada pelo o pessoal da Altera e utilizar. Os drivers no reposit\u00f3rio do Linux ficam na pasta: linux/drivers . No caso do v\u00eddeo/ framebuffer, em: linux/drivers/video/fbdev . Adicionando o driver altvipfb Siga o roteiro em: https://github.com/Insper/Embarcados-Avancados/blob/master/driver/altvipfb/README.md e depois volte para essa p\u00e1gina! Note Esse tutorial incluiu o driver do fb no kernel, outra op\u00e7\u00e3o seria criar um m\u00f3dulo (module) que poderia ser carregado conforme a necessidade. Testando Compile o kernel Copie o zImage novo para o SDCARD Liga um monitor a VGA Inicialize o linux embarcado Se tudo der certo, voc\u00ea deve ver dois pinguins no canto esquerdo do monitor. Cada pinguim representa um core do sistema, como nosso ARM \u00e9 um dual core, temos dois. Esse pinguins aparecem porque ativamos essa op\u00e7\u00e3o no kernel: CONFIG_LOGO=y CONFIG_LOGO_LINUX_MONO=y CONFIG_LOGO_LINUX_VGA16=y CONFIG_LOGO_LINUX_CLUT224=y Note \u00c9 poss\u00edvel editar o pinguim e fazer por exemplo, aparecer a carinha de voc\u00eas! Os arquivos ppm ficam na pasta /drivers/video/logo/ , esses s\u00e3o ent\u00e3o compilados na compila\u00e7\u00e3o do kernel. Quer fazer umas coisas legais com o FB? Tenta o seguinte: Exibir imagem rand\u00f4mica no FB: sudo cat /dev/urandom > /dev/fb0 ref: http://seenaburns.com/2018/04/04/writing-to-the-framebuffer/ Buildroot \u00b6 S\u00e3o diversas as solu\u00e7\u00f5es de desenvolvimento de interface gr\u00e1fica para Linux embarcado, e nem todas envolvem um gerenciador de janelas. A seguir uma lista de ferramentas que podem ser utilizadas: GUI: LittlevGL: https://littlevgl.com/ QT: https://www.qt.io/ emWin (comercial): https://www.segger.com/products/user-interface/emwin/ ... Existem outras solu\u00e7\u00f5es, vamos usar uma delas para exibir uma imagem na nossa tela! Quando eu estava fazendo esse roteiro, queria algo mais simples, em uma busca (n\u00e3o muito r\u00e1pida) na internet (keyword: linux frame buffer show image ) eu encontrei esse programa: fbv , que por sorte est\u00e1 no buildroot . fbv OVERVIEW fbv (FrameBuffer Viewer) is a simple program to view pictures on a linux framebuffer device. In 2000, when fbv was created, there were no other situable programs performing the same task, so the authors decided to follow the rule: 'If you need a tool - write it yourself!' :-) https://github.com/smokku/fbv Fa\u00e7a Adicione o programa fbv ao buildroot Compile o novo fs Grave no SDCard Grave uma imagem no SDCard No target, exiba a imagem usando o fbv","title":"Tutorial - HPS + FPGA - VGA"},{"location":"Tutorial-HPS-FPGA-VGA/#tutorial-hps-fpga-vga","text":"Se repararem em nosso hardware verificamos que o mesmo possui uma sa\u00edda de v\u00eddeo VGA, por\u00e9m os sinais do VGA foram conectados nos pinos da FPGA! Tornando necess\u00e1rio a cria\u00e7\u00e3o de um hardware e sua conex\u00e3o com o HPS para que possamos fazer com que nosso Linux tenha uma sa\u00edda de v\u00eddeo. Diagrama Para conseguirmos ter uma sa\u00edda de v\u00eddeo no nosso sistema embarcado, teremos que realizar os seguintes passos: Configurar um hw que gerencie VGA alt_vip_* pense que vamos adicionar na FPGA uma 'placa de v\u00eddeo' muito simples Adicionar ao kernel um device driver para gerenciar esse hardware Configurar o kernel adicionando a parte de FB compilar o kernel Configurar no buildroot um programa capaz de manipular o FB e exibir uma imagem","title":"Tutorial - HPS + FPGA - VGA"},{"location":"Tutorial-HPS-FPGA-VGA/#frame-buffer","text":"Antes de mexermos com o hardware, vamos ver como o Linux trata uma sa\u00edda de v\u00eddeo! Voc\u00ea j\u00e1 ouviu falar de frame buffer (FB)? Verifique que o seu PC possui um: $ ls /dev | grep fb O FB \u00e9 uma regi\u00e3o da mem\u00f3ria RAM reservada e que cont\u00e9m um bitmap (se tiver uma placa de v\u00eddeo, essa mem\u00f3ria pode estar localizada nela), esse bitmap \u00e9 convertido (por hardware ou software) para a sa\u00edda de v\u00eddeo em quest\u00e3o. Essa convers\u00e3o de bitmap para sa\u00edda de v\u00eddeo depende do driver de v\u00eddeo que foi carregado para gerenciar (e criar) o FB, no caso de placas de v\u00eddeo intel, \u00e9 utilizado o driver vesa . Por\u00e9m nem tudo que \u00e9 exibido passa diretamente pelo FB, alguns programas podem querer maior performance e podem acessar o display direto ( Direct Graphics Access ), como demonstrado no diagrama a seguir: Framebuffer Console O Linux possui um driver (fbcon) que exibe um console em um framebuffer, para usar, basta ativar na configura\u00e7\u00e3o do kernel: Device Drivers Graphics Support->Frame buffer Devices->Console display driver support Framebuffer Console Support Para mais detalhes: https://www.kernel.org/doc/html/latest/fb/fbcon.html","title":"Frame Buffer"},{"location":"Tutorial-HPS-FPGA-VGA/#hardware","text":"Como no exemplo anterior (para ganhar tempo), vamos utilizar um hardware da Terasic que j\u00e1 possui a parte da FPGA configurada para trabalharmos com o VGA. Copie a pasta DE10-Standard-v.1.3.0-SystemCD/Demonstration/SoC_FPGA/DE10_Standard_FB/ para o seu reposit\u00f3rio. Com o projeto DE10_Standard_FB copiado, abra o projeto no quartus e analise o soc_system.qsys no Platform Designer, voc\u00ea deve ver algo como: Eu deixei a mostra somente as partes referentes ao v\u00eddeo!","title":"Hardware"},{"location":"Tutorial-HPS-FPGA-VGA/#entendo-o-hw","text":"O projeto de HW possui dois componentes para tratar o VGA: alt_vip_vfr_vga e alt_vip_itc_0 , ambos fazem parte do pacote de IPs: 'Video and Image Processing Suite Intel FPGA' espec\u00edfico para processamento de v\u00eddeo (j\u00e1 suporta 8K e +60Hz) Video and Image Process ( VIP ) Suite Intel FPGA Retirado do site da Intel: The Intel\u00ae FPGA Video and Image Processing Suite is a collection of Intel FPGA IP functions that you can use to facilitate the development of custom video and image processing (VIP) designs. These Intel FPGA IP functions are suitable for use in a wide variety of image processing and display applications, such as video surveillance, broadcast, video conferencing, and medical and military imaging. The Video and Image Processing Suite features cores that range from simple building block functions, such as color space conversion to sophisticated video scaling functions that can implement programmable polyphase scaling. All the VIP cores use an open, low-overhead Avalon\u00ae Streaming (Avalon-ST) interface standard so that they can be easily connected You can use VIP cores to quickly build a custom video processing signal chain using the Intel Quartus\u00ae Prime Lite or Standard Edition software and the associated Platform Designer You can mix and match VIP cores with your own proprietary intellectual property (IP) You can use the Platform Designer to automatically integrate embedded processors and peripherals and generate arbitration logic Capable of supporting 8K video at 60fps and above https://www.intel.com.br/content/www/br/pt/programmable/products/intellectual-property/ip/dsp/m-alt-vipsuite.html","title":"Entendo o HW"},{"location":"Tutorial-HPS-FPGA-VGA/#alt_vip_vfr_vga","text":"\u00c9 um perif\u00e9rico do tipo Frame Reader e \u00e9 respons\u00e1vel por fazer a leitura de um Frame Buffer alocado em mem\u00f3ria ( avalon_master ) e o transformar em um Streaming ( avalon_streaming ). A maioria dos IP do VIP operam no barramento de dados do tipo: avalon_streaming , por isso \u00e9 necess\u00e1rio fazer a leitura do FB (que est\u00e1 alocado na mem\u00f3ria DDR3, conectada ao ARM). Os dados da DDR3 s\u00e3o transferidos para o alt_vip_vfr_vga via DMA pelo ARM/Linux, inicializado pelo device driver carregado no Linux!","title":"alt_vip_vfr_vga"},{"location":"Tutorial-HPS-FPGA-VGA/#alt_vip_itc","text":"\u00c9 um perif\u00e9rico de v\u00eddeo que faz a convers\u00e3o do streaming de pixels para a sa\u00edda de v\u00eddeo em quest\u00e3o (VGA). O VGA \u00e9 um formato de sa\u00edda de v\u00eddeo DIGITA que possui 5 sinais: HSYNC/ VSYNC/ R/G/B. HSYNC: indica o fim da linha VSYNC: indica o fim da tela R/G/B: s\u00e3o os valores dos pixels. Note O sinal VGA \u00e9 simples. que at\u00e9 da para gerar via arduino: - http://labdegaragem.com/profiles/blogs/gerando-sinal-vga-colorido-com-arduino-completo","title":"alt_vip_itc"},{"location":"Tutorial-HPS-FPGA-VGA/#compilando","text":"Agora que analisamos o HW, podemos compilar e utilizar no nosso SoC! Execute Gere o soc_system.dtb do projeto Grave o novo soc_system.dtb no SDCard (mesma parti\u00e7\u00e3o do kernel) Gere o soc_system.rbf do projeto (COMPILAR O QUARTUS!) Grave o novo rbf no SDCard (mesma parti\u00e7\u00e3o do kernel)","title":"Compilando"},{"location":"Tutorial-HPS-FPGA-VGA/#driver","text":"Ser\u00e1 necess\u00e1rio carregarmos um device driver no kernel do linux para que possamos utilizar essa sa\u00edda de v\u00eddeo rec\u00e9m criada. Por\u00e9m o driver do IP alt_vip_vfr_vga n\u00e3o \u00e9 oficial do kernel, vamos ter que adicionar manualmente!","title":"Driver"},{"location":"Tutorial-HPS-FPGA-VGA/#dts","text":"Mas como o linux sabe que existe uma sa\u00edda de v\u00eddeo? No nosso caso ser\u00e1 via o device tree (.dtb) que \u00e9 passado pelo u-boot na inicializa\u00e7\u00e3o do kernel, se repararmos no novo .dts gerado com o hardware, existe um novo componente chamado de alt_vip_vfr_vga , que \u00e9 compat\u00edvel com o driver vip-frame-reader-9.1 : alt_vip_vfr_vga : vip @ 0x100031000 { compatible = \"ALTR,vip-frame-reader-14.0\" , \"ALTR,vip-frame-reader-9.1\" ; reg = < 0x00000001 0x00031000 0x00000080 > ; clocks = <& clk_0 > ; max-width = < 1024 > ; /* MAX_IMAGE_WIDTH type NUMBER */ max-height = < 768 > ; /* MAX_IMAGE_HEIGHT type NUMBER */ bits-per-color = < 8 > ; /* BITS_PER_PIXEL_PER_COLOR_PLANE type NUMBER */ colors-per-beat = < 4 > ; /* NUMBER_OF_CHANNELS_IN_PARALLEL type NUMBER */ beats-per-pixel = < 1 > ; /* NUMBER_OF_CHANNELS_IN_SEQUENCE type NUMBER */ mem-word-width = < 128 > ; /* MEM_PORT_WIDTH type NUMBER */ }; //end vip@0x100031000 (alt_vip_vfr_vga)","title":"dts"},{"location":"Tutorial-HPS-FPGA-VGA/#driver_1","text":"O driver vip-frame-reader-9.1 n\u00e3o \u00e9 oficial do linux, vamos ter que pegar uma implementa\u00e7\u00e3o realizada pelo o pessoal da Altera e utilizar. Os drivers no reposit\u00f3rio do Linux ficam na pasta: linux/drivers . No caso do v\u00eddeo/ framebuffer, em: linux/drivers/video/fbdev . Adicionando o driver altvipfb Siga o roteiro em: https://github.com/Insper/Embarcados-Avancados/blob/master/driver/altvipfb/README.md e depois volte para essa p\u00e1gina! Note Esse tutorial incluiu o driver do fb no kernel, outra op\u00e7\u00e3o seria criar um m\u00f3dulo (module) que poderia ser carregado conforme a necessidade. Testando Compile o kernel Copie o zImage novo para o SDCARD Liga um monitor a VGA Inicialize o linux embarcado Se tudo der certo, voc\u00ea deve ver dois pinguins no canto esquerdo do monitor. Cada pinguim representa um core do sistema, como nosso ARM \u00e9 um dual core, temos dois. Esse pinguins aparecem porque ativamos essa op\u00e7\u00e3o no kernel: CONFIG_LOGO=y CONFIG_LOGO_LINUX_MONO=y CONFIG_LOGO_LINUX_VGA16=y CONFIG_LOGO_LINUX_CLUT224=y Note \u00c9 poss\u00edvel editar o pinguim e fazer por exemplo, aparecer a carinha de voc\u00eas! Os arquivos ppm ficam na pasta /drivers/video/logo/ , esses s\u00e3o ent\u00e3o compilados na compila\u00e7\u00e3o do kernel. Quer fazer umas coisas legais com o FB? Tenta o seguinte: Exibir imagem rand\u00f4mica no FB: sudo cat /dev/urandom > /dev/fb0 ref: http://seenaburns.com/2018/04/04/writing-to-the-framebuffer/","title":"driver"},{"location":"Tutorial-HPS-FPGA-VGA/#buildroot","text":"S\u00e3o diversas as solu\u00e7\u00f5es de desenvolvimento de interface gr\u00e1fica para Linux embarcado, e nem todas envolvem um gerenciador de janelas. A seguir uma lista de ferramentas que podem ser utilizadas: GUI: LittlevGL: https://littlevgl.com/ QT: https://www.qt.io/ emWin (comercial): https://www.segger.com/products/user-interface/emwin/ ... Existem outras solu\u00e7\u00f5es, vamos usar uma delas para exibir uma imagem na nossa tela! Quando eu estava fazendo esse roteiro, queria algo mais simples, em uma busca (n\u00e3o muito r\u00e1pida) na internet (keyword: linux frame buffer show image ) eu encontrei esse programa: fbv , que por sorte est\u00e1 no buildroot . fbv OVERVIEW fbv (FrameBuffer Viewer) is a simple program to view pictures on a linux framebuffer device. In 2000, when fbv was created, there were no other situable programs performing the same task, so the authors decided to follow the rule: 'If you need a tool - write it yourself!' :-) https://github.com/smokku/fbv Fa\u00e7a Adicione o programa fbv ao buildroot Compile o novo fs Grave no SDCard Grave uma imagem no SDCard No target, exiba a imagem usando o fbv","title":"Buildroot"},{"location":"Tutorial-HPS-FPGA-kernel-char-led-driver/","text":"Char LED device driver \u00b6 Agora iremos misturar o tutorial do char-device-driver com o tutorial do Tutorial - HPS + FPGA - Blink LED , onde iremos desenvolver um driver no linux capaz de controlar os LEDs da FPGA. Info Para seguir nesse tutorial voc\u00ea deve ter feito o do HPS + FPGA - Blik LED e ter o SDCARD configurado com a imagem da FPGA que possui o PD com os PIO que controla os LEDs. Extraindo do PD \u00b6 Para controlarmos os LEDs da FPGA \u00e9 necess\u00e1rio que saibamos os endere\u00e7os dos perif\u00e9ricos no barramento do platform designer (AVALON), para n\u00e3o termos que ficar dependentes de n\u00fameros m\u00e1gicos no nosso driver, iremos usar uma ferramenta do PD que gera um arquivo .h com as informa\u00e7\u00f5es necess\u00e1rias para podermos controlar os perif\u00e9ricos. Na pasta do projeto (hardware) execute: $ embedded_command_shell.sh $ sopc-create-header-files --single hps_0.h --module hps_0 Esse comando ir\u00e1 gerar um arquivo hps_0.h que cont\u00e9m as informa\u00e7\u00f5es de endere\u00e7o de mem\u00f3ria que podemos usar para acessar os perif\u00e9ricos na FPGA: /* * Macros for device 'led_pio', class 'altera_avalon_pio' * The macros are prefixed with 'LED_PIO_'. * The prefix is the slave descriptor. */ #define LED_PIO_COMPONENT_TYPE altera_avalon_pio #define LED_PIO_COMPONENT_NAME led_pio #define LED_PIO_BASE 0x3000 #define LED_PIO_SPAN 16 #define LED_PIO_END 0x300f #define LED_PIO_BIT_CLEARING_EDGE_REGISTER 0 #define LED_PIO_BIT_MODIFYING_OUTPUT_REGISTER 0 Configurando driver \u00b6 Primeiro iremos realizar uma c\u00f3pia da pasta do driver: ebbchar para ebbchar-led . hps_0.h \u00b6 Copie o arquivo hps_0.h para dentro da pasta do driver. Makefile \u00b6 Vamos ter que editar o Makefile para suportar: Cross-compila\u00e7\u00e3o Arquivos e fun\u00e7\u00f5es do Embedded do Quartus Use o arquivo a seguir no lugar do Makefile original: # https://stackoverflow.com/questions/3467850/cross-compiling-a-kernel-module ARCH = arm COMPILER = arm-linux-gnueabihf- ALT_DEVICE_FAMILY ?= soc_cv_av SOCEDS_ROOT ?= $( SOCEDS_DEST_ROOT ) HWLIBS_ROOT = $( SOCEDS_ROOT ) /ip/altera/hps/altera_hps/hwlib #EXTRA_CFLAGS = -D$(ALT_DEVICE_FAMILY) -I$(HWLIBS_ROOT)/include/$(ALT_DEVICE_FAMILY) -I$(HWLIBS_ROOT)/include/ obj-m := ebbchar.o KERNELDIR := /home/corsi/work/Embarcados-Avancados/Corsi/linux PWD := $( shell pwd ) IP = 169 .254.0.13 DEST = /root/driver/ PASS = 1234 all : ebbchar . ko , test ebbchar.ko : ebbchar . c $( MAKE ) -C $( KERNELDIR ) M = $( PWD ) ARCH = $( ARCH ) CROSS_COMPILE = $( COMPILER ) modules test : $( COMPILER ) gcc testebbchar.c -o test deploy : ebbchar . ko test sshpass -p $( PASS ) scp test root@ $( IP ) : $( DEST ) sshpass -p $( PASS ) scp ebbchar.ko root@ $( IP ) : $( DEST ) clean : $( MAKE ) -C $( KERNELDIR ) M = $( PWD ) ARCH = $( ARCH ) clean rm test Info Voc\u00ea deve editar a vari\u00e1vel KERNELDIR := para o caminho do kernel que voc\u00ea compilou. Acessando hardware \u00b6 No kernel do Linux s\u00e3o v\u00e1rias as fun\u00e7\u00f5es dispon\u00edveis para manipular hardware/ endere\u00e7o de mem\u00f3ria f\u00edsica. Iremos usar apenas a fun\u00e7\u00e3o: void iowrite32 ( u32 value , void __iomem * addr ); Info https://lwn.net/Articles/102232/ Essa fun\u00e7\u00e3o escreve um valor value a um endere\u00e7o de mem\u00f3ria f\u00edsica addr . Para isso funcionar devemos criar um ponteiro que aponta para o perif\u00e9rico PIO na FPGA: p_led = ioremap_nocache ( ALT_LWFPGASLVS_OFST + LED_PIO_BASE , LED_PIO_SPAN ); Info Estamos falando para o kernel criar um ponteiro e que todo acesso a esse endere\u00e7o deve ser efetivado no hardware, e n\u00e3o pode ficar no cache. Onde p_led \u00e9 uma vari\u00e1vel global e est\u00e1tica do m\u00f3dulo: static int * p_led = NULL ; Com isso, podemos agora usar a fun\u00e7\u00e3o iowrite32 e escrever no perif\u00e9rico PIO do LED, iremos fazer essa escrita dentro da fun\u00e7\u00e3o dev_write , com o objetivo de escrevermos nos LEDs os valores passados pelo comando de write. A fun\u00e7\u00e3o deve ficar como: static ssize_t dev_write ( struct file * filep , const char * buffer , size_t len , loff_t * offset ){ copy_from_user ( message , buffer , len ); size_of_message = len ; // store the length of the stored message printk ( KERN_INFO \"EBBChar: Received %zu characters from the user \\n \" , len ); // escreve no hardware! iowrite32 ( message [ 0 ], p_led ); // corsi: write to LED return len ; } Agora, toda vez que um programa no userspace escrever nesse driver, o mesmo ir\u00e1 pegar o primeiro byte e transferir para o PIO na FPGA. Testando \u00b6 Para testa: Compile o m\u00f3dulo e o programa de teste Passe para o SoC Carregue o m\u00f3dulo e teste.","title":"Char LED device driver"},{"location":"Tutorial-HPS-FPGA-kernel-char-led-driver/#char-led-device-driver","text":"Agora iremos misturar o tutorial do char-device-driver com o tutorial do Tutorial - HPS + FPGA - Blink LED , onde iremos desenvolver um driver no linux capaz de controlar os LEDs da FPGA. Info Para seguir nesse tutorial voc\u00ea deve ter feito o do HPS + FPGA - Blik LED e ter o SDCARD configurado com a imagem da FPGA que possui o PD com os PIO que controla os LEDs.","title":"Char LED device driver"},{"location":"Tutorial-HPS-FPGA-kernel-char-led-driver/#extraindo-do-pd","text":"Para controlarmos os LEDs da FPGA \u00e9 necess\u00e1rio que saibamos os endere\u00e7os dos perif\u00e9ricos no barramento do platform designer (AVALON), para n\u00e3o termos que ficar dependentes de n\u00fameros m\u00e1gicos no nosso driver, iremos usar uma ferramenta do PD que gera um arquivo .h com as informa\u00e7\u00f5es necess\u00e1rias para podermos controlar os perif\u00e9ricos. Na pasta do projeto (hardware) execute: $ embedded_command_shell.sh $ sopc-create-header-files --single hps_0.h --module hps_0 Esse comando ir\u00e1 gerar um arquivo hps_0.h que cont\u00e9m as informa\u00e7\u00f5es de endere\u00e7o de mem\u00f3ria que podemos usar para acessar os perif\u00e9ricos na FPGA: /* * Macros for device 'led_pio', class 'altera_avalon_pio' * The macros are prefixed with 'LED_PIO_'. * The prefix is the slave descriptor. */ #define LED_PIO_COMPONENT_TYPE altera_avalon_pio #define LED_PIO_COMPONENT_NAME led_pio #define LED_PIO_BASE 0x3000 #define LED_PIO_SPAN 16 #define LED_PIO_END 0x300f #define LED_PIO_BIT_CLEARING_EDGE_REGISTER 0 #define LED_PIO_BIT_MODIFYING_OUTPUT_REGISTER 0","title":"Extraindo do PD"},{"location":"Tutorial-HPS-FPGA-kernel-char-led-driver/#configurando-driver","text":"Primeiro iremos realizar uma c\u00f3pia da pasta do driver: ebbchar para ebbchar-led .","title":"Configurando driver"},{"location":"Tutorial-HPS-FPGA-kernel-char-led-driver/#hps_0h","text":"Copie o arquivo hps_0.h para dentro da pasta do driver.","title":"hps_0.h"},{"location":"Tutorial-HPS-FPGA-kernel-char-led-driver/#makefile","text":"Vamos ter que editar o Makefile para suportar: Cross-compila\u00e7\u00e3o Arquivos e fun\u00e7\u00f5es do Embedded do Quartus Use o arquivo a seguir no lugar do Makefile original: # https://stackoverflow.com/questions/3467850/cross-compiling-a-kernel-module ARCH = arm COMPILER = arm-linux-gnueabihf- ALT_DEVICE_FAMILY ?= soc_cv_av SOCEDS_ROOT ?= $( SOCEDS_DEST_ROOT ) HWLIBS_ROOT = $( SOCEDS_ROOT ) /ip/altera/hps/altera_hps/hwlib #EXTRA_CFLAGS = -D$(ALT_DEVICE_FAMILY) -I$(HWLIBS_ROOT)/include/$(ALT_DEVICE_FAMILY) -I$(HWLIBS_ROOT)/include/ obj-m := ebbchar.o KERNELDIR := /home/corsi/work/Embarcados-Avancados/Corsi/linux PWD := $( shell pwd ) IP = 169 .254.0.13 DEST = /root/driver/ PASS = 1234 all : ebbchar . ko , test ebbchar.ko : ebbchar . c $( MAKE ) -C $( KERNELDIR ) M = $( PWD ) ARCH = $( ARCH ) CROSS_COMPILE = $( COMPILER ) modules test : $( COMPILER ) gcc testebbchar.c -o test deploy : ebbchar . ko test sshpass -p $( PASS ) scp test root@ $( IP ) : $( DEST ) sshpass -p $( PASS ) scp ebbchar.ko root@ $( IP ) : $( DEST ) clean : $( MAKE ) -C $( KERNELDIR ) M = $( PWD ) ARCH = $( ARCH ) clean rm test Info Voc\u00ea deve editar a vari\u00e1vel KERNELDIR := para o caminho do kernel que voc\u00ea compilou.","title":"Makefile"},{"location":"Tutorial-HPS-FPGA-kernel-char-led-driver/#acessando-hardware","text":"No kernel do Linux s\u00e3o v\u00e1rias as fun\u00e7\u00f5es dispon\u00edveis para manipular hardware/ endere\u00e7o de mem\u00f3ria f\u00edsica. Iremos usar apenas a fun\u00e7\u00e3o: void iowrite32 ( u32 value , void __iomem * addr ); Info https://lwn.net/Articles/102232/ Essa fun\u00e7\u00e3o escreve um valor value a um endere\u00e7o de mem\u00f3ria f\u00edsica addr . Para isso funcionar devemos criar um ponteiro que aponta para o perif\u00e9rico PIO na FPGA: p_led = ioremap_nocache ( ALT_LWFPGASLVS_OFST + LED_PIO_BASE , LED_PIO_SPAN ); Info Estamos falando para o kernel criar um ponteiro e que todo acesso a esse endere\u00e7o deve ser efetivado no hardware, e n\u00e3o pode ficar no cache. Onde p_led \u00e9 uma vari\u00e1vel global e est\u00e1tica do m\u00f3dulo: static int * p_led = NULL ; Com isso, podemos agora usar a fun\u00e7\u00e3o iowrite32 e escrever no perif\u00e9rico PIO do LED, iremos fazer essa escrita dentro da fun\u00e7\u00e3o dev_write , com o objetivo de escrevermos nos LEDs os valores passados pelo comando de write. A fun\u00e7\u00e3o deve ficar como: static ssize_t dev_write ( struct file * filep , const char * buffer , size_t len , loff_t * offset ){ copy_from_user ( message , buffer , len ); size_of_message = len ; // store the length of the stored message printk ( KERN_INFO \"EBBChar: Received %zu characters from the user \\n \" , len ); // escreve no hardware! iowrite32 ( message [ 0 ], p_led ); // corsi: write to LED return len ; } Agora, toda vez que um programa no userspace escrever nesse driver, o mesmo ir\u00e1 pegar o primeiro byte e transferir para o PIO na FPGA.","title":"Acessando hardware"},{"location":"Tutorial-HPS-FPGA-kernel-char-led-driver/#testando","text":"Para testa: Compile o m\u00f3dulo e o programa de teste Passe para o SoC Carregue o m\u00f3dulo e teste.","title":"Testando"},{"location":"Tutorial-HPS-Kernel/","text":"Tutorial 7 - HPS - Compilando o kernel \u00b6 Nesse tutorial iremos compilar o kernel do Linux para o ARM do nosso SoC usando o toolchain que j\u00e1 temos configurado. Kernel 4.4 \u00b6 Clone o kernel do linux : $ git clone https://github.com/torvalds/linux $ cd linux Isso pode demorar um pouquinho, o kernel \u00e9 um projeto grande. Tip O reposit\u00f3rio oficial do kernel do linus \u00e9 o : https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git por\u00e9m clonar dele \u00e9 normalmente muito mais lento que do github (que \u00e9 apenas um mirror do reposit\u00f3rio oficial). Vamos trabalhar com a vers\u00e3o 4.4 do kernel que \u00e9 uma vers\u00e3o com: Long Time Suport (LTS), ou seja, ser\u00e1 mantida por muito mais tempo que as outras vers\u00f5es. A vers\u00e3o 4.4 foi lan\u00e7ada em 10 de Janeiro e ser\u00e1 mantida oficialmente at\u00e9 2021, ela tamb\u00e9m \u00e9 uma vers\u00e3o chamada de Super LTS, com suporte estendido at\u00e9 2036. Linux Pense que um desenvolvedor de um sistema embarcado, que vai criar toda uma infra dedicada n\u00e3o quer ficar ter que ajustando e validando tudo novamente s\u00f3 para ter a vers\u00e3o mais nova do kenrel. A ideia de usar uma com maior suporte \u00e9 minimizar esfor\u00e7os com recursos novos. O kernel utiliza o sistema de tag do git: $ git tag ... v2.6.11 v2.6.11-tree v2.6.12 v2.6.12-rc2 v2.6.12-rc3 v2.6.12-rc4 v2.6.12-rc5 v2.6.12-rc6 v2.6.13-rc2 v2.6.14-rc2 v2.6.14-rc3 ... Note que revis\u00f5es \u00edmpares s\u00e3o para Karnel em est\u00e1gio de desenvolvimento, e n\u00fameros pares para vers\u00e3o de produ\u00e7\u00e3o, exemplo : Linux 2.4.x - Produ\u00e7\u00e3o Linux 2.5.x - Desenvolvimento Linux 2.6.x - Produ\u00e7\u00e3o .... Vamos criar um branch da vers\u00e3o v4.4, para isso execute o comando a seguir: $ git checkout v4.4 $ git checkout -b 4 .4-SoC Configurando o kernel \u00b6 Uma vez no branch 4.4-SoC precisamos configurar o kernel para nosso processador (ARM) e fazer as configura\u00e7\u00f5es necess\u00e1rias no kernel. Primeiramente iremos gerar um arquivo de configura\u00e7\u00e3o .config padr\u00e3o para SoCs ARM Altera: $ export ARCH = arm # indica a arquitetura do Kernel $ make socfpga_defconfig # gera o arquivo padr\u00e3o de configura\u00e7\u00e3o para SoC Note As configura\u00e7\u00e3o do kernel ficam salvos no arquivo: .config na raiz do reposit\u00f3rio. Quando executamos o comando make socfpga_defconfig , o mesmo \u00e9 inicializado com algumas configura\u00e7\u00f5es padr\u00f5es. Voc\u00ea pode dar uma olhada na pasta: linux/arch/arm/configs/socfpga_defconfig . Agora vamos configurar alguns par\u00e2metros espec\u00edficos do Kernel para a nossa aplica\u00e7\u00e3o: $ make ARCH = arm menuconfig Note Talvez seja necess\u00e1rio instalar o pacote libncurses5-dev $ sudo apt install libncurses5-dev Esse comando ir\u00e1 abrir a interface de configura\u00e7\u00e3o do Kernel do Linux (existem outras op\u00e7\u00f5es: make xconfig ; make config ; make gconfig , ...). Essa interface permite selecionarmos v\u00e1rias configura\u00e7\u00f5es do Kernel. Agora iremos seguir o roteiro proposto no tutorial a seguir, traduzido de maneira reduzida aqui. https://rocketboards.org/foswiki/Documentation/EmbeddedLinuxBeginnerSGuide Configurando \u00b6 Automatically append version information to the version string General Setup Desabilite : Automatically append version information to the version string Exclude/ Include Para Desativar utilize a letra N do teclado, para incluir a letra Y D\u00favidas? A maioria dos par\u00e2metros possui uma explica\u00e7\u00e3o, basta apertar ? para ler a respeito. Note ref : https://rocketboards.org/foswiki/Documentation/EmbeddedLinuxBeginnerSGuide#8 Go into the \u201cGeneral Setup\u201d menu. Uncheck \u201cAutomatically append version information to the version string\u201d. This will prevent the kernel from adding extra \u201cversion\u201d information to the kernel. Whenever we try to dynamically load a driver (also called kernel modules, as discussed in a later section) the kernel will check to see if the driver was built with the same version of the source code as itself. If it isn\u2019t, it will reject to load that driver. For development, it\u2019s useful to disable these options to make it easier to test out different versions of drivers. In a production system however, it\u2019s recommend to keep this option enabled and only use drivers that were compiled with the correct version of the kernel. I encourage you to peruse the options in the General Setup menu and see what\u2019s available to you (hitting \u201c?\u201d to view the help info for the highlighted option). Of particular importance to us is the \u201cEmbedded System\u201d option (turns on advanced features) and the type of SLAB allocator used (determines how memory will be dynamically allocated in the kernel). If you want to use an initial ram disk or ram filesystem that would be enabled here as well (these will be explained in the next section). (texto extra\u00eddo da refer\u00eancia) Enable loadable module support \u00b6 Volte para o menu principal ( <ESC> <ESC> ) Note que o Enable loadable module support est\u00e1 ativado. Isso permite que o kernel seja modificado (pelo carregamento de drivers) ap\u00f3s a sua execu\u00e7\u00e3o. Isso ser\u00e1 \u00fatil quando formos desenvolver nosso pr\u00f3prio device driver, sem a necessidade de recompilarmos o kernel toda vez que desejamos testar uma modifica\u00e7\u00e3o no c\u00f3digo. \u00c9 essa configura\u00e7\u00e3o que permite utilizarmos USBs, SSDs, placas de rede via a possibilidade do carregamento de drivers de forma din\u00e2mica pelo sistema operacional. Support for large (2TB+) block devices and files \u00b6 No menu principal Enable the block layer Ative : Support for large (2TB+) block devices and files Essa op\u00e7\u00e3o ir\u00e1 permitir a utiliza\u00e7\u00e3o de parti\u00e7\u00f5es do tipo EXT4. Se esquecer essa op\u00e7\u00e3o e o kernel tiver em uma parti\u00e7\u00e3o EXT4 a mesma ser\u00e1 montada como READ-ONLY. The Extended 4 (ext4) filesystem \u00b6 Menu principal File systems Note que j\u00e1 est\u00e1 selecionado: The Extended 4 (ext4) filesystem Essa op\u00e7\u00e3o ir\u00e1 possibilitar que o kernel monte dispositivos formatados em EXT4. Pretendemos usar isso no SDCARD. Altera SOCFPGA family \u00b6 Menu principal System Type Note que j\u00e1 est\u00e1 selecioado: Altera SOCFGPA family Isso indica para o kernel qual ser\u00e1 o dispositivo que o mesmo ser\u00e1 executado, note que esssa op\u00e7\u00e3o possui um novo menu onde podemos ativar ou n\u00e3o a suspens\u00e3o para RAM. Symmetric Multi-Processing \u00b6 Menu principal Kernel Features Note que j\u00e1 est\u00e1 selecioado: Symmmetric Multi-Processing Essa op\u00e7\u00e3o indica para o kernel que ele deve utilizar os dois cores presente no ARM HPS da FPGA. Device Drivers \u00b6 Menu principal Device Drivers Analise os drivers dispon\u00edveis... Indica quais drivers ser\u00e3o compilados junto com o kernel, note que j\u00e1 temos configurado drivers de rede (Network device support); GPIO (GPIO Support); RTC; DMA; ... . Lembre que j\u00e1 inicializamos o .config com uma configura\u00e7\u00e3o padr\u00e3o para SoCs Altera. Salvando \u00b6 Aperte ESC duas vezes ( <ESC> <ESC> ) e salve as configura\u00e7\u00f5es no arquivo .config .config \u00b6 Note De uma olhada no arquivo .config gerado! As vezes \u00e9 mais f\u00e1cil editar direto nele, do que ter que abrir o menu de configura\u00e7\u00e3o e encontrar o local de ativar um m\u00f3dulo. Compilando \u00b6 O makefile utiliza a vari\u00e1vel CROSS_COMPILE para definir o toolchain que ir\u00e1 fazer a compila\u00e7\u00e3o do kernel, vamos definir como sendo o GCC do Linaro baixado recentemente: $ export CROSS_COMPILE = $GCC_Linaro /arm-linux-gnueabihf- Para compilarmos o kernel : make ARCH = arm LOCALVERSION = zImage -j 4 Note -j4 executa a compila\u00e7\u00e3o em 4 threads, voc\u00ea pode ajustar esse valor para adequar ao seu processador. Dica Adicione o export CROSS_COMPILE=.... ao seu .bashrc para n\u00e3o ter que ficar digitando isso sempre que tiver que compilar o kernel. Fail Caso aconte\u00e7a algum erro de build, deve-se verificar o path do CROSS_COMPILE ou se existe alguma depend\u00eancia que n\u00e3o foi satisfeita. Esse comando faz com que o kernel do linux seja compilado em uma vers\u00e3o compactada que \u00e9 auto-extra\u00edda. Outras op\u00e7\u00f5es seriam : Image : Bin\u00e1rio do kernel zImage: vers\u00e3o compactada que possui self-extracting uImage: uma vers\u00e3o que j\u00e1 possui o bootloader uboot 1^: https://stackoverflow.com/questions/22322304/image-vs-zimage-vs-uimage Kernel compilado o zImage \u00e9 salvo em: arch/arm/boot/zImage zImage Esse arquivo \u00e9 o bin\u00e1rio que cont\u00e9m o kernel do linux e ser\u00e1 executado no sistema embarcado. Atualizando o SDCARD Agora devemos atualizar o kernel que est\u00e1 no SDCard, para isso basta: inserir o sdcard no pc montar a parti\u00e7\u00e3o 1 substituir o zImage que est\u00e1 no SDCARD pelo o gerado dentro da pata arch/arm/boot/zImage ejetar o sdcard ou executar o comando sync coloque o SDCARD na placa e ligar a FPGA Executando \u00b6 Para verificar se tudo est\u00e1 certo, basta colocar o cart\u00e3o de mem\u00f3ria no kit e verificar a vers\u00e3o do kernel em execu\u00e7\u00e3o: $ uname -a Linux buildroot 4 .14.0 #1 SMP Mon Jul 16 21:22:58 -03 2018 armv7l GNU/Linux Mouse/ Teclado? \u00b6 Mouse e teclado funcionam de imediato? Tentei plugar um mouse USB na placa, ele \u00e9 reconhecido pelo Linux? N\u00e3o deveria. Para funcionar voc\u00ea deve voltar nas configura\u00e7\u00f5es do kernel do linux e inserir os drivers que gereciam USB e HID. Compilar, substituit o zImage no sdcard e testar novamente. Como verificar se o mouse est\u00e1 funcionando? Digite 'lsusb', ele deve mostrar que reconheceu um mouse Ap\u00f3s conectar o mouse, digite tail dmesg , ele deve mostrar que reconheceu um novo device USB e que associou ele com um mouse O mouse no linux \u00e9 montado em /dev/input/mice , para ver se est\u00e1 funcionando voc\u00ea pode executar: cat /dev/input/mice , mexa o mouse para ver se aparece alguma coisa na tela Human Interface Devices (HID) HID \u00e9 um tipo de dispositivo reconhecido pelo Kenel do Linux como um dispositivo de interface com o usu\u00e1rio, esse tipo de dispositivo \u00e9 normalmente reconhecido automaticamente pelos kernels, po\u00eds eles implementam um pad\u00e3o de comunica\u00e7\u00e3o. https://www.kernel.org/doc/html/latest/hid/index.html O USB tamb\u00e9m possui uma classifica\u00e7\u00e3o de dispositivos do tipo HID, que facilita o uso dos mesmos pelo kernel: https://en.wikipedia.org/wiki/USB_human_interface_device_class","title":"Tutorial 7 - HPS - Compilando o kernel"},{"location":"Tutorial-HPS-Kernel/#tutorial-7-hps-compilando-o-kernel","text":"Nesse tutorial iremos compilar o kernel do Linux para o ARM do nosso SoC usando o toolchain que j\u00e1 temos configurado.","title":"Tutorial 7 - HPS - Compilando o kernel"},{"location":"Tutorial-HPS-Kernel/#kernel-44","text":"Clone o kernel do linux : $ git clone https://github.com/torvalds/linux $ cd linux Isso pode demorar um pouquinho, o kernel \u00e9 um projeto grande. Tip O reposit\u00f3rio oficial do kernel do linus \u00e9 o : https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git por\u00e9m clonar dele \u00e9 normalmente muito mais lento que do github (que \u00e9 apenas um mirror do reposit\u00f3rio oficial). Vamos trabalhar com a vers\u00e3o 4.4 do kernel que \u00e9 uma vers\u00e3o com: Long Time Suport (LTS), ou seja, ser\u00e1 mantida por muito mais tempo que as outras vers\u00f5es. A vers\u00e3o 4.4 foi lan\u00e7ada em 10 de Janeiro e ser\u00e1 mantida oficialmente at\u00e9 2021, ela tamb\u00e9m \u00e9 uma vers\u00e3o chamada de Super LTS, com suporte estendido at\u00e9 2036. Linux Pense que um desenvolvedor de um sistema embarcado, que vai criar toda uma infra dedicada n\u00e3o quer ficar ter que ajustando e validando tudo novamente s\u00f3 para ter a vers\u00e3o mais nova do kenrel. A ideia de usar uma com maior suporte \u00e9 minimizar esfor\u00e7os com recursos novos. O kernel utiliza o sistema de tag do git: $ git tag ... v2.6.11 v2.6.11-tree v2.6.12 v2.6.12-rc2 v2.6.12-rc3 v2.6.12-rc4 v2.6.12-rc5 v2.6.12-rc6 v2.6.13-rc2 v2.6.14-rc2 v2.6.14-rc3 ... Note que revis\u00f5es \u00edmpares s\u00e3o para Karnel em est\u00e1gio de desenvolvimento, e n\u00fameros pares para vers\u00e3o de produ\u00e7\u00e3o, exemplo : Linux 2.4.x - Produ\u00e7\u00e3o Linux 2.5.x - Desenvolvimento Linux 2.6.x - Produ\u00e7\u00e3o .... Vamos criar um branch da vers\u00e3o v4.4, para isso execute o comando a seguir: $ git checkout v4.4 $ git checkout -b 4 .4-SoC","title":"Kernel 4.4"},{"location":"Tutorial-HPS-Kernel/#configurando-o-kernel","text":"Uma vez no branch 4.4-SoC precisamos configurar o kernel para nosso processador (ARM) e fazer as configura\u00e7\u00f5es necess\u00e1rias no kernel. Primeiramente iremos gerar um arquivo de configura\u00e7\u00e3o .config padr\u00e3o para SoCs ARM Altera: $ export ARCH = arm # indica a arquitetura do Kernel $ make socfpga_defconfig # gera o arquivo padr\u00e3o de configura\u00e7\u00e3o para SoC Note As configura\u00e7\u00e3o do kernel ficam salvos no arquivo: .config na raiz do reposit\u00f3rio. Quando executamos o comando make socfpga_defconfig , o mesmo \u00e9 inicializado com algumas configura\u00e7\u00f5es padr\u00f5es. Voc\u00ea pode dar uma olhada na pasta: linux/arch/arm/configs/socfpga_defconfig . Agora vamos configurar alguns par\u00e2metros espec\u00edficos do Kernel para a nossa aplica\u00e7\u00e3o: $ make ARCH = arm menuconfig Note Talvez seja necess\u00e1rio instalar o pacote libncurses5-dev $ sudo apt install libncurses5-dev Esse comando ir\u00e1 abrir a interface de configura\u00e7\u00e3o do Kernel do Linux (existem outras op\u00e7\u00f5es: make xconfig ; make config ; make gconfig , ...). Essa interface permite selecionarmos v\u00e1rias configura\u00e7\u00f5es do Kernel. Agora iremos seguir o roteiro proposto no tutorial a seguir, traduzido de maneira reduzida aqui. https://rocketboards.org/foswiki/Documentation/EmbeddedLinuxBeginnerSGuide","title":"Configurando o kernel"},{"location":"Tutorial-HPS-Kernel/#configurando","text":"Automatically append version information to the version string General Setup Desabilite : Automatically append version information to the version string Exclude/ Include Para Desativar utilize a letra N do teclado, para incluir a letra Y D\u00favidas? A maioria dos par\u00e2metros possui uma explica\u00e7\u00e3o, basta apertar ? para ler a respeito. Note ref : https://rocketboards.org/foswiki/Documentation/EmbeddedLinuxBeginnerSGuide#8 Go into the \u201cGeneral Setup\u201d menu. Uncheck \u201cAutomatically append version information to the version string\u201d. This will prevent the kernel from adding extra \u201cversion\u201d information to the kernel. Whenever we try to dynamically load a driver (also called kernel modules, as discussed in a later section) the kernel will check to see if the driver was built with the same version of the source code as itself. If it isn\u2019t, it will reject to load that driver. For development, it\u2019s useful to disable these options to make it easier to test out different versions of drivers. In a production system however, it\u2019s recommend to keep this option enabled and only use drivers that were compiled with the correct version of the kernel. I encourage you to peruse the options in the General Setup menu and see what\u2019s available to you (hitting \u201c?\u201d to view the help info for the highlighted option). Of particular importance to us is the \u201cEmbedded System\u201d option (turns on advanced features) and the type of SLAB allocator used (determines how memory will be dynamically allocated in the kernel). If you want to use an initial ram disk or ram filesystem that would be enabled here as well (these will be explained in the next section). (texto extra\u00eddo da refer\u00eancia)","title":"Configurando"},{"location":"Tutorial-HPS-Kernel/#enable-loadable-module-support","text":"Volte para o menu principal ( <ESC> <ESC> ) Note que o Enable loadable module support est\u00e1 ativado. Isso permite que o kernel seja modificado (pelo carregamento de drivers) ap\u00f3s a sua execu\u00e7\u00e3o. Isso ser\u00e1 \u00fatil quando formos desenvolver nosso pr\u00f3prio device driver, sem a necessidade de recompilarmos o kernel toda vez que desejamos testar uma modifica\u00e7\u00e3o no c\u00f3digo. \u00c9 essa configura\u00e7\u00e3o que permite utilizarmos USBs, SSDs, placas de rede via a possibilidade do carregamento de drivers de forma din\u00e2mica pelo sistema operacional.","title":"Enable loadable module support"},{"location":"Tutorial-HPS-Kernel/#support-for-large-2tb-block-devices-and-files","text":"No menu principal Enable the block layer Ative : Support for large (2TB+) block devices and files Essa op\u00e7\u00e3o ir\u00e1 permitir a utiliza\u00e7\u00e3o de parti\u00e7\u00f5es do tipo EXT4. Se esquecer essa op\u00e7\u00e3o e o kernel tiver em uma parti\u00e7\u00e3o EXT4 a mesma ser\u00e1 montada como READ-ONLY.","title":"Support for large (2TB+) block devices and files"},{"location":"Tutorial-HPS-Kernel/#the-extended-4-ext4-filesystem","text":"Menu principal File systems Note que j\u00e1 est\u00e1 selecionado: The Extended 4 (ext4) filesystem Essa op\u00e7\u00e3o ir\u00e1 possibilitar que o kernel monte dispositivos formatados em EXT4. Pretendemos usar isso no SDCARD.","title":"The Extended 4 (ext4) filesystem"},{"location":"Tutorial-HPS-Kernel/#altera-socfpga-family","text":"Menu principal System Type Note que j\u00e1 est\u00e1 selecioado: Altera SOCFGPA family Isso indica para o kernel qual ser\u00e1 o dispositivo que o mesmo ser\u00e1 executado, note que esssa op\u00e7\u00e3o possui um novo menu onde podemos ativar ou n\u00e3o a suspens\u00e3o para RAM.","title":"Altera SOCFPGA family"},{"location":"Tutorial-HPS-Kernel/#symmetric-multi-processing","text":"Menu principal Kernel Features Note que j\u00e1 est\u00e1 selecioado: Symmmetric Multi-Processing Essa op\u00e7\u00e3o indica para o kernel que ele deve utilizar os dois cores presente no ARM HPS da FPGA.","title":"Symmetric Multi-Processing"},{"location":"Tutorial-HPS-Kernel/#device-drivers","text":"Menu principal Device Drivers Analise os drivers dispon\u00edveis... Indica quais drivers ser\u00e3o compilados junto com o kernel, note que j\u00e1 temos configurado drivers de rede (Network device support); GPIO (GPIO Support); RTC; DMA; ... . Lembre que j\u00e1 inicializamos o .config com uma configura\u00e7\u00e3o padr\u00e3o para SoCs Altera.","title":"Device Drivers"},{"location":"Tutorial-HPS-Kernel/#salvando","text":"Aperte ESC duas vezes ( <ESC> <ESC> ) e salve as configura\u00e7\u00f5es no arquivo .config","title":"Salvando"},{"location":"Tutorial-HPS-Kernel/#config","text":"Note De uma olhada no arquivo .config gerado! As vezes \u00e9 mais f\u00e1cil editar direto nele, do que ter que abrir o menu de configura\u00e7\u00e3o e encontrar o local de ativar um m\u00f3dulo.","title":".config"},{"location":"Tutorial-HPS-Kernel/#compilando","text":"O makefile utiliza a vari\u00e1vel CROSS_COMPILE para definir o toolchain que ir\u00e1 fazer a compila\u00e7\u00e3o do kernel, vamos definir como sendo o GCC do Linaro baixado recentemente: $ export CROSS_COMPILE = $GCC_Linaro /arm-linux-gnueabihf- Para compilarmos o kernel : make ARCH = arm LOCALVERSION = zImage -j 4 Note -j4 executa a compila\u00e7\u00e3o em 4 threads, voc\u00ea pode ajustar esse valor para adequar ao seu processador. Dica Adicione o export CROSS_COMPILE=.... ao seu .bashrc para n\u00e3o ter que ficar digitando isso sempre que tiver que compilar o kernel. Fail Caso aconte\u00e7a algum erro de build, deve-se verificar o path do CROSS_COMPILE ou se existe alguma depend\u00eancia que n\u00e3o foi satisfeita. Esse comando faz com que o kernel do linux seja compilado em uma vers\u00e3o compactada que \u00e9 auto-extra\u00edda. Outras op\u00e7\u00f5es seriam : Image : Bin\u00e1rio do kernel zImage: vers\u00e3o compactada que possui self-extracting uImage: uma vers\u00e3o que j\u00e1 possui o bootloader uboot 1^: https://stackoverflow.com/questions/22322304/image-vs-zimage-vs-uimage Kernel compilado o zImage \u00e9 salvo em: arch/arm/boot/zImage zImage Esse arquivo \u00e9 o bin\u00e1rio que cont\u00e9m o kernel do linux e ser\u00e1 executado no sistema embarcado. Atualizando o SDCARD Agora devemos atualizar o kernel que est\u00e1 no SDCard, para isso basta: inserir o sdcard no pc montar a parti\u00e7\u00e3o 1 substituir o zImage que est\u00e1 no SDCARD pelo o gerado dentro da pata arch/arm/boot/zImage ejetar o sdcard ou executar o comando sync coloque o SDCARD na placa e ligar a FPGA","title":"Compilando"},{"location":"Tutorial-HPS-Kernel/#executando","text":"Para verificar se tudo est\u00e1 certo, basta colocar o cart\u00e3o de mem\u00f3ria no kit e verificar a vers\u00e3o do kernel em execu\u00e7\u00e3o: $ uname -a Linux buildroot 4 .14.0 #1 SMP Mon Jul 16 21:22:58 -03 2018 armv7l GNU/Linux","title":"Executando"},{"location":"Tutorial-HPS-Kernel/#mouse-teclado","text":"Mouse e teclado funcionam de imediato? Tentei plugar um mouse USB na placa, ele \u00e9 reconhecido pelo Linux? N\u00e3o deveria. Para funcionar voc\u00ea deve voltar nas configura\u00e7\u00f5es do kernel do linux e inserir os drivers que gereciam USB e HID. Compilar, substituit o zImage no sdcard e testar novamente. Como verificar se o mouse est\u00e1 funcionando? Digite 'lsusb', ele deve mostrar que reconheceu um mouse Ap\u00f3s conectar o mouse, digite tail dmesg , ele deve mostrar que reconheceu um novo device USB e que associou ele com um mouse O mouse no linux \u00e9 montado em /dev/input/mice , para ver se est\u00e1 funcionando voc\u00ea pode executar: cat /dev/input/mice , mexa o mouse para ver se aparece alguma coisa na tela Human Interface Devices (HID) HID \u00e9 um tipo de dispositivo reconhecido pelo Kenel do Linux como um dispositivo de interface com o usu\u00e1rio, esse tipo de dispositivo \u00e9 normalmente reconhecido automaticamente pelos kernels, po\u00eds eles implementam um pad\u00e3o de comunica\u00e7\u00e3o. https://www.kernel.org/doc/html/latest/hid/index.html O USB tamb\u00e9m possui uma classifica\u00e7\u00e3o de dispositivos do tipo HID, que facilita o uso dos mesmos pelo kernel: https://en.wikipedia.org/wiki/USB_human_interface_device_class","title":"Mouse/ Teclado?"},{"location":"Tutorial-HPS-Linux/","text":"Tutorial-HPS-Embarcando \u00b6 O HPS espera um SDCARD formatado com o esquema a seguir para que o possa carregar o boot loader e depois o kernel: Esse roteiro n\u00e3o trata a fundo a cria\u00e7\u00e3o das parti\u00e7\u00f5es no SDCARD, que podem ser facilmente geradas com o fsdisk do Linux. Aqui iremos usar uma imagem padr\u00e3o que j\u00e1 possui a formata\u00e7\u00e3o e atualizar o SDCARD com o nosso uboot / kernel e filesystem. Imagem padr\u00e3o \u00b6 Utilizaremos uma imagem (.iso) j\u00e1 gerado com as especifica\u00e7\u00f5es e que j\u00e1 possui todo o sistema necess\u00e1rio para executar o linux no HPS (incluindo boot loader, kernel e filesystem): O conte\u00fado da imagem e como a mesma foi criada \u00e9 detalhado no p\u00e1gina (acesse para fazer o download da iso): SDcard img base . Para usar, basta fazer o download e salvar no SDCard. Note que no comando DD deve-se substituir o SeuDevice pelo caminho que o seu Linux atribuiu ao dispositivo. Para saber basta verificar o dmesg: $ dmesg | tail 4789 .207972 ] mmc0: new ultra high speed SDR50 SDHC card at address aaaa [ 4789 .211680 ] mmcblk0: mmc0:aaaa SL16G 14 .8 GiB [ 4789 .215857 ] mmcblk0: p1 p2 p3 [ 4988 .443942 ] mmcblk0: p1 p2 p3 Estamos interessados no: mmcblk0 . Agora vamos salvar a .iso no SDcard. Cuidado, se errar o dispositivo (of=/dev/mmcblk0) pode acontecer muitas coisas ruins $ sudo dd bs = 4M if = SDCardEmptyCycloneV of = /dev/mmcblk0 conv = fsync status = progress $ sync O sync \u00e9 necess\u00e1rio para que o kernel fa\u00e7a um flush do cashe escrevendo realmente no SDCard todos os dados que foram endere\u00e7ados a ele. Essa etapa pode ser um pouco demorada. Agora basta montar no seu linux o SDCard rec\u00e9m escrito e devemos ter duas parti\u00e7\u00f5es vis\u00edveis: 819,2 MiB: FAT32 Script de configura\u00e7\u00e3o do uboot; Kernel comprimido; Device Tree Blob file u-boot.scr; zImage; socfpga.dtb 1,0 GiB: Filesystem (/) E outra parti\u00e7\u00e3o que n\u00e3o \u00e9 vis\u00edvel (cont\u00e9m o preloader e o uboot), para visualizar : $ sudo fdisk -l /dev/mmcblk0 ... Device Boot Start End Sectors Size Id Type /dev/mmcblk0p1 2121728 3799448 1677721 819 ,2M b W95 FAT32 /dev/mmcblk0p2 14336 2111488 2097153 1G 83 Linux /dev/mmcblk0p3 2048 4096 2049 1M a2 unknown ... Note que a parti\u00e7\u00e3o 3 (mmcblk0p3) \u00e9 do tipo unknown (a2) e possui 1M de espa\u00e7o. \u00c9 nela que temos salvo o preloader e o uboot . Pr\u00f3ximos passo \u00b6 Se \u00e9 a primeira vez nesse tutorial siga direto para o Tutorial HPS BlinkLED . Atualizando os arquivos \u00b6 Para atualizar o SDCARD com a vers\u00e3o rec\u00e9m gerada siga os passo a seguir. Kernel \u00b6 Para atualizar o kernel basta montar a parti\u00e7\u00e3o 1 (819,2 M). No meu caso o path \u00e9 : /run/media/corsi/B0DA-B234/ e copiar o arquivo zImage para ela. Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. $ cp ~/work/HPS-Linux/zImage /run/media/corsi/B0DA-B234/ $ sync Quando fizer isso, ir\u00e1 reparar que a vers\u00e3o do kernel do Linux \u00e9 a que foi gerada na etapa de compila\u00e7\u00e3o do kernel. FileSystem \u00b6 Para insierirmos nosso fileSystem no SDCARD, primeiramente deve montar a parti\u00e7\u00e3o. no meu caso : /run/media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ . Uma vez montada, devemos primeiramente excluir os arquivos ali salvo (apagar o fileSystem antigo) e ent\u00e3o extrair o que foi gerado pelo buildrrot. # Limpando fs antigo $ sudo rm -r /run/media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync # Extraindo novo fs $ sudo tar xvf rootfs.tar -C /run/media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync uboot script e device tree \u00b6 $ cp ~/work/HPS-Linux/u-boot.scr /run/media/corsi/B0DA-B234/ $ cp ~/work/HPS-Linux/socfpga.dtb /run/media/corsi/B0DA-B234/ $ sync","title":"Tutorial-HPS-Embarcando"},{"location":"Tutorial-HPS-Linux/#tutorial-hps-embarcando","text":"O HPS espera um SDCARD formatado com o esquema a seguir para que o possa carregar o boot loader e depois o kernel: Esse roteiro n\u00e3o trata a fundo a cria\u00e7\u00e3o das parti\u00e7\u00f5es no SDCARD, que podem ser facilmente geradas com o fsdisk do Linux. Aqui iremos usar uma imagem padr\u00e3o que j\u00e1 possui a formata\u00e7\u00e3o e atualizar o SDCARD com o nosso uboot / kernel e filesystem.","title":"Tutorial-HPS-Embarcando"},{"location":"Tutorial-HPS-Linux/#imagem-padrao","text":"Utilizaremos uma imagem (.iso) j\u00e1 gerado com as especifica\u00e7\u00f5es e que j\u00e1 possui todo o sistema necess\u00e1rio para executar o linux no HPS (incluindo boot loader, kernel e filesystem): O conte\u00fado da imagem e como a mesma foi criada \u00e9 detalhado no p\u00e1gina (acesse para fazer o download da iso): SDcard img base . Para usar, basta fazer o download e salvar no SDCard. Note que no comando DD deve-se substituir o SeuDevice pelo caminho que o seu Linux atribuiu ao dispositivo. Para saber basta verificar o dmesg: $ dmesg | tail 4789 .207972 ] mmc0: new ultra high speed SDR50 SDHC card at address aaaa [ 4789 .211680 ] mmcblk0: mmc0:aaaa SL16G 14 .8 GiB [ 4789 .215857 ] mmcblk0: p1 p2 p3 [ 4988 .443942 ] mmcblk0: p1 p2 p3 Estamos interessados no: mmcblk0 . Agora vamos salvar a .iso no SDcard. Cuidado, se errar o dispositivo (of=/dev/mmcblk0) pode acontecer muitas coisas ruins $ sudo dd bs = 4M if = SDCardEmptyCycloneV of = /dev/mmcblk0 conv = fsync status = progress $ sync O sync \u00e9 necess\u00e1rio para que o kernel fa\u00e7a um flush do cashe escrevendo realmente no SDCard todos os dados que foram endere\u00e7ados a ele. Essa etapa pode ser um pouco demorada. Agora basta montar no seu linux o SDCard rec\u00e9m escrito e devemos ter duas parti\u00e7\u00f5es vis\u00edveis: 819,2 MiB: FAT32 Script de configura\u00e7\u00e3o do uboot; Kernel comprimido; Device Tree Blob file u-boot.scr; zImage; socfpga.dtb 1,0 GiB: Filesystem (/) E outra parti\u00e7\u00e3o que n\u00e3o \u00e9 vis\u00edvel (cont\u00e9m o preloader e o uboot), para visualizar : $ sudo fdisk -l /dev/mmcblk0 ... Device Boot Start End Sectors Size Id Type /dev/mmcblk0p1 2121728 3799448 1677721 819 ,2M b W95 FAT32 /dev/mmcblk0p2 14336 2111488 2097153 1G 83 Linux /dev/mmcblk0p3 2048 4096 2049 1M a2 unknown ... Note que a parti\u00e7\u00e3o 3 (mmcblk0p3) \u00e9 do tipo unknown (a2) e possui 1M de espa\u00e7o. \u00c9 nela que temos salvo o preloader e o uboot .","title":"Imagem padr\u00e3o"},{"location":"Tutorial-HPS-Linux/#proximos-passo","text":"Se \u00e9 a primeira vez nesse tutorial siga direto para o Tutorial HPS BlinkLED .","title":"Pr\u00f3ximos passo"},{"location":"Tutorial-HPS-Linux/#atualizando-os-arquivos","text":"Para atualizar o SDCARD com a vers\u00e3o rec\u00e9m gerada siga os passo a seguir.","title":"Atualizando os arquivos"},{"location":"Tutorial-HPS-Linux/#kernel","text":"Para atualizar o kernel basta montar a parti\u00e7\u00e3o 1 (819,2 M). No meu caso o path \u00e9 : /run/media/corsi/B0DA-B234/ e copiar o arquivo zImage para ela. Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. $ cp ~/work/HPS-Linux/zImage /run/media/corsi/B0DA-B234/ $ sync Quando fizer isso, ir\u00e1 reparar que a vers\u00e3o do kernel do Linux \u00e9 a que foi gerada na etapa de compila\u00e7\u00e3o do kernel.","title":"Kernel"},{"location":"Tutorial-HPS-Linux/#filesystem","text":"Para insierirmos nosso fileSystem no SDCARD, primeiramente deve montar a parti\u00e7\u00e3o. no meu caso : /run/media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ . Uma vez montada, devemos primeiramente excluir os arquivos ali salvo (apagar o fileSystem antigo) e ent\u00e3o extrair o que foi gerado pelo buildrrot. # Limpando fs antigo $ sudo rm -r /run/media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync # Extraindo novo fs $ sudo tar xvf rootfs.tar -C /run/media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync","title":"FileSystem"},{"location":"Tutorial-HPS-Linux/#uboot-script-e-device-tree","text":"$ cp ~/work/HPS-Linux/u-boot.scr /run/media/corsi/B0DA-B234/ $ cp ~/work/HPS-Linux/socfpga.dtb /run/media/corsi/B0DA-B234/ $ sync","title":"uboot script e device tree"},{"location":"Tutorial-HPS-Running/","text":"Tutorial 4 - HPS - Linux embarcado \u00b6 2020-2 Material atualizado. Danger Nesse tutorial mexemos com grava\u00e7\u00e3o de disco, se errar o dispositivo pode corromper seus arquivos!!! Vamos nessa etapa executar um linux de exemplo fornecido pela Terasic, para isso, ser\u00e1 necess\u00e1rio programarmos um SDcard com a imagem. Vamos executar os seguintes passos para isso: Download e gravar a Imagem da Teraisc ( .iso ) no SDcard Insira o SDCard na FPGA Conecte o USB na porta UART (perto da porta Ethernet) Conecte a alimenta\u00e7\u00e3o Conecte-se ao terminal via UART Executar comandos Come\u00e7ando \u00b6 Para seguir esse tutorial \u00e9 necess\u00e1rio: Hardware: DE10-Standard e SDCard Softwares: Quartus 18.01 Entrega no git : pasta Lab4_HPS_Infra Imagem padr\u00e3o (sdcard) \u00b6 Utilizaremos uma imagem ( .iso ) j\u00e1 gerada para o ARM da placa e que j\u00e1 possui todo o sistema necess\u00e1rio para executar o linux no HPS (incluindo boot loader, kernel e filesystem), essa imagem foi criada com a distribui\u00e7\u00e3o Linaro . Download Fa\u00e7a o download da imagem Linux Console (Kernel 4.5) do site da terasic: - \"Linux BSP (Board Support Package): MicroSD Card Image\" Extraia o arquio de10_standard_linux_console.img do arquivo zipado, esse .img \u00e9 uma c\u00f3pia bit a bit do que deve ser salvo no SDCard. Agora temos que copiar o img para o cart\u00e3o de mem\u00f3ria. Insira o cart\u00e3o de mem\u00f3ria no computador Use o adaptador fornecido. Quando inserirmos um disco externo no linux o mesmo o associa a um 'device' na pasta /dev/ , para sabermos qual o nome do device que foi atribu\u00eddo ao SDcard, podemos usar o comando dmesg , que exibe o log do sistema operacional e nele podemos ver qual foi o \u00faltimo hardware detectado e qual device foi atribu\u00eddo: Cuidado, estou assumindo que nenhum dispositivo foi inserido ap\u00f3s o SDcard $ dmesg | tail [ 4789 .207972 ] mmc0: new ultra high speed SDR50 SDHC card at address aaaa [ 4789 .211680 ] mmcblk0: mmc0:aaaa SL16G 14 .8 GiB [ 4789 .215857 ] mmcblk0: p1 p2 p3 [ 4988 .443942 ] mmcblk0: p1 p2 p3 O dmesg possui o log que o meu SDCARD foi alocado ao: /dev/mmclk0 , no seu linux pode ser outro nome! Warning Isso pode mudar de PC para PC! Agora vamos transferir a .iso para o SDcard (isso \u00e9 diferente de copiar o arquivo para o sdcard!) Danger Cuidado, se errar o dispositivo (no meu caso: of=/dev/mmcblk0 ) pode acontecer coisas muito ruins com os seus dados $ sudo dd bs = 4M if = de10_standard_linux_console.img of = DEVICE conv = fsync status = progress $ sync dd O comando dd executa uma c\u00f3pia bit a bit de um arquivo de entrada input file: if para um output file: of O comando sync \u00e9 necess\u00e1rio para que o kernel fa\u00e7a um flush do cache escrevendo realmente no SDCard todos os dados que foram endere\u00e7ados a ele. Essa etapa pode ser um pouco demorada. Agora basta montar no seu linux o SDCard rec\u00e9m escrito e devemos ter duas parti\u00e7\u00f5es vis\u00edveis: 524 MiB: FAT32 Script de configura\u00e7\u00e3o do uboot; Kernel comprimido; Device Tree Blob file u-boot.scr; zImage; socfpga.dtb 3,3 GiB: Filesystem ( / ) E outra parti\u00e7\u00e3o que n\u00e3o \u00e9 vis\u00edvel (cont\u00e9m o preloader e o uboot), para visualizar: $ sudo fdisk -l /dev/mmcblk0 ... Device Boot Start End Sectors Size Id Type /dev/mmcblk0p1 4096 1028095 1024000 500M b W95 FAT32 /dev/mmcblk0p2 1028096 7376895 6348800 3G 83 Linux /dev/mmcblk0p3 2048 4095 2048 1M a2 unknown ... Note que a parti\u00e7\u00e3o 3 (mmcblk0p3) \u00e9 do tipo unknown (a2) e possui 1M de espa\u00e7o. \u00c9 nela que temos salvo o preloader e o uboot . Success Agora remova o SDCard e o coloque na FPGA USB - UART \u00b6 A porta UART-to-USB \u00e9 um conector que possibilita acessar a sa\u00edda serial do HPS via porta serial. No linux o driver \u00e9 reconhecido automaticamente, no Windows ser\u00e1 necess\u00e1rio instalar manualmente o driver da serial.. Uma vez conectado no linux host, verificamos que o mesmo foi mapeado para um dispositivo do tipo serial (no meu caso com nome ttyUSB0 ): $ dmesg | tail .... [80473.426308] ftdi_sio 1-2:1.0: FTDI USB Serial Device converter detected [80473.426333] usb 1-2: Detected FT232RL [80473.426456] usb 1-2: FTDI USB Serial Device converter now attached to ttyUSB0 ... Warning Isso pode mudar de PC para PC! Para conectarmos nessa porta, precisamos usar um programa do tipo: emulador de terminal. No caso iremos utilizar o screen (verificar se possui instalado). Note que o comando a seguir deve ser modificado para o device ( /dev/ttyxxx ) na qual o seu linux associou a porta UsSB-Serial, extra\u00eddo do dmesg. $ screen /dev/ttyUSB0 115200 ,cs8 Tip Para sair do terminal: ctr + A : quit Tip Se voc\u00ea usa um editor (emacs/ vscode/ ...) procure por plugins que fazem a conex\u00e3o serial ( serial-term ), ai n\u00e3o precisa usar o screen . Linux \u00b6 Fa\u00e7a o loggin no linux: user: root pass: Legal! Vamos agora descobrir como criar programas para esse Linux!","title":"Tutorial 4 - HPS - Linux embarcado"},{"location":"Tutorial-HPS-Running/#tutorial-4-hps-linux-embarcado","text":"2020-2 Material atualizado. Danger Nesse tutorial mexemos com grava\u00e7\u00e3o de disco, se errar o dispositivo pode corromper seus arquivos!!! Vamos nessa etapa executar um linux de exemplo fornecido pela Terasic, para isso, ser\u00e1 necess\u00e1rio programarmos um SDcard com a imagem. Vamos executar os seguintes passos para isso: Download e gravar a Imagem da Teraisc ( .iso ) no SDcard Insira o SDCard na FPGA Conecte o USB na porta UART (perto da porta Ethernet) Conecte a alimenta\u00e7\u00e3o Conecte-se ao terminal via UART Executar comandos","title":"Tutorial 4 - HPS - Linux embarcado"},{"location":"Tutorial-HPS-Running/#comecando","text":"Para seguir esse tutorial \u00e9 necess\u00e1rio: Hardware: DE10-Standard e SDCard Softwares: Quartus 18.01 Entrega no git : pasta Lab4_HPS_Infra","title":"Come\u00e7ando"},{"location":"Tutorial-HPS-Running/#imagem-padrao-sdcard","text":"Utilizaremos uma imagem ( .iso ) j\u00e1 gerada para o ARM da placa e que j\u00e1 possui todo o sistema necess\u00e1rio para executar o linux no HPS (incluindo boot loader, kernel e filesystem), essa imagem foi criada com a distribui\u00e7\u00e3o Linaro . Download Fa\u00e7a o download da imagem Linux Console (Kernel 4.5) do site da terasic: - \"Linux BSP (Board Support Package): MicroSD Card Image\" Extraia o arquio de10_standard_linux_console.img do arquivo zipado, esse .img \u00e9 uma c\u00f3pia bit a bit do que deve ser salvo no SDCard. Agora temos que copiar o img para o cart\u00e3o de mem\u00f3ria. Insira o cart\u00e3o de mem\u00f3ria no computador Use o adaptador fornecido. Quando inserirmos um disco externo no linux o mesmo o associa a um 'device' na pasta /dev/ , para sabermos qual o nome do device que foi atribu\u00eddo ao SDcard, podemos usar o comando dmesg , que exibe o log do sistema operacional e nele podemos ver qual foi o \u00faltimo hardware detectado e qual device foi atribu\u00eddo: Cuidado, estou assumindo que nenhum dispositivo foi inserido ap\u00f3s o SDcard $ dmesg | tail [ 4789 .207972 ] mmc0: new ultra high speed SDR50 SDHC card at address aaaa [ 4789 .211680 ] mmcblk0: mmc0:aaaa SL16G 14 .8 GiB [ 4789 .215857 ] mmcblk0: p1 p2 p3 [ 4988 .443942 ] mmcblk0: p1 p2 p3 O dmesg possui o log que o meu SDCARD foi alocado ao: /dev/mmclk0 , no seu linux pode ser outro nome! Warning Isso pode mudar de PC para PC! Agora vamos transferir a .iso para o SDcard (isso \u00e9 diferente de copiar o arquivo para o sdcard!) Danger Cuidado, se errar o dispositivo (no meu caso: of=/dev/mmcblk0 ) pode acontecer coisas muito ruins com os seus dados $ sudo dd bs = 4M if = de10_standard_linux_console.img of = DEVICE conv = fsync status = progress $ sync dd O comando dd executa uma c\u00f3pia bit a bit de um arquivo de entrada input file: if para um output file: of O comando sync \u00e9 necess\u00e1rio para que o kernel fa\u00e7a um flush do cache escrevendo realmente no SDCard todos os dados que foram endere\u00e7ados a ele. Essa etapa pode ser um pouco demorada. Agora basta montar no seu linux o SDCard rec\u00e9m escrito e devemos ter duas parti\u00e7\u00f5es vis\u00edveis: 524 MiB: FAT32 Script de configura\u00e7\u00e3o do uboot; Kernel comprimido; Device Tree Blob file u-boot.scr; zImage; socfpga.dtb 3,3 GiB: Filesystem ( / ) E outra parti\u00e7\u00e3o que n\u00e3o \u00e9 vis\u00edvel (cont\u00e9m o preloader e o uboot), para visualizar: $ sudo fdisk -l /dev/mmcblk0 ... Device Boot Start End Sectors Size Id Type /dev/mmcblk0p1 4096 1028095 1024000 500M b W95 FAT32 /dev/mmcblk0p2 1028096 7376895 6348800 3G 83 Linux /dev/mmcblk0p3 2048 4095 2048 1M a2 unknown ... Note que a parti\u00e7\u00e3o 3 (mmcblk0p3) \u00e9 do tipo unknown (a2) e possui 1M de espa\u00e7o. \u00c9 nela que temos salvo o preloader e o uboot . Success Agora remova o SDCard e o coloque na FPGA","title":"Imagem padr\u00e3o (sdcard)"},{"location":"Tutorial-HPS-Running/#usb-uart","text":"A porta UART-to-USB \u00e9 um conector que possibilita acessar a sa\u00edda serial do HPS via porta serial. No linux o driver \u00e9 reconhecido automaticamente, no Windows ser\u00e1 necess\u00e1rio instalar manualmente o driver da serial.. Uma vez conectado no linux host, verificamos que o mesmo foi mapeado para um dispositivo do tipo serial (no meu caso com nome ttyUSB0 ): $ dmesg | tail .... [80473.426308] ftdi_sio 1-2:1.0: FTDI USB Serial Device converter detected [80473.426333] usb 1-2: Detected FT232RL [80473.426456] usb 1-2: FTDI USB Serial Device converter now attached to ttyUSB0 ... Warning Isso pode mudar de PC para PC! Para conectarmos nessa porta, precisamos usar um programa do tipo: emulador de terminal. No caso iremos utilizar o screen (verificar se possui instalado). Note que o comando a seguir deve ser modificado para o device ( /dev/ttyxxx ) na qual o seu linux associou a porta UsSB-Serial, extra\u00eddo do dmesg. $ screen /dev/ttyUSB0 115200 ,cs8 Tip Para sair do terminal: ctr + A : quit Tip Se voc\u00ea usa um editor (emacs/ vscode/ ...) procure por plugins que fazem a conex\u00e3o serial ( serial-term ), ai n\u00e3o precisa usar o screen .","title":"USB - UART"},{"location":"Tutorial-HPS-Running/#linux","text":"Fa\u00e7a o loggin no linux: user: root pass: Legal! Vamos agora descobrir como criar programas para esse Linux!","title":"Linux"},{"location":"Tutorial-HPS-SDcard/","text":"Atualizando o SDCARD \u00b6 Premissas Atualizando o preload \u00b6 TBD Atualizando o uboot \u00b6 TBD uboot script \u00b6 $ cp u-boot.scr /run/media/corsi/B0DA-B234/ Atualizando Kernel \u00b6 Para atualizar o kernel basta montar a parti\u00e7\u00e3o 1 (819,2 M). No meu caso o path \u00e9: /run/media/corsi/B0DA-B234/ e copiar o arquivo zImage para ela. O arquivo zImage fica localizado (dentro do reposit\u00f3rio do kernel) em: /arch/arm/boot/zImage Note Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. $ cp ~/work/linux/arch/arm/boot/zImage /run/media/corsi/B0DA-B234/ $ sync Quando fizer isso, ir\u00e1 reparar que a vers\u00e3o do kernel do Linux \u00e9 a que foi gerada na etapa de compila\u00e7\u00e3o do kernel. Atualizando o dts \u00b6 $ cp socfpga.dtb /run/media/corsi/B0DA-B234/ FileSystem \u00b6 Para insierirmos nosso fileSystem no SDCARD, primeiramente deve montar a parti\u00e7\u00e3o. no meu caso : /media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ . Uma vez montada, devemos primeiramente excluir os arquivos ali salvo (apagar o fileSystem antigo) e ent\u00e3o extrair o que foi gerado pelo buildroot. Warning Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. Danger Se errar, pode ser destrutivo (para seus arquivos) # Limpando fs antigo $ sudo rm -r /media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync # Extraindo novo fs $ sudo tar xvf rootfs.tar -C /media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync uboot script e device tree \u00b6","title":"Atualizando o SDCARD"},{"location":"Tutorial-HPS-SDcard/#atualizando-o-sdcard","text":"Premissas","title":"Atualizando o SDCARD"},{"location":"Tutorial-HPS-SDcard/#atualizando-o-preload","text":"TBD","title":"Atualizando o preload"},{"location":"Tutorial-HPS-SDcard/#atualizando-o-uboot","text":"TBD","title":"Atualizando o uboot"},{"location":"Tutorial-HPS-SDcard/#uboot-script","text":"$ cp u-boot.scr /run/media/corsi/B0DA-B234/","title":"uboot script"},{"location":"Tutorial-HPS-SDcard/#atualizando-kernel","text":"Para atualizar o kernel basta montar a parti\u00e7\u00e3o 1 (819,2 M). No meu caso o path \u00e9: /run/media/corsi/B0DA-B234/ e copiar o arquivo zImage para ela. O arquivo zImage fica localizado (dentro do reposit\u00f3rio do kernel) em: /arch/arm/boot/zImage Note Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. $ cp ~/work/linux/arch/arm/boot/zImage /run/media/corsi/B0DA-B234/ $ sync Quando fizer isso, ir\u00e1 reparar que a vers\u00e3o do kernel do Linux \u00e9 a que foi gerada na etapa de compila\u00e7\u00e3o do kernel.","title":"Atualizando Kernel"},{"location":"Tutorial-HPS-SDcard/#atualizando-o-dts","text":"$ cp socfpga.dtb /run/media/corsi/B0DA-B234/","title":"Atualizando o dts"},{"location":"Tutorial-HPS-SDcard/#filesystem","text":"Para insierirmos nosso fileSystem no SDCARD, primeiramente deve montar a parti\u00e7\u00e3o. no meu caso : /media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ . Uma vez montada, devemos primeiramente excluir os arquivos ali salvo (apagar o fileSystem antigo) e ent\u00e3o extrair o que foi gerado pelo buildroot. Warning Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. Danger Se errar, pode ser destrutivo (para seus arquivos) # Limpando fs antigo $ sudo rm -r /media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync # Extraindo novo fs $ sudo tar xvf rootfs.tar -C /media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync","title":"FileSystem"},{"location":"Tutorial-HPS-SDcard/#uboot-script-e-device-tree","text":"","title":"uboot script e device tree"},{"location":"Tutorial-HPS-kernel-chardriver/","text":"Char device driver \u00b6 Agora iremos criar um driver do tipo char, este m\u00f3dulo ir\u00e1 aparecer como um dispositivo no /dev/ , suportando que um programa no userspace interaja com ele. Syscall \u00b6 Lembre que no linux tudo \u00e9 um arquivo, inclusive um driver. Para ele se comportar como um arquivo devemos implementar no m\u00ednimo as as seguintes chamadas de sistema: open , close/release , read e write . Com isso, um programa no userspace poder\u00e1 interagir com o nosso driver. chamada de sistemas Um m\u00f3dulo do tipo char pode implementar outras chamadas de sistema, como definido no arquivo fs.h no reposit\u00f3rio do kernel: struct file_operations { struct module * owner ; loff_t ( * llseek ) ( struct file * , loff_t , int ); ssize_t ( * read ) ( struct file * , char __user * , size_t , loff_t * ); ssize_t ( * write ) ( struct file * , const char __user * , size_t , loff_t * ); ssize_t ( * read_iter ) ( struct kiocb * , struct iov_iter * ); ssize_t ( * write_iter ) ( struct kiocb * , struct iov_iter * ); int ( * iterate ) ( struct file * , struct dir_context * ); unsigned int ( * poll ) ( struct file * , struct poll_table_struct * ); long ( * unlocked_ioctl ) ( struct file * , unsigned int , unsigned long ); long ( * compat_ioctl ) ( struct file * , unsigned int , unsigned long ); int ( * mmap ) ( struct file * , struct vm_area_struct * ); int ( * open ) ( struct inode * , struct file * ); int ( * flush ) ( struct file * , fl_owner_t id ); int ( * release ) ( struct inode * , struct file * ); int ( * fsync ) ( struct file * , loff_t , loff_t , int datasync ); int ( * aio_fsync ) ( struct kiocb * , int datasync ); int ( * fasync ) ( int , struct file * , int ); int ( * lock ) ( struct file * , int , struct file_lock * ); ssize_t ( * sendpage ) ( struct file * , struct page * , int , size_t , loff_t * , int ); unsigned long ( * get_unmapped_area )( struct file * , unsigned long , unsigned long , unsigned long , unsigned long ); int ( * check_flags )( int ); int ( * flock ) ( struct file * , int , struct file_lock * ); ssize_t ( * splice_write )( struct pipe_inode_info * , struct file * , loff_t * , size_t , unsigned int ); ssize_t ( * splice_read )( struct file * , loff_t * , struct pipe_inode_info * , size_t , unsigned int ); int ( * setlease )( struct file * , long , struct file_lock ** , void ** ); long ( * fallocate )( struct file * file , int mode , loff_t offset , loff_t len ); void ( * show_fdinfo )( struct seq_file * m , struct file * f ); #ifndef CONFIG_MMU unsigned ( * mmap_capabilities )( struct file * ); #endif }; ebbchar \u00b6 O c\u00f3digo a seguir implementa um driver muito simples do tipo char, esse driver possui as opera\u00e7\u00f5es listadas no struct fops . Esse driver faz o seguinte: Ele imprime no log do sistema tudo o que for escrito nele e retornar para leitura a mesma string que foi escrito, isso \u00e9 feito salvando a mensagem na regi\u00e3o de mem\u00f3ria chamada de message (criada no init do m\u00f3dulo com kmalloc ). Toda vez que o driver for aberto por um programa ele incrementa um contador global e imprime no log do sistema esse valor. +-------+ <------| |----------------< | | | | | +-------+ test.c | | | users space -v--------------------------------^---------------------- | | kernel space | | | +------------------+ | | write| kmalloc |read | |----->-\\ ------- /-->---- | \\ | | / | | \\->|message|-> | | ---|--- | +---------|--------+ | ebbchar.c v demesg Tip N\u00e3o copie apenas, leia e entenda. Os c\u00f3digos fornecidos est\u00e3o s\u00e3o bem comentandos. Crie e inicialize com os c\u00f3digos a seguir, resultando em tr\u00eas arquivos: ebbchar.c , test.c e Makefile Makefile obj - m += ebbchar . o all : make - C / lib / modules / $ ( shell uname - r ) / build / M = $ ( PWD ) modules $ ( CC ) test . c - o test clean : make - C / lib / modules / $ ( shell uname - r ) / build / M = $ ( PWD ) clean rm test ebbchar.c /* * @file ebbchar.c * @author Derek Molloy * @date 7 April 2015 * @version 0.1 * @brief An introductory character driver to support the second article of my series on * Linux loadable kernel module (LKM) development. This module maps to /dev/ebbchar and * comes with a helper C program that can be run in Linux user space to communicate with * this the LKM. * @see http://www.derekmolloy.ie/ for a full description and follow-up descriptions. * * Corsi 20b: Modifiquei para usar kmalloc no lugar de de alocacao est\u00e1tica. * */ #include <linux/init.h> // Macros used to mark up functions e.g. __init __exit #include <linux/module.h> // Core header for loading LKMs into the kernel #include <linux/device.h> // Header to support the kernel Driver Model #include <linux/kernel.h> // Contains types, macros, functions for the kernel #include <linux/fs.h> // Header for the Linux file system support #include <linux/uaccess.h> // Required for the copy to user function #include <linux/slab.h> #define DEVICE_NAME \"ebbchar\" ///< The device will appear at /dev/ebbchar using this value #define CLASS_NAME \"ebb\" ///< The device class -- this is a character device driver MODULE_LICENSE ( \"GPL\" ); ///< The license type -- this affects available functionality MODULE_AUTHOR ( \"Derek Molloy\" ); ///< The author -- visible when you use modinfo MODULE_DESCRIPTION ( \"A simple Linux char driver for the BBB\" ); ///< The description -- see modinfo MODULE_VERSION ( \"0.1\" ); ///< A version number to inform users static int majorNumber ; ///< Stores the device number -- determined automatically static char * message ; ///< Memory for the string that is passed from userspace static short size_of_message ; ///< Used to remember the size of the string stored static int numberOpens = 0 ; ///< Counts the number of times the device is opened static struct class * ebbcharClass = NULL ; ///< The device-driver class struct pointer static struct device * ebbcharDevice = NULL ; ///< The device-driver device struct pointer // The prototype functions for the character driver -- must come before the struct definition static int dev_open ( struct inode * , struct file * ); static int dev_release ( struct inode * , struct file * ); static ssize_t dev_read ( struct file * , char * , size_t , loff_t * ); static ssize_t dev_write ( struct file * , const char * , size_t , loff_t * ); /** @brief Devices are represented as file structure in the kernel. The file_operations structure from * /linux/fs.h lists the callback functions that you wish to associated with your file operations * using a C99 syntax structure. char devices usually implement open, read, write and release calls */ static struct file_operations fops = { . open = dev_open , . read = dev_read , . write = dev_write , . release = dev_release , }; /** @brief The LKM initialization function * The static keyword restricts the visibility of the function to within this C file. The __init * macro means that for a built-in driver (not a LKM) the function is only used at initialization * time and that it can be discarded and its memory freed up after that point. * @return returns 0 if successful */ static int __init ebbchar_init ( void ){ printk ( KERN_INFO \"EBBChar: Initializing the EBBChar LKM \\n \" ); // Try to dynamically allocate a major number for the device -- more difficult but worth it majorNumber = register_chrdev ( 0 , DEVICE_NAME , & fops ); if ( majorNumber < 0 ){ printk ( KERN_ALERT \"EBBChar failed to register a major number \\n \" ); return majorNumber ; } printk ( KERN_INFO \"EBBChar: registered correctly with major number %d \\n \" , majorNumber ); // Register the device class ebbcharClass = class_create ( THIS_MODULE , CLASS_NAME ); if ( IS_ERR ( ebbcharClass )){ // Check for error and clean up if there is unregister_chrdev ( majorNumber , DEVICE_NAME ); printk ( KERN_ALERT \"Failed to register device class \\n \" ); return PTR_ERR ( ebbcharClass ); // Correct way to return an error on a pointer } printk ( KERN_INFO \"EBBChar: device class registered correctly \\n \" ); // Register the device driver ebbcharDevice = device_create ( ebbcharClass , NULL , MKDEV ( majorNumber , 0 ), NULL , DEVICE_NAME ); if ( IS_ERR ( ebbcharDevice )){ // Clean up if there is an error class_destroy ( ebbcharClass ); // Repeated code but the alternative is goto statements unregister_chrdev ( majorNumber , DEVICE_NAME ); printk ( KERN_ALERT \"Failed to create the device \\n \" ); return PTR_ERR ( ebbcharDevice ); } // alocate mem message = kmalloc ( 32 , GFP_KERNEL ); if ( IS_ERR ( message )){ printk ( KERN_INFO \"Failed to allocate mem \\n \" ); return PTR_ERR ( message ); } printk ( KERN_INFO \"EBBChar: device class created correctly \\n \" ); // Made it! device was initialized return 0 ; } /** @brief The LKM cleanup function * Similar to the initialization function, it is static. The __exit macro notifies that if this * code is used for a built-in driver (not a LKM) that this function is not required. */ static void __exit ebbchar_exit ( void ){ device_destroy ( ebbcharClass , MKDEV ( majorNumber , 0 )); // remove the device class_unregister ( ebbcharClass ); // unregister the device class class_destroy ( ebbcharClass ); // remove the device class unregister_chrdev ( majorNumber , DEVICE_NAME ); // unregister the major number kfree ( message ); // release memmory printk ( KERN_INFO \"EBBChar: Goodbye from the LKM! \\n \" ); } /** @brief The device open function that is called each time the device is opened * This will only increment the numberOpens counter in this case. * @param inodep A pointer to an inode object (defined in linux/fs.h) * @param filep A pointer to a file object (defined in linux/fs.h) */ static int dev_open ( struct inode * inodep , struct file * filep ){ numberOpens ++ ; printk ( KERN_INFO \"EBBChar: Device has been opened %d time(s) \\n \" , numberOpens ); return 0 ; } /** @brief This function is called whenever device is being read from user space i.e. data is * being sent from the device to the user. In this case is uses the copy_to_user() function to * send the buffer string to the user and captures any errors. * @param filep A pointer to a file object (defined in linux/fs.h) * @param buffer The pointer to the buffer to which this function writes the data * @param len The length of the b * @param offset The offset if required */ static ssize_t dev_read ( struct file * filep , char * buffer , size_t len , loff_t * offset ){ int error_count = 0 ; // copy_to_user has the format ( * to, *from, size) and returns 0 on success error_count = copy_to_user ( buffer , message , size_of_message ); if ( error_count == 0 ){ // if true then have success printk ( KERN_INFO \"EBBChar: Sent %d characters to the user \\n \" , size_of_message ); return ( size_of_message = 0 ); // clear the position to the start and return 0 } else { printk ( KERN_INFO \"EBBChar: Failed to send %d characters to the user \\n \" , error_count ); return - EFAULT ; // Failed -- return a bad address message (i.e. -14) } } /** @brief This function is called whenever the device is being written to from user space i.e. * data is sent to the device from the user. The data is copied to the message[] array in this * LKM using the sprintf() function along with the length of the string. * @param filep A pointer to a file object * @param buffer The buffer to that contains the string to write to the device * aaaaaaa @param len The length of the array of data that is being passed in the const char buffer * @param offset The offset if required */ static ssize_t dev_write ( struct file * filep , const char * buffer , size_t len , loff_t * offset ){ copy_from_user ( message , buffer , len ); size_of_message = len ; // store the length of the stored message printk ( KERN_INFO \"EBBChar: Received %zu characters from the user \\n \" , len ); return len ; } /** @brieaf The device release function that is called whenever the device is closed/released by * the userspace program * @param inodep A pointer to an inode object (defined in linux/fs.h) * @param filep A pointer to a file object (defined in linux/fs.h) */ static int dev_release ( struct inode * inodep , struct file * filep ){ printk ( KERN_INFO \"EBBChar: Device successfully closed \\n \" ); return 0 ; } /** @brief A module must use the module_init() module_exit() macros from linux/init.h, which * identify the initialization function at insertion time and the cleanup function (as * listed above) */ module_init ( ebbchar_init ); module_exit ( ebbchar_exit ); test.c /** * @file testebbchar.c * @author Derek Molloy * @date 7 April 2015 * @version 0.1 * @brief A Linux user space program that communicates with the ebbchar.c LKM. It passes a * string to the LKM and reads the response from the LKM. For this example to work the device * must be called /dev/ebbchar. * @see http://www.derekmolloy.ie/ for a full description and follow-up descriptions. */ #include <stdio.h> #include <stdlib.h> #include <errno.h> #include <fcntl.h> #include <string.h> #include <unistd.h> #define BUFFER_LENGTH 256 ///< The buffer length (crude but fine) static char receive [ BUFFER_LENGTH ]; ///< The receive buffer from the LKM int main (){ int ret , fd ; char stringToSend [ BUFFER_LENGTH ]; printf ( \"Starting device test code example... \\n \" ); fd = open ( \"/dev/ebbchar\" , O_RDWR ); // Open the device with read/write access if ( fd < 0 ){ perror ( \"Failed to open the device...\" ); return errno ; } while ( 1 ){ printf ( \"Type in a short string to send to the kernel module: \\n \" ); scanf ( \"%[^ \\n ]%*c\" , stringToSend ); // Read in a string (with spaces) printf ( \"Writing message to the device [%s]. \\n \" , stringToSend ); ret = write ( fd , stringToSend , strlen ( stringToSend )); // Send the string to the LKM if ( ret < 0 ){ perror ( \"Failed to write the message to the device.\" ); return errno ; } //printf(\"Press ENTER to read back from the device...\\n\"); //getchar(); printf ( \"Reading from the device... \\n \" ); ret = read ( fd , receive , BUFFER_LENGTH ); // Read the response from the LKM if ( ret < 0 ){ perror ( \"Failed to read the message fm the device.\" ); return errno ; } printf ( \"The received message is: [%s] \\n \" , receive ); } printf ( \"End of the program \\n \" ); close ( fd ); return 0 ; } Vamos analisar algumas partes desse c\u00f3digo: ebbchar_iniat : \u00e9 chamado sempre que o driver for inserido no kernel ( insmod ) e faz o registro do m\u00f3dulo coamo device no /dev/eebchar . Nessa etapa o driver aloca uma mem\u00f3ria para uso interno pelo comando kmalloc // alocate mem message = kmalloc ( 32 , GFP_KERNEL ); if ( IS_ERR ( message )){ printk ( KERN_INFO \"Failed to allocate mem \\n \" ); return PTR_ERR ( message ); } ebbchar_exit : \u00e9 chamada quando o driver for removido do kernel ( rmmod ), e remove o device do /dev/ebbchar , libera a mem\u00f3ria que foi alocada anteriormente ( kfree ). A fun\u00e7\u00e3o dev_open \u00e9 chamada sempre que um programa abrir o device como um arquivo, sempre que isso acontece uma vari\u00e1vel global ( numberOpens ) \u00e9 incrementada e um log KERN_INFO gerado. dev_write : \u00e9 chamado sempre que acontece uma escrita no driver, quando isso acontece a mensagem que foi passada no comando de write no programa do userspace \u00e9 copiada para a regi\u00e3o de mem\u00f3ria message : static ssize_t dev_write ( struct file * filep , const char * buffer , size_t len , loff_t * offset ){ copy_from_user ( message , buffer , len ); ... dev_read : \u00e9 chamada quando acontece uma opera\u00e7\u00e3o de leitura no driver, o m\u00f3dulo retorna a mensagem salva no buffer message : static ssize_t dev_read ( struct file * filep , char * buffer , size_t len , loff_t * offset ){ int error_count = 0 ; // copy_to_user has the format ( * to, *from, size) and returns 0 on success error_count = copy_to_user ( buffer , message , size_of_message ); ... Testando \u00b6 Para testar basta compilar o m\u00f3dulo e o programa de teste com o comando make , uma vez compilado voc\u00ea deve carregar o m\u00f3dulo (verificar se ele inicializou corretamente) e ent\u00e3o executar o programa de teste. Em um terminal execute o comando dmesg -wH . Em outro terminal execute: make sudo insmod ebbchar.ko Voc\u00ea deve obter o log a seguir no terminal do dmesg: [12944.610531] EBBChar: Initializing the EBBChar LKM [12944.610537] EBBChar: registered correctly with major number 236 [12944.610577] EBBChar: device class registered correctly [12944.613972] EBBChar: device class created correctly verificando se device foi inserido corretamente: ls /dev/ebbchar (deve ter esse arquivo) agora vamos inicializar o programa sudo ./test note que o dmesg indicou que algu\u00e9m abriu o nosso driver: [nov 3 13:07] EBBChar: Device has been opened 1 time(s) agora no terminal que executou o programa test, escreva alguma coisa, voc\u00ea ir\u00e1 notar que a mesma informa\u00e7\u00e3o ser\u00e1 imprimida de volta: Type in a short string to send to the kernel module: 123 Writing message to the device [123]. Reading from the device... The received message is: [123] 1. No dmesg aparece a informa\u00e7\u00e3o de quantos bytes o usu\u00e1rio digitou. Info Experimente voc\u00ea escrever uma mensagem grande no terminal do programa test, o que acontece? Porque isso acontece? Pronto! acabamos de criar nosso primeiro device driver, ele ainda n\u00e3o controla nenhum hardware, mas j\u00e1 implementamos a interface com o sistema operacional. Agora vem a parte que mais dominamos, controlar hardware (criar ponteiro, configurar e escrever).","title":"Char device driver"},{"location":"Tutorial-HPS-kernel-chardriver/#char-device-driver","text":"Agora iremos criar um driver do tipo char, este m\u00f3dulo ir\u00e1 aparecer como um dispositivo no /dev/ , suportando que um programa no userspace interaja com ele.","title":"Char device driver"},{"location":"Tutorial-HPS-kernel-chardriver/#syscall","text":"Lembre que no linux tudo \u00e9 um arquivo, inclusive um driver. Para ele se comportar como um arquivo devemos implementar no m\u00ednimo as as seguintes chamadas de sistema: open , close/release , read e write . Com isso, um programa no userspace poder\u00e1 interagir com o nosso driver. chamada de sistemas Um m\u00f3dulo do tipo char pode implementar outras chamadas de sistema, como definido no arquivo fs.h no reposit\u00f3rio do kernel: struct file_operations { struct module * owner ; loff_t ( * llseek ) ( struct file * , loff_t , int ); ssize_t ( * read ) ( struct file * , char __user * , size_t , loff_t * ); ssize_t ( * write ) ( struct file * , const char __user * , size_t , loff_t * ); ssize_t ( * read_iter ) ( struct kiocb * , struct iov_iter * ); ssize_t ( * write_iter ) ( struct kiocb * , struct iov_iter * ); int ( * iterate ) ( struct file * , struct dir_context * ); unsigned int ( * poll ) ( struct file * , struct poll_table_struct * ); long ( * unlocked_ioctl ) ( struct file * , unsigned int , unsigned long ); long ( * compat_ioctl ) ( struct file * , unsigned int , unsigned long ); int ( * mmap ) ( struct file * , struct vm_area_struct * ); int ( * open ) ( struct inode * , struct file * ); int ( * flush ) ( struct file * , fl_owner_t id ); int ( * release ) ( struct inode * , struct file * ); int ( * fsync ) ( struct file * , loff_t , loff_t , int datasync ); int ( * aio_fsync ) ( struct kiocb * , int datasync ); int ( * fasync ) ( int , struct file * , int ); int ( * lock ) ( struct file * , int , struct file_lock * ); ssize_t ( * sendpage ) ( struct file * , struct page * , int , size_t , loff_t * , int ); unsigned long ( * get_unmapped_area )( struct file * , unsigned long , unsigned long , unsigned long , unsigned long ); int ( * check_flags )( int ); int ( * flock ) ( struct file * , int , struct file_lock * ); ssize_t ( * splice_write )( struct pipe_inode_info * , struct file * , loff_t * , size_t , unsigned int ); ssize_t ( * splice_read )( struct file * , loff_t * , struct pipe_inode_info * , size_t , unsigned int ); int ( * setlease )( struct file * , long , struct file_lock ** , void ** ); long ( * fallocate )( struct file * file , int mode , loff_t offset , loff_t len ); void ( * show_fdinfo )( struct seq_file * m , struct file * f ); #ifndef CONFIG_MMU unsigned ( * mmap_capabilities )( struct file * ); #endif };","title":"Syscall"},{"location":"Tutorial-HPS-kernel-chardriver/#ebbchar","text":"O c\u00f3digo a seguir implementa um driver muito simples do tipo char, esse driver possui as opera\u00e7\u00f5es listadas no struct fops . Esse driver faz o seguinte: Ele imprime no log do sistema tudo o que for escrito nele e retornar para leitura a mesma string que foi escrito, isso \u00e9 feito salvando a mensagem na regi\u00e3o de mem\u00f3ria chamada de message (criada no init do m\u00f3dulo com kmalloc ). Toda vez que o driver for aberto por um programa ele incrementa um contador global e imprime no log do sistema esse valor. +-------+ <------| |----------------< | | | | | +-------+ test.c | | | users space -v--------------------------------^---------------------- | | kernel space | | | +------------------+ | | write| kmalloc |read | |----->-\\ ------- /-->---- | \\ | | / | | \\->|message|-> | | ---|--- | +---------|--------+ | ebbchar.c v demesg Tip N\u00e3o copie apenas, leia e entenda. Os c\u00f3digos fornecidos est\u00e3o s\u00e3o bem comentandos. Crie e inicialize com os c\u00f3digos a seguir, resultando em tr\u00eas arquivos: ebbchar.c , test.c e Makefile Makefile obj - m += ebbchar . o all : make - C / lib / modules / $ ( shell uname - r ) / build / M = $ ( PWD ) modules $ ( CC ) test . c - o test clean : make - C / lib / modules / $ ( shell uname - r ) / build / M = $ ( PWD ) clean rm test ebbchar.c /* * @file ebbchar.c * @author Derek Molloy * @date 7 April 2015 * @version 0.1 * @brief An introductory character driver to support the second article of my series on * Linux loadable kernel module (LKM) development. This module maps to /dev/ebbchar and * comes with a helper C program that can be run in Linux user space to communicate with * this the LKM. * @see http://www.derekmolloy.ie/ for a full description and follow-up descriptions. * * Corsi 20b: Modifiquei para usar kmalloc no lugar de de alocacao est\u00e1tica. * */ #include <linux/init.h> // Macros used to mark up functions e.g. __init __exit #include <linux/module.h> // Core header for loading LKMs into the kernel #include <linux/device.h> // Header to support the kernel Driver Model #include <linux/kernel.h> // Contains types, macros, functions for the kernel #include <linux/fs.h> // Header for the Linux file system support #include <linux/uaccess.h> // Required for the copy to user function #include <linux/slab.h> #define DEVICE_NAME \"ebbchar\" ///< The device will appear at /dev/ebbchar using this value #define CLASS_NAME \"ebb\" ///< The device class -- this is a character device driver MODULE_LICENSE ( \"GPL\" ); ///< The license type -- this affects available functionality MODULE_AUTHOR ( \"Derek Molloy\" ); ///< The author -- visible when you use modinfo MODULE_DESCRIPTION ( \"A simple Linux char driver for the BBB\" ); ///< The description -- see modinfo MODULE_VERSION ( \"0.1\" ); ///< A version number to inform users static int majorNumber ; ///< Stores the device number -- determined automatically static char * message ; ///< Memory for the string that is passed from userspace static short size_of_message ; ///< Used to remember the size of the string stored static int numberOpens = 0 ; ///< Counts the number of times the device is opened static struct class * ebbcharClass = NULL ; ///< The device-driver class struct pointer static struct device * ebbcharDevice = NULL ; ///< The device-driver device struct pointer // The prototype functions for the character driver -- must come before the struct definition static int dev_open ( struct inode * , struct file * ); static int dev_release ( struct inode * , struct file * ); static ssize_t dev_read ( struct file * , char * , size_t , loff_t * ); static ssize_t dev_write ( struct file * , const char * , size_t , loff_t * ); /** @brief Devices are represented as file structure in the kernel. The file_operations structure from * /linux/fs.h lists the callback functions that you wish to associated with your file operations * using a C99 syntax structure. char devices usually implement open, read, write and release calls */ static struct file_operations fops = { . open = dev_open , . read = dev_read , . write = dev_write , . release = dev_release , }; /** @brief The LKM initialization function * The static keyword restricts the visibility of the function to within this C file. The __init * macro means that for a built-in driver (not a LKM) the function is only used at initialization * time and that it can be discarded and its memory freed up after that point. * @return returns 0 if successful */ static int __init ebbchar_init ( void ){ printk ( KERN_INFO \"EBBChar: Initializing the EBBChar LKM \\n \" ); // Try to dynamically allocate a major number for the device -- more difficult but worth it majorNumber = register_chrdev ( 0 , DEVICE_NAME , & fops ); if ( majorNumber < 0 ){ printk ( KERN_ALERT \"EBBChar failed to register a major number \\n \" ); return majorNumber ; } printk ( KERN_INFO \"EBBChar: registered correctly with major number %d \\n \" , majorNumber ); // Register the device class ebbcharClass = class_create ( THIS_MODULE , CLASS_NAME ); if ( IS_ERR ( ebbcharClass )){ // Check for error and clean up if there is unregister_chrdev ( majorNumber , DEVICE_NAME ); printk ( KERN_ALERT \"Failed to register device class \\n \" ); return PTR_ERR ( ebbcharClass ); // Correct way to return an error on a pointer } printk ( KERN_INFO \"EBBChar: device class registered correctly \\n \" ); // Register the device driver ebbcharDevice = device_create ( ebbcharClass , NULL , MKDEV ( majorNumber , 0 ), NULL , DEVICE_NAME ); if ( IS_ERR ( ebbcharDevice )){ // Clean up if there is an error class_destroy ( ebbcharClass ); // Repeated code but the alternative is goto statements unregister_chrdev ( majorNumber , DEVICE_NAME ); printk ( KERN_ALERT \"Failed to create the device \\n \" ); return PTR_ERR ( ebbcharDevice ); } // alocate mem message = kmalloc ( 32 , GFP_KERNEL ); if ( IS_ERR ( message )){ printk ( KERN_INFO \"Failed to allocate mem \\n \" ); return PTR_ERR ( message ); } printk ( KERN_INFO \"EBBChar: device class created correctly \\n \" ); // Made it! device was initialized return 0 ; } /** @brief The LKM cleanup function * Similar to the initialization function, it is static. The __exit macro notifies that if this * code is used for a built-in driver (not a LKM) that this function is not required. */ static void __exit ebbchar_exit ( void ){ device_destroy ( ebbcharClass , MKDEV ( majorNumber , 0 )); // remove the device class_unregister ( ebbcharClass ); // unregister the device class class_destroy ( ebbcharClass ); // remove the device class unregister_chrdev ( majorNumber , DEVICE_NAME ); // unregister the major number kfree ( message ); // release memmory printk ( KERN_INFO \"EBBChar: Goodbye from the LKM! \\n \" ); } /** @brief The device open function that is called each time the device is opened * This will only increment the numberOpens counter in this case. * @param inodep A pointer to an inode object (defined in linux/fs.h) * @param filep A pointer to a file object (defined in linux/fs.h) */ static int dev_open ( struct inode * inodep , struct file * filep ){ numberOpens ++ ; printk ( KERN_INFO \"EBBChar: Device has been opened %d time(s) \\n \" , numberOpens ); return 0 ; } /** @brief This function is called whenever device is being read from user space i.e. data is * being sent from the device to the user. In this case is uses the copy_to_user() function to * send the buffer string to the user and captures any errors. * @param filep A pointer to a file object (defined in linux/fs.h) * @param buffer The pointer to the buffer to which this function writes the data * @param len The length of the b * @param offset The offset if required */ static ssize_t dev_read ( struct file * filep , char * buffer , size_t len , loff_t * offset ){ int error_count = 0 ; // copy_to_user has the format ( * to, *from, size) and returns 0 on success error_count = copy_to_user ( buffer , message , size_of_message ); if ( error_count == 0 ){ // if true then have success printk ( KERN_INFO \"EBBChar: Sent %d characters to the user \\n \" , size_of_message ); return ( size_of_message = 0 ); // clear the position to the start and return 0 } else { printk ( KERN_INFO \"EBBChar: Failed to send %d characters to the user \\n \" , error_count ); return - EFAULT ; // Failed -- return a bad address message (i.e. -14) } } /** @brief This function is called whenever the device is being written to from user space i.e. * data is sent to the device from the user. The data is copied to the message[] array in this * LKM using the sprintf() function along with the length of the string. * @param filep A pointer to a file object * @param buffer The buffer to that contains the string to write to the device * aaaaaaa @param len The length of the array of data that is being passed in the const char buffer * @param offset The offset if required */ static ssize_t dev_write ( struct file * filep , const char * buffer , size_t len , loff_t * offset ){ copy_from_user ( message , buffer , len ); size_of_message = len ; // store the length of the stored message printk ( KERN_INFO \"EBBChar: Received %zu characters from the user \\n \" , len ); return len ; } /** @brieaf The device release function that is called whenever the device is closed/released by * the userspace program * @param inodep A pointer to an inode object (defined in linux/fs.h) * @param filep A pointer to a file object (defined in linux/fs.h) */ static int dev_release ( struct inode * inodep , struct file * filep ){ printk ( KERN_INFO \"EBBChar: Device successfully closed \\n \" ); return 0 ; } /** @brief A module must use the module_init() module_exit() macros from linux/init.h, which * identify the initialization function at insertion time and the cleanup function (as * listed above) */ module_init ( ebbchar_init ); module_exit ( ebbchar_exit ); test.c /** * @file testebbchar.c * @author Derek Molloy * @date 7 April 2015 * @version 0.1 * @brief A Linux user space program that communicates with the ebbchar.c LKM. It passes a * string to the LKM and reads the response from the LKM. For this example to work the device * must be called /dev/ebbchar. * @see http://www.derekmolloy.ie/ for a full description and follow-up descriptions. */ #include <stdio.h> #include <stdlib.h> #include <errno.h> #include <fcntl.h> #include <string.h> #include <unistd.h> #define BUFFER_LENGTH 256 ///< The buffer length (crude but fine) static char receive [ BUFFER_LENGTH ]; ///< The receive buffer from the LKM int main (){ int ret , fd ; char stringToSend [ BUFFER_LENGTH ]; printf ( \"Starting device test code example... \\n \" ); fd = open ( \"/dev/ebbchar\" , O_RDWR ); // Open the device with read/write access if ( fd < 0 ){ perror ( \"Failed to open the device...\" ); return errno ; } while ( 1 ){ printf ( \"Type in a short string to send to the kernel module: \\n \" ); scanf ( \"%[^ \\n ]%*c\" , stringToSend ); // Read in a string (with spaces) printf ( \"Writing message to the device [%s]. \\n \" , stringToSend ); ret = write ( fd , stringToSend , strlen ( stringToSend )); // Send the string to the LKM if ( ret < 0 ){ perror ( \"Failed to write the message to the device.\" ); return errno ; } //printf(\"Press ENTER to read back from the device...\\n\"); //getchar(); printf ( \"Reading from the device... \\n \" ); ret = read ( fd , receive , BUFFER_LENGTH ); // Read the response from the LKM if ( ret < 0 ){ perror ( \"Failed to read the message fm the device.\" ); return errno ; } printf ( \"The received message is: [%s] \\n \" , receive ); } printf ( \"End of the program \\n \" ); close ( fd ); return 0 ; } Vamos analisar algumas partes desse c\u00f3digo: ebbchar_iniat : \u00e9 chamado sempre que o driver for inserido no kernel ( insmod ) e faz o registro do m\u00f3dulo coamo device no /dev/eebchar . Nessa etapa o driver aloca uma mem\u00f3ria para uso interno pelo comando kmalloc // alocate mem message = kmalloc ( 32 , GFP_KERNEL ); if ( IS_ERR ( message )){ printk ( KERN_INFO \"Failed to allocate mem \\n \" ); return PTR_ERR ( message ); } ebbchar_exit : \u00e9 chamada quando o driver for removido do kernel ( rmmod ), e remove o device do /dev/ebbchar , libera a mem\u00f3ria que foi alocada anteriormente ( kfree ). A fun\u00e7\u00e3o dev_open \u00e9 chamada sempre que um programa abrir o device como um arquivo, sempre que isso acontece uma vari\u00e1vel global ( numberOpens ) \u00e9 incrementada e um log KERN_INFO gerado. dev_write : \u00e9 chamado sempre que acontece uma escrita no driver, quando isso acontece a mensagem que foi passada no comando de write no programa do userspace \u00e9 copiada para a regi\u00e3o de mem\u00f3ria message : static ssize_t dev_write ( struct file * filep , const char * buffer , size_t len , loff_t * offset ){ copy_from_user ( message , buffer , len ); ... dev_read : \u00e9 chamada quando acontece uma opera\u00e7\u00e3o de leitura no driver, o m\u00f3dulo retorna a mensagem salva no buffer message : static ssize_t dev_read ( struct file * filep , char * buffer , size_t len , loff_t * offset ){ int error_count = 0 ; // copy_to_user has the format ( * to, *from, size) and returns 0 on success error_count = copy_to_user ( buffer , message , size_of_message ); ...","title":"ebbchar"},{"location":"Tutorial-HPS-kernel-chardriver/#testando","text":"Para testar basta compilar o m\u00f3dulo e o programa de teste com o comando make , uma vez compilado voc\u00ea deve carregar o m\u00f3dulo (verificar se ele inicializou corretamente) e ent\u00e3o executar o programa de teste. Em um terminal execute o comando dmesg -wH . Em outro terminal execute: make sudo insmod ebbchar.ko Voc\u00ea deve obter o log a seguir no terminal do dmesg: [12944.610531] EBBChar: Initializing the EBBChar LKM [12944.610537] EBBChar: registered correctly with major number 236 [12944.610577] EBBChar: device class registered correctly [12944.613972] EBBChar: device class created correctly verificando se device foi inserido corretamente: ls /dev/ebbchar (deve ter esse arquivo) agora vamos inicializar o programa sudo ./test note que o dmesg indicou que algu\u00e9m abriu o nosso driver: [nov 3 13:07] EBBChar: Device has been opened 1 time(s) agora no terminal que executou o programa test, escreva alguma coisa, voc\u00ea ir\u00e1 notar que a mesma informa\u00e7\u00e3o ser\u00e1 imprimida de volta: Type in a short string to send to the kernel module: 123 Writing message to the device [123]. Reading from the device... The received message is: [123] 1. No dmesg aparece a informa\u00e7\u00e3o de quantos bytes o usu\u00e1rio digitou. Info Experimente voc\u00ea escrever uma mensagem grande no terminal do programa test, o que acontece? Porque isso acontece? Pronto! acabamos de criar nosso primeiro device driver, ele ainda n\u00e3o controla nenhum hardware, mas j\u00e1 implementamos a interface com o sistema operacional. Agora vem a parte que mais dominamos, controlar hardware (criar ponteiro, configurar e escrever).","title":"Testando"},{"location":"Tutorial-HPS-kernel-module/","text":"Kernel module \u00b6 Nesse tutorial iremos trabalhar com o b\u00e1sico do desenvolvimento de m\u00f3dulos para o kernel do linux. Simple module \u00b6 Tip Antes de come\u00e7ar instale: apt-get install build-essential linux-headers-`uname -r` Note Trabalhe dentro de uma pasta chamada simple_module . Crie um arquivo simple.c e inicialize com o c\u00f3digo a seguir: // simple.c // https://tldp.org/LDP/lkmpg/2.6/html/x121.html #include <linux/kernel.h> #include <linux/init.h> #include <linux/module.h> MODULE_DESCRIPTION ( \"My kernel module\" ); MODULE_AUTHOR ( \"Me\" ); MODULE_LICENSE ( \"GPL\" ); static int simple_init ( void ) { printk ( KERN_INFO \"HELLO, WORLD \\n \" ); return 0 ; } static void simple_exit ( void ) { printk ( KERN_INFO \"GOODBYE, WORLD \\n \" ); } module_init ( simple_init ); module_exit ( simple_exit ); Pronto! Este \u00e9 um m\u00f3dulo que pode ser lincado no kernel do Linux em tempo de execu\u00e7\u00e3o e altera o seu funcionamento (na verdade n\u00e3o faz nada). Vamos entender algumas coisas: Todo m\u00f3dulo deve ter uma fun\u00e7\u00e3o de inicializa\u00e7\u00e3o e sa\u00edda, essas fun\u00e7\u00f5es podem ter qualquer nome, mas devem ser informadas ao kernel pelas macros module_init() e module_exit() . kernel doc __initcall()/module_init() include/linux/init.h Many parts of the kernel are well served as a module (dynamically-loadable parts of the kernel). Using the module_init() and module_exit() macros it is easy to write code without #ifdefs which can operate both as a module or built into the kernel. The module_init() macro defines which function is to be called at module insertion time (if the file is compiled as a module), or at boot time: if the file is not compiled as a module the module_init() macro becomes equivalent to __initcall() , which through linker magic ensures that the function is called on boot. The function can return a negative error number to cause module loading to fail (unfortunately, this has no effect if the module is compiled into the kernel). This function is called in user context with interrupts enabled, so it can sleep. ref: https://www.kernel.org/doc/htmldocs/kernel-hacking/routines-init-again.html printk : \u00c9 uma das fun\u00e7\u00f5es mais conhecidas no kernel do Linux, usada para criar logs e rastrear bugs. A sa\u00edda desse print n\u00e3o \u00e9 no terminal como o printf, mas sim no demesg . kernel doc Para mais informa\u00e7\u00f5es acesse: https://www.kernel.org/doc/html/latest/core-api/printk-basics.html Agora precisamos compilar esse m\u00f3dulo para um .ko , para isso crie um arquivo Makefile : // Makefile obj-m += simple.o all : make -C /lib/modules/ $( shell uname -r ) /build M = $( PWD ) modules clean : make -C /lib/modules/ $( shell uname -r ) /build M = $( PWD ) clean compilando e testando \u00b6 Agora voc\u00ea pode compilar o m\u00f3dulo com o comando make , uma vez feito isso o arquivo simple.ko deve ter sido gerado na pasta do projeto. Esse arquivo \u00e9 o m\u00f3dulo compilado e que iremos linkar no kernel do linux usando o comando: $ sudo insmod simple.ko Isso far\u00e1 com que o m\u00f3dulo fa\u00e7a parte do kernel, para verificarmos se funcionou podemos listar os m\u00f3dulos em execu\u00e7\u00e3o com o comando lsmod : $ lsmod | grep simple Para termos acesso ao log (mensagem de HELLO), basta acessarmos o dmesg : $ dmesg | tail Para remover o m\u00f3dulo usamos o comando rmmod : $ sudo rmmod simple Ent\u00e3o devemos ver a mensagem de Goodbye no demesg : $ dmesg | tail","title":"Kernel module"},{"location":"Tutorial-HPS-kernel-module/#kernel-module","text":"Nesse tutorial iremos trabalhar com o b\u00e1sico do desenvolvimento de m\u00f3dulos para o kernel do linux.","title":"Kernel module"},{"location":"Tutorial-HPS-kernel-module/#simple-module","text":"Tip Antes de come\u00e7ar instale: apt-get install build-essential linux-headers-`uname -r` Note Trabalhe dentro de uma pasta chamada simple_module . Crie um arquivo simple.c e inicialize com o c\u00f3digo a seguir: // simple.c // https://tldp.org/LDP/lkmpg/2.6/html/x121.html #include <linux/kernel.h> #include <linux/init.h> #include <linux/module.h> MODULE_DESCRIPTION ( \"My kernel module\" ); MODULE_AUTHOR ( \"Me\" ); MODULE_LICENSE ( \"GPL\" ); static int simple_init ( void ) { printk ( KERN_INFO \"HELLO, WORLD \\n \" ); return 0 ; } static void simple_exit ( void ) { printk ( KERN_INFO \"GOODBYE, WORLD \\n \" ); } module_init ( simple_init ); module_exit ( simple_exit ); Pronto! Este \u00e9 um m\u00f3dulo que pode ser lincado no kernel do Linux em tempo de execu\u00e7\u00e3o e altera o seu funcionamento (na verdade n\u00e3o faz nada). Vamos entender algumas coisas: Todo m\u00f3dulo deve ter uma fun\u00e7\u00e3o de inicializa\u00e7\u00e3o e sa\u00edda, essas fun\u00e7\u00f5es podem ter qualquer nome, mas devem ser informadas ao kernel pelas macros module_init() e module_exit() . kernel doc __initcall()/module_init() include/linux/init.h Many parts of the kernel are well served as a module (dynamically-loadable parts of the kernel). Using the module_init() and module_exit() macros it is easy to write code without #ifdefs which can operate both as a module or built into the kernel. The module_init() macro defines which function is to be called at module insertion time (if the file is compiled as a module), or at boot time: if the file is not compiled as a module the module_init() macro becomes equivalent to __initcall() , which through linker magic ensures that the function is called on boot. The function can return a negative error number to cause module loading to fail (unfortunately, this has no effect if the module is compiled into the kernel). This function is called in user context with interrupts enabled, so it can sleep. ref: https://www.kernel.org/doc/htmldocs/kernel-hacking/routines-init-again.html printk : \u00c9 uma das fun\u00e7\u00f5es mais conhecidas no kernel do Linux, usada para criar logs e rastrear bugs. A sa\u00edda desse print n\u00e3o \u00e9 no terminal como o printf, mas sim no demesg . kernel doc Para mais informa\u00e7\u00f5es acesse: https://www.kernel.org/doc/html/latest/core-api/printk-basics.html Agora precisamos compilar esse m\u00f3dulo para um .ko , para isso crie um arquivo Makefile : // Makefile obj-m += simple.o all : make -C /lib/modules/ $( shell uname -r ) /build M = $( PWD ) modules clean : make -C /lib/modules/ $( shell uname -r ) /build M = $( PWD ) clean","title":"Simple module"},{"location":"Tutorial-HPS-kernel-module/#compilando-e-testando","text":"Agora voc\u00ea pode compilar o m\u00f3dulo com o comando make , uma vez feito isso o arquivo simple.ko deve ter sido gerado na pasta do projeto. Esse arquivo \u00e9 o m\u00f3dulo compilado e que iremos linkar no kernel do linux usando o comando: $ sudo insmod simple.ko Isso far\u00e1 com que o m\u00f3dulo fa\u00e7a parte do kernel, para verificarmos se funcionou podemos listar os m\u00f3dulos em execu\u00e7\u00e3o com o comando lsmod : $ lsmod | grep simple Para termos acesso ao log (mensagem de HELLO), basta acessarmos o dmesg : $ dmesg | tail Para remover o m\u00f3dulo usamos o comando rmmod : $ sudo rmmod simple Ent\u00e3o devemos ver a mensagem de Goodbye no demesg : $ dmesg | tail","title":"compilando e testando"},{"location":"Tutorial-HPS/","text":"Vis\u00e3o geral \u00b6 2020-2 Material atualizado. A FPGA contida no kit DE10-Standard \u00e9 um chip SoC que em um \u00fanico dispositivo que possui duas partes: o fabric da FPGA e um Hardware Process System (HPS). HPS \u00e9 o termo utilizado pela Intel-Altera para definir a parte da FPGA que \u00e9 fixa e relativa ao processador ARM A9 (pode ser outro ARM, depende da fam\u00edlia da FPGA). O HPS possui uma unidade de processamento com um ou dois Cores (depende do chip, no nosso caso \u00e9 dual core ) e alguns perif\u00e9ricos conectados em seu barramento (DMA, UART, USB, EMACS, ...). Al\u00e9m dos perif\u00e9ricos j\u00e1 contidos no HPS \u00e9 poss\u00edvel conectarmos novos perif\u00e9ricos sintetizados na FPGA via a interface HPS FPGA Interfaces . Ler Introdu\u00e7\u00e3o: 1 Introduction to Cyclone V Hard Processor System (HPS) Fam\u00edlia de FPGAs \u00b6 A Altera possui quatro fam\u00edlias de FPGAs-SoC : Stratix 10 SoC: High end, 14nm com ARM-Cortex-A53 de 64bits quad-core Arria 10 SoC: 20nm, Cortex A9 duas core com grande capacidade na FPGA Temos um kit no lab Arria V SoC: 28nm, Cortex A9 com foco em telecomunica\u00e7\u00f5es Cyclone V SoC : Fam\u00edlia low end com valor mais baixo e mais low power. Cortex A9 \u00b6 O Cortex A9 existente no HPS da Cyclone V possui as caracter\u00edsticas a seguir (extra\u00eddo do datasheet ): ARM Cortex-A9 MPCore One or two ARM Cortex-A9 processors in a cluster NEON SIMD coprocessor and VFPv3 per processor Snoop Control Unit (SCU) to ensure coherency within the cluster Accelerator coherency port (ACP) that accepts coherency memory access requests Interrupt controller One general-purpose timer and one watchdog timer per processor \u2022 Debug and trace features 32 KB instruction and 32 KB data level 1 (L1) caches per processor Memory management unit (MMU) per processor ARM L2-310 level 2 (L2) cache Shared 512 KB L2 cache A seguir um diagrama detalhado do HPS: Conex\u00e3o entre HPS e FPGA \u00b6 Note que existe no diagrama anterior algumas interfaces definidas no \"FPGA Portion\", essas interfaces permitem a ponte entre o Fabric da FPGA e o ARM hard core do chip. As interfaces s\u00e3o, resumidamente: FPGA to HPS: Barramento na qual um Master na FPGA (Platform Designer) acessa o ARM HPS to FPGA: Barramento pelo qual o ARM acessa um perif\u00e9rico (slave) na FPGA Lightweight HPS to FPGA: Barramento de menor banda que conecta o ARM em um perif\u00e9rico na FPGA (slave) 1-6 Masters SDRAM Controller: Permite a FPGA ler e escrever da mem\u00f3ria SDRAM externa ao chip AXI \u00b6 Os barramentos s\u00e3o todos do tipo AXI , um padr\u00e3o definido pela pr\u00f3pria ARM e usada em seus microcontroladores. AXI - AVALON Via Platform Designer podemos conectar perif\u00e9ricos com o barramento Avalon (mm) no barramento AXI do ARM, isso \u00e9 poss\u00edvel por uma \"m\u00e1gica\" que a PD faz convertendo um barramento no outro de forma transparente ao usu\u00e1rio. SDRAM \u00b6 A SDRAM deve ser usada com muita cautela, pois ela ser\u00e1 compartilhada com o Linux que estar\u00e1 em execu\u00e7\u00e3o no ARM, caso um perif\u00e9rico da FPGA acesse \"aleatoriamente\" a mem\u00f3ria SDRAM ele pode sobrescrever dados importantes do kernel e pode causar falhar em todo sistema. Essa aloca\u00e7\u00e3o deve ser realizada no boot do Linux onde iremos dizer qual regi\u00e3o de mem\u00f3ria o kernel pode utilizar. Note Essa mem\u00f3ria que \u00e9 acess\u00edvel tanto pelo Linux quanto pela FPGA \u00e9 uma boa maneira de compartilhamento de dados a serem processados. Aplica\u00e7\u00f5es \u00b6 Agora \u00e9 poss\u00edvel unir o melhor dos dois mundos: flexibilidade e paralelismo da FPGA com o melhor dos processadores embarcados, o ARM. Daqui para frente nossos projetos, o NIOS ser\u00e1 substitu\u00eddo pelo ARM , possibilitando maior poder de processamento e tamb\u00e9m suportando a execu\u00e7\u00e3o de sistemas operacionais mais complexos, tal como o Linux. Vamos fazer um exerc\u00edcio mental e imaginar uma aplica\u00e7\u00e3o que ir\u00e1 processar uma imagem em um sistema embarcada, com o SoC podemos fazer que a imagmem seja processada pela FPGA de modo a aumentar o throughtput do sistema. Essa imagem seria lida, por exemplo por uma c\u00e2mera USB conectada no HPS (ARM), como geralmente o HPS executa um Linux, temos facilidade de acesso ao driver desse dispositivo. A imagem ser\u00e1 ent\u00e3o lida via o driver e alocada na mem\u00f3ria SDRAM, o endere\u00e7o da mem\u00f3ria assim como as propriedades do processamento ser\u00e3o transferidas para um perif\u00e9rico customizado no Fabric da FPGA via a interface LT-AXI. O perif\u00e9rico que est\u00e1 em modo wait, ap\u00f3s ser configurado, come\u00e7a a ler a imagem na mem\u00f3ria SDRAM, processar e salvar o resultado na pr\u00f3pria mem\u00f3ria. Ao final da convers\u00e3o uma interrup\u00e7\u00e3o \u00e9 gerada e o Linux ir\u00e1 tratar o dado. Enquanto o perif\u00e9rico processa a imagem, a aplica\u00e7\u00e3o pode de forma concorrente, ler uma nova imagem e j\u00e1 alocar em um novo endere\u00e7o de mem\u00f3ria, pois o processamento e a aquisi\u00e7\u00e3o agora funcionam de forma simult\u00e2nea. Pr\u00f3ximos passos \u00b6 Vamos agora executar um Linux no ARM, iremos nesse momento trabalhar com uma imagem j\u00e1 pronta e fornecida pelo fabricante do kit. Siga para o pr\u00f3ximo tutorial, onde iremos configurar nossa infra para podermos gerar c\u00f3digos para o ARM.","title":"Vis\u00e3o geral"},{"location":"Tutorial-HPS/#visao-geral","text":"2020-2 Material atualizado. A FPGA contida no kit DE10-Standard \u00e9 um chip SoC que em um \u00fanico dispositivo que possui duas partes: o fabric da FPGA e um Hardware Process System (HPS). HPS \u00e9 o termo utilizado pela Intel-Altera para definir a parte da FPGA que \u00e9 fixa e relativa ao processador ARM A9 (pode ser outro ARM, depende da fam\u00edlia da FPGA). O HPS possui uma unidade de processamento com um ou dois Cores (depende do chip, no nosso caso \u00e9 dual core ) e alguns perif\u00e9ricos conectados em seu barramento (DMA, UART, USB, EMACS, ...). Al\u00e9m dos perif\u00e9ricos j\u00e1 contidos no HPS \u00e9 poss\u00edvel conectarmos novos perif\u00e9ricos sintetizados na FPGA via a interface HPS FPGA Interfaces . Ler Introdu\u00e7\u00e3o: 1 Introduction to Cyclone V Hard Processor System (HPS)","title":"Vis\u00e3o geral"},{"location":"Tutorial-HPS/#familia-de-fpgas","text":"A Altera possui quatro fam\u00edlias de FPGAs-SoC : Stratix 10 SoC: High end, 14nm com ARM-Cortex-A53 de 64bits quad-core Arria 10 SoC: 20nm, Cortex A9 duas core com grande capacidade na FPGA Temos um kit no lab Arria V SoC: 28nm, Cortex A9 com foco em telecomunica\u00e7\u00f5es Cyclone V SoC : Fam\u00edlia low end com valor mais baixo e mais low power.","title":"Fam\u00edlia de FPGAs"},{"location":"Tutorial-HPS/#cortex-a9","text":"O Cortex A9 existente no HPS da Cyclone V possui as caracter\u00edsticas a seguir (extra\u00eddo do datasheet ): ARM Cortex-A9 MPCore One or two ARM Cortex-A9 processors in a cluster NEON SIMD coprocessor and VFPv3 per processor Snoop Control Unit (SCU) to ensure coherency within the cluster Accelerator coherency port (ACP) that accepts coherency memory access requests Interrupt controller One general-purpose timer and one watchdog timer per processor \u2022 Debug and trace features 32 KB instruction and 32 KB data level 1 (L1) caches per processor Memory management unit (MMU) per processor ARM L2-310 level 2 (L2) cache Shared 512 KB L2 cache A seguir um diagrama detalhado do HPS:","title":"Cortex A9"},{"location":"Tutorial-HPS/#conexao-entre-hps-e-fpga","text":"Note que existe no diagrama anterior algumas interfaces definidas no \"FPGA Portion\", essas interfaces permitem a ponte entre o Fabric da FPGA e o ARM hard core do chip. As interfaces s\u00e3o, resumidamente: FPGA to HPS: Barramento na qual um Master na FPGA (Platform Designer) acessa o ARM HPS to FPGA: Barramento pelo qual o ARM acessa um perif\u00e9rico (slave) na FPGA Lightweight HPS to FPGA: Barramento de menor banda que conecta o ARM em um perif\u00e9rico na FPGA (slave) 1-6 Masters SDRAM Controller: Permite a FPGA ler e escrever da mem\u00f3ria SDRAM externa ao chip","title":"Conex\u00e3o entre HPS e FPGA"},{"location":"Tutorial-HPS/#axi","text":"Os barramentos s\u00e3o todos do tipo AXI , um padr\u00e3o definido pela pr\u00f3pria ARM e usada em seus microcontroladores. AXI - AVALON Via Platform Designer podemos conectar perif\u00e9ricos com o barramento Avalon (mm) no barramento AXI do ARM, isso \u00e9 poss\u00edvel por uma \"m\u00e1gica\" que a PD faz convertendo um barramento no outro de forma transparente ao usu\u00e1rio.","title":"AXI"},{"location":"Tutorial-HPS/#sdram","text":"A SDRAM deve ser usada com muita cautela, pois ela ser\u00e1 compartilhada com o Linux que estar\u00e1 em execu\u00e7\u00e3o no ARM, caso um perif\u00e9rico da FPGA acesse \"aleatoriamente\" a mem\u00f3ria SDRAM ele pode sobrescrever dados importantes do kernel e pode causar falhar em todo sistema. Essa aloca\u00e7\u00e3o deve ser realizada no boot do Linux onde iremos dizer qual regi\u00e3o de mem\u00f3ria o kernel pode utilizar. Note Essa mem\u00f3ria que \u00e9 acess\u00edvel tanto pelo Linux quanto pela FPGA \u00e9 uma boa maneira de compartilhamento de dados a serem processados.","title":"SDRAM"},{"location":"Tutorial-HPS/#aplicacoes","text":"Agora \u00e9 poss\u00edvel unir o melhor dos dois mundos: flexibilidade e paralelismo da FPGA com o melhor dos processadores embarcados, o ARM. Daqui para frente nossos projetos, o NIOS ser\u00e1 substitu\u00eddo pelo ARM , possibilitando maior poder de processamento e tamb\u00e9m suportando a execu\u00e7\u00e3o de sistemas operacionais mais complexos, tal como o Linux. Vamos fazer um exerc\u00edcio mental e imaginar uma aplica\u00e7\u00e3o que ir\u00e1 processar uma imagem em um sistema embarcada, com o SoC podemos fazer que a imagmem seja processada pela FPGA de modo a aumentar o throughtput do sistema. Essa imagem seria lida, por exemplo por uma c\u00e2mera USB conectada no HPS (ARM), como geralmente o HPS executa um Linux, temos facilidade de acesso ao driver desse dispositivo. A imagem ser\u00e1 ent\u00e3o lida via o driver e alocada na mem\u00f3ria SDRAM, o endere\u00e7o da mem\u00f3ria assim como as propriedades do processamento ser\u00e3o transferidas para um perif\u00e9rico customizado no Fabric da FPGA via a interface LT-AXI. O perif\u00e9rico que est\u00e1 em modo wait, ap\u00f3s ser configurado, come\u00e7a a ler a imagem na mem\u00f3ria SDRAM, processar e salvar o resultado na pr\u00f3pria mem\u00f3ria. Ao final da convers\u00e3o uma interrup\u00e7\u00e3o \u00e9 gerada e o Linux ir\u00e1 tratar o dado. Enquanto o perif\u00e9rico processa a imagem, a aplica\u00e7\u00e3o pode de forma concorrente, ler uma nova imagem e j\u00e1 alocar em um novo endere\u00e7o de mem\u00f3ria, pois o processamento e a aquisi\u00e7\u00e3o agora funcionam de forma simult\u00e2nea.","title":"Aplica\u00e7\u00f5es"},{"location":"Tutorial-HPS/#proximos-passos","text":"Vamos agora executar um Linux no ARM, iremos nesse momento trabalhar com uma imagem j\u00e1 pronta e fornecida pelo fabricante do kit. Siga para o pr\u00f3ximo tutorial, onde iremos configurar nossa infra para podermos gerar c\u00f3digos para o ARM.","title":"Pr\u00f3ximos passos"},{"location":"info-FPGA-e-Softwares/","text":"Infraestrutura de HW e SWs \u00b6 Ao longo do curso iremos trabalhar principalmente com FPGAs SoC da Intel, o principal kit de desenvolvimento \u00e9 o DE10-Standard que possui uma FPGA Cyclone V SoC. O software de desenvolvimento para FPGAs Intel chama Quartus, e ele possui v\u00e1rias e v\u00e1rias vers\u00f5es e varia\u00e7\u00f5es, baixar a indicada aqui para n\u00e3o correr o risco de ter que instalar tudo novamente. Vers\u00e3o 2020-2 online Voc\u00eas v\u00e3o receber os seguintes materiais para trabalharem no curso de casa: 1x FPGA DE10-Standard 1x micro SDcard 1x Adaptador microSD/USB 1x NIC USB-Wifi HW - DE10-Standard \u00b6 Site do fabricante \u00c9 um kit de desenvolvimento fabricado pela Terasic com valor de $350 que possui em seu core uma FPGA Intel Cyclone V - SoC com grande capacidade de mem\u00f3ria e v\u00e1rias c\u00e9lulas l\u00f3gicas, possui diversos perif\u00e9ricos que podem ser controlados ou pela FPGA ou pelo ARM do chip. Softwares \u00b6 Devido a segunda parte do curso na qual iremos compilar e trabalhar com Linux embarcado a disciplina deve ser realizada (e os tutoriais v\u00e3o nessa linha) no Linux , Windows at\u00e9 funciona para a primeira parte, mas depois n\u00e3o da mais para usar, MAC n\u00e3o \u00e9 suportado pelo Quartus. Para o desenvolvimento na disciplina: Ubuntu 18.04 Quartus 18.01 Standard : e os softwares que j\u00e1 vem nesse pacote. SoC EDS Ap\u00f3s instalar, seguir roteiro em (para o quartus funcionar no ubuntu): :TODO: Atualizar link! https://github.com/Insper/Z01.1/wiki/Infraestrutura-Detalhada#3---quartus-prime-e-modelsim Linux Windows MAC","title":"Infraestrutura de HW e SWs"},{"location":"info-FPGA-e-Softwares/#infraestrutura-de-hw-e-sws","text":"Ao longo do curso iremos trabalhar principalmente com FPGAs SoC da Intel, o principal kit de desenvolvimento \u00e9 o DE10-Standard que possui uma FPGA Cyclone V SoC. O software de desenvolvimento para FPGAs Intel chama Quartus, e ele possui v\u00e1rias e v\u00e1rias vers\u00f5es e varia\u00e7\u00f5es, baixar a indicada aqui para n\u00e3o correr o risco de ter que instalar tudo novamente. Vers\u00e3o 2020-2 online Voc\u00eas v\u00e3o receber os seguintes materiais para trabalharem no curso de casa: 1x FPGA DE10-Standard 1x micro SDcard 1x Adaptador microSD/USB 1x NIC USB-Wifi","title":"Infraestrutura de HW e SWs"},{"location":"info-FPGA-e-Softwares/#hw-de10-standard","text":"Site do fabricante \u00c9 um kit de desenvolvimento fabricado pela Terasic com valor de $350 que possui em seu core uma FPGA Intel Cyclone V - SoC com grande capacidade de mem\u00f3ria e v\u00e1rias c\u00e9lulas l\u00f3gicas, possui diversos perif\u00e9ricos que podem ser controlados ou pela FPGA ou pelo ARM do chip.","title":"HW - DE10-Standard"},{"location":"info-FPGA-e-Softwares/#softwares","text":"Devido a segunda parte do curso na qual iremos compilar e trabalhar com Linux embarcado a disciplina deve ser realizada (e os tutoriais v\u00e3o nessa linha) no Linux , Windows at\u00e9 funciona para a primeira parte, mas depois n\u00e3o da mais para usar, MAC n\u00e3o \u00e9 suportado pelo Quartus. Para o desenvolvimento na disciplina: Ubuntu 18.04 Quartus 18.01 Standard : e os softwares que j\u00e1 vem nesse pacote. SoC EDS Ap\u00f3s instalar, seguir roteiro em (para o quartus funcionar no ubuntu): :TODO: Atualizar link! https://github.com/Insper/Z01.1/wiki/Infraestrutura-Detalhada#3---quartus-prime-e-modelsim Linux Windows MAC","title":"Softwares"},{"location":"info-HPS-Serial/","text":"Screen \u00b6 Possu\u00edmos algumas formas de acessar e utilizar esse sistema: Via terminal UART Via terminal ssh Se o linux possuir interface gr\u00e1fica, podemos usar um teclado e mouse. Interface gr\u00e1fica via ssh UART \u00b6 O linux no HPS \u00e9 geralmente configurado (no bootloader) para possuir um terminal redirecionado para uma porta UART, essa porta UART \u00e9 dispon\u00edvel via FTDI em um dos USBs da placa (o que estiver escrito UART) e ent\u00e3o pode ser acessado como uma UART. Para isso h\u00e1 uma porta USB espec\u00edfica (UART). Uma vez conectada a porta USB ao PC e energizada a placa, podemos verificar em qual device a porta serial foi mapeada (no host ): $ demsg | tail [ 95158 .497894 ] ftdi_sio 1 -1.1:1.0: device disconnected [ 95161 .649187 ] usb 1 -1.1: new full-speed USB device number 22 using xhci_hcd [ 95161 .748948 ] ftdi_sio 1 -1.1:1.0: FTDI USB Serial Device converter detected [ 95161 .749067 ] usb 1 -1.1: Detected FT232RL [ 95161 .756092 ] usb 1 -1.1: FTDI USB Serial Device converter now attached to ttyUSB0 No log, verificamos que um dispositivo FTDI USB Serial Device foi conectado a ttyUSB0 . E ent\u00e3o podemos abrir o terminal por qualquer programa de porta serial (PUTTY, ...), nesse exemplo utilizaremos o programa screen . $ screen /dev/ttyUSB0 115200 ,cs8 Para melhoramos a interface com o screen crie um arquivo ~/.screenrc e adicione o seguinte conte\u00fado a ele # Enable mouse scrolling and scroll bar history scrolling termcapinfo xterm* ti@:te@ talvez seja necess\u00e1rio instalar o screen. Feito isso, reinicie o target (religando a energia) para termos acesso a todo o log de inicializa\u00e7\u00e3o. notem que no meu caso o nome atribuido ao USB-UART foi o /dev/ttyUSB0 , isso pode mudar no PC de voc\u00eas Uma vez conectado, agora temos acesso a todas as funcionalidades do linux como um bash normal. Na verdade o terminal j\u00e1 \u00e9 configurado para funcionar j\u00e1 no boot, ou seja, conseguimos ter acesso as informa\u00e7\u00f5es do u-boot. Kernel e porta serial \u00b6 Como o kernel sabe qual porta ele deve utilizar para imprimir o log e usar como terminal ? Esse par\u00e2metro \u00e9 passado pelo u-boot para o kernel via o Device Tree : hps_0_uart0: serial@0xffc02000 { compatible = \"snps,dw-apb-uart-1.0\", \"snps,dw-apb-uart\"; reg = < 0xFFC02000 0x00001000 >; interrupt-parent = < &hps_0_arm_gic_0 >; interrupts = < 0 162 4 >; reg-io-width = < 4 >; reg-shift = < 2 >; clock-frequency = < 100000000 >; }; E ent\u00e3o passado com o argumento para o kernel: bootargs = \"console=ttyS0,115200\"; (esse exemplo n\u00e3o \u00e9 da nossa FPGA)","title":"Screen"},{"location":"info-HPS-Serial/#screen","text":"Possu\u00edmos algumas formas de acessar e utilizar esse sistema: Via terminal UART Via terminal ssh Se o linux possuir interface gr\u00e1fica, podemos usar um teclado e mouse. Interface gr\u00e1fica via ssh","title":"Screen"},{"location":"info-HPS-Serial/#uart","text":"O linux no HPS \u00e9 geralmente configurado (no bootloader) para possuir um terminal redirecionado para uma porta UART, essa porta UART \u00e9 dispon\u00edvel via FTDI em um dos USBs da placa (o que estiver escrito UART) e ent\u00e3o pode ser acessado como uma UART. Para isso h\u00e1 uma porta USB espec\u00edfica (UART). Uma vez conectada a porta USB ao PC e energizada a placa, podemos verificar em qual device a porta serial foi mapeada (no host ): $ demsg | tail [ 95158 .497894 ] ftdi_sio 1 -1.1:1.0: device disconnected [ 95161 .649187 ] usb 1 -1.1: new full-speed USB device number 22 using xhci_hcd [ 95161 .748948 ] ftdi_sio 1 -1.1:1.0: FTDI USB Serial Device converter detected [ 95161 .749067 ] usb 1 -1.1: Detected FT232RL [ 95161 .756092 ] usb 1 -1.1: FTDI USB Serial Device converter now attached to ttyUSB0 No log, verificamos que um dispositivo FTDI USB Serial Device foi conectado a ttyUSB0 . E ent\u00e3o podemos abrir o terminal por qualquer programa de porta serial (PUTTY, ...), nesse exemplo utilizaremos o programa screen . $ screen /dev/ttyUSB0 115200 ,cs8 Para melhoramos a interface com o screen crie um arquivo ~/.screenrc e adicione o seguinte conte\u00fado a ele # Enable mouse scrolling and scroll bar history scrolling termcapinfo xterm* ti@:te@ talvez seja necess\u00e1rio instalar o screen. Feito isso, reinicie o target (religando a energia) para termos acesso a todo o log de inicializa\u00e7\u00e3o. notem que no meu caso o nome atribuido ao USB-UART foi o /dev/ttyUSB0 , isso pode mudar no PC de voc\u00eas Uma vez conectado, agora temos acesso a todas as funcionalidades do linux como um bash normal. Na verdade o terminal j\u00e1 \u00e9 configurado para funcionar j\u00e1 no boot, ou seja, conseguimos ter acesso as informa\u00e7\u00f5es do u-boot.","title":"UART"},{"location":"info-HPS-Serial/#kernel-e-porta-serial","text":"Como o kernel sabe qual porta ele deve utilizar para imprimir o log e usar como terminal ? Esse par\u00e2metro \u00e9 passado pelo u-boot para o kernel via o Device Tree : hps_0_uart0: serial@0xffc02000 { compatible = \"snps,dw-apb-uart-1.0\", \"snps,dw-apb-uart\"; reg = < 0xFFC02000 0x00001000 >; interrupt-parent = < &hps_0_arm_gic_0 >; interrupts = < 0 162 4 >; reg-io-width = < 4 >; reg-shift = < 2 >; clock-frequency = < 100000000 >; }; E ent\u00e3o passado com o argumento para o kernel: bootargs = \"console=ttyS0,115200\"; (esse exemplo n\u00e3o \u00e9 da nossa FPGA)","title":"Kernel e porta serial"},{"location":"info-HPS-ethernet/","text":"Ethernet \u00b6 Cyclone V Hard Processor System Technical Reference Manual https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/hb/cyclone-v/cv_54001.pdf S\u00e3o dois cen\u00e1rios poss\u00edveis: Conectar a DE10-Standard a um roteador via cabo de rede Conectar a DE10-Standard no seu PC via um NIC (foi junto com o kit) Cen\u00e1rio 1 - roteador \u00b6 Tip Se poss\u00edvel, escolha esse cen\u00e1rio. Conecta-se a placa no roteador e o PC no roteador via wifi ou cabo. Siga os passoas a seguir: Conecte a DE10-Standard via cabo de rede no roteador Conecte-se a placa via a porta USB-Serial (screen) Ligue a placa (com o SDCARD) Configure o target Configurando target \u00b6 Com um cabo ethernet conectado ao RJ45, precisamos configurar o Linux para utilizar essa \"porta\". No target , verifique se o linux detecta a placa de rede, com o comando: ifconfig eth0 up , e ent\u00e3o ifconfig all . Note Depois iremos entender como o Linux sabe que existe uma porta ethernet. Requisitando IP (DHCP) \u00b6 Agora \u00e9 necess\u00e1rio buscar um IP no servidor de DHCP (que est\u00e1 no seu roteador), para isso utilizaremos o programa udhcpc , com o comando a seguir: $ udhcpc eth0 Para ver o ip $ ifconfig Testando \u00b6 Para testar vamos pingar Host \u2192 Target e Target \u2192 Host, Target \u2192 internet Verifique o IP com o comando ifconfig e tente pingar algum site ping google.com . Cen\u00e1rio 2 - NIC \u00b6 Conecta-se a placa ao computador via o adaptador NIC. Siga os passos a seguir: Conecte a DE10-Standard a NIC Conecte a NIC ao USB do seu PC Conecte-se a placa via a porta USB-Serial (screen) Ligue a placa (com o SDCARD) Configure seu PC Configure o target Configurando PC \u00b6 Vamos ter que configurar um IP fixo na porta ethernet que a NIC cria no Linux do seu PC. Configurando Target \u00b6 Agora no target iremos configurar que a porta de rede tenha IP fixo: $ ifconfig eth0 up $ ifconfig eth0 169 .254.0.13 netmask 255 .255.0.0 up Testando \u00b6 Para testar vamos pingar Host \u2192 Target e Target \u2192 Host. Tip Importante validar antes de seguir. Automatizando no boot \u00b6 Essas configura\u00e7\u00f5es n\u00e3o s\u00e3o persistentes, se reiniciar o linux embarcados ter\u00e1 que fazer tudo novamente. Para facilitar nossa vida, vamos executar isso no boot. RC \u00b6 J\u00e1 reparou nas pastas /etc/rc* do seu sistema operacional? \u00c9 l\u00e1 que reside grande parte dos scripts que s\u00e3o executados no boot/ reboot/ halt. Cada distribui\u00e7\u00e3o utiliza de forma diferente os scripts, por exemplo, o debian utiliza da seguinte forma: https://wiki.debian.org/BootProcess runlevel directory meaning N none System bootup (NONE). There is no /etc/rcN.d/ directory. 0 /etc/rc0.d/ Halt the system. S /etc/rcS.d/ Single-user mode on boot. The lower case s can be used as alias. 1 /etc/rc1.d/ Single-user mode switched from multi-user mode. 2 .. 5 /etc/rc{2,3,4,5}.d/ Multi-user mode. The Debian system does not pre-assign any special meaning differences among these. 6 /etc/rc6.d/ Reboot the system. 7 .. 9 /etc/rc{7,8,9}.d/ Valid multi-user mode but traditional Unix variants don\u2019t use. Their /etc/rc?.d/ directories are not populated when packages are installed. Dentro de cada pasta rc.x os scripts possuem nomes que ditam a sequ\u00eancia na qual os scripts da pasta ser\u00e3o chamados. Adicionando script ao boot - systemd \u00b6 Crie um script com o nome S60MAC.sh na pasta /etc/init.d e adicione o c\u00f3digo a seguir (depende de qual cen\u00e1rio voc\u00ea ir\u00e1 usar): Cen\u00e1rio 1 #!/bin/bash case \" $1 \" in start ) printf \"Setting ip: \" ifconfig eth0 down ifconfig eth0 up udhcpc eth0 [ $? = 0 ] && echo \"OK\" || echo \"FAIL\" ;; * ) exit 1 ;; esac Cen\u00e1rio 2 #!/bin/bash case \" $1 \" in start ) printf \"Setting ip: \" /sbin/ifconfig eth0 169 .254.0.13 netmask 255 .255.0.0 up [ $? = 0 ] && echo \"OK\" || echo \"FAIL\" ;; * ) exit 1 ;; esac Torne o script execut\u00e1vel: chmod +x S60MAC.sh Uma vez criado o script ser\u00e1 necess\u00e1rio adicionar a inicializa\u00e7\u00e3o do sistema, para isso devemos chamar (quando a iso utiliza systemd, que \u00e9 o caso do Amstrong, mas n\u00e3o do buildroot): $ systemctl enable S60MAC.sh ref: https://forums.kali.org/showthread.php?21985-How-to-make-mac-address-random-at-each-boot-up","title":"Ethernet"},{"location":"info-HPS-ethernet/#ethernet","text":"Cyclone V Hard Processor System Technical Reference Manual https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/hb/cyclone-v/cv_54001.pdf S\u00e3o dois cen\u00e1rios poss\u00edveis: Conectar a DE10-Standard a um roteador via cabo de rede Conectar a DE10-Standard no seu PC via um NIC (foi junto com o kit)","title":"Ethernet"},{"location":"info-HPS-ethernet/#cenario-1-roteador","text":"Tip Se poss\u00edvel, escolha esse cen\u00e1rio. Conecta-se a placa no roteador e o PC no roteador via wifi ou cabo. Siga os passoas a seguir: Conecte a DE10-Standard via cabo de rede no roteador Conecte-se a placa via a porta USB-Serial (screen) Ligue a placa (com o SDCARD) Configure o target","title":"Cen\u00e1rio 1 - roteador"},{"location":"info-HPS-ethernet/#configurando-target","text":"Com um cabo ethernet conectado ao RJ45, precisamos configurar o Linux para utilizar essa \"porta\". No target , verifique se o linux detecta a placa de rede, com o comando: ifconfig eth0 up , e ent\u00e3o ifconfig all . Note Depois iremos entender como o Linux sabe que existe uma porta ethernet.","title":"Configurando target"},{"location":"info-HPS-ethernet/#requisitando-ip-dhcp","text":"Agora \u00e9 necess\u00e1rio buscar um IP no servidor de DHCP (que est\u00e1 no seu roteador), para isso utilizaremos o programa udhcpc , com o comando a seguir: $ udhcpc eth0 Para ver o ip $ ifconfig","title":"Requisitando IP (DHCP)"},{"location":"info-HPS-ethernet/#testando","text":"Para testar vamos pingar Host \u2192 Target e Target \u2192 Host, Target \u2192 internet Verifique o IP com o comando ifconfig e tente pingar algum site ping google.com .","title":"Testando"},{"location":"info-HPS-ethernet/#cenario-2-nic","text":"Conecta-se a placa ao computador via o adaptador NIC. Siga os passos a seguir: Conecte a DE10-Standard a NIC Conecte a NIC ao USB do seu PC Conecte-se a placa via a porta USB-Serial (screen) Ligue a placa (com o SDCARD) Configure seu PC Configure o target","title":"Cen\u00e1rio 2 - NIC"},{"location":"info-HPS-ethernet/#configurando-pc","text":"Vamos ter que configurar um IP fixo na porta ethernet que a NIC cria no Linux do seu PC.","title":"Configurando PC"},{"location":"info-HPS-ethernet/#configurando-target_1","text":"Agora no target iremos configurar que a porta de rede tenha IP fixo: $ ifconfig eth0 up $ ifconfig eth0 169 .254.0.13 netmask 255 .255.0.0 up","title":"Configurando Target"},{"location":"info-HPS-ethernet/#testando_1","text":"Para testar vamos pingar Host \u2192 Target e Target \u2192 Host. Tip Importante validar antes de seguir.","title":"Testando"},{"location":"info-HPS-ethernet/#automatizando-no-boot","text":"Essas configura\u00e7\u00f5es n\u00e3o s\u00e3o persistentes, se reiniciar o linux embarcados ter\u00e1 que fazer tudo novamente. Para facilitar nossa vida, vamos executar isso no boot.","title":"Automatizando no boot"},{"location":"info-HPS-ethernet/#rc","text":"J\u00e1 reparou nas pastas /etc/rc* do seu sistema operacional? \u00c9 l\u00e1 que reside grande parte dos scripts que s\u00e3o executados no boot/ reboot/ halt. Cada distribui\u00e7\u00e3o utiliza de forma diferente os scripts, por exemplo, o debian utiliza da seguinte forma: https://wiki.debian.org/BootProcess runlevel directory meaning N none System bootup (NONE). There is no /etc/rcN.d/ directory. 0 /etc/rc0.d/ Halt the system. S /etc/rcS.d/ Single-user mode on boot. The lower case s can be used as alias. 1 /etc/rc1.d/ Single-user mode switched from multi-user mode. 2 .. 5 /etc/rc{2,3,4,5}.d/ Multi-user mode. The Debian system does not pre-assign any special meaning differences among these. 6 /etc/rc6.d/ Reboot the system. 7 .. 9 /etc/rc{7,8,9}.d/ Valid multi-user mode but traditional Unix variants don\u2019t use. Their /etc/rc?.d/ directories are not populated when packages are installed. Dentro de cada pasta rc.x os scripts possuem nomes que ditam a sequ\u00eancia na qual os scripts da pasta ser\u00e3o chamados.","title":"RC"},{"location":"info-HPS-ethernet/#adicionando-script-ao-boot-systemd","text":"Crie um script com o nome S60MAC.sh na pasta /etc/init.d e adicione o c\u00f3digo a seguir (depende de qual cen\u00e1rio voc\u00ea ir\u00e1 usar): Cen\u00e1rio 1 #!/bin/bash case \" $1 \" in start ) printf \"Setting ip: \" ifconfig eth0 down ifconfig eth0 up udhcpc eth0 [ $? = 0 ] && echo \"OK\" || echo \"FAIL\" ;; * ) exit 1 ;; esac Cen\u00e1rio 2 #!/bin/bash case \" $1 \" in start ) printf \"Setting ip: \" /sbin/ifconfig eth0 169 .254.0.13 netmask 255 .255.0.0 up [ $? = 0 ] && echo \"OK\" || echo \"FAIL\" ;; * ) exit 1 ;; esac Torne o script execut\u00e1vel: chmod +x S60MAC.sh Uma vez criado o script ser\u00e1 necess\u00e1rio adicionar a inicializa\u00e7\u00e3o do sistema, para isso devemos chamar (quando a iso utiliza systemd, que \u00e9 o caso do Amstrong, mas n\u00e3o do buildroot): $ systemctl enable S60MAC.sh ref: https://forums.kali.org/showthread.php?21985-How-to-make-mac-address-random-at-each-boot-up","title":"Adicionando script ao boot - systemd"},{"location":"info-SDcard/","text":"Atualizando o SDCARD \u00b6 Informa\u00e7\u00f5es de como ataulizar o sdcard. Atualizando o preload \u00b6 TBD Atualizando o uboot \u00b6 TBD uboot script \u00b6 $ cp u-boot.scr /run/media/corsi/B0DA-B234/ Atualizando Kernel \u00b6 Para atualizar o kernel basta montar a parti\u00e7\u00e3o 0 (819,2 M). No meu caso o path \u00e9: /run/media/corsi/B0DA-B234/ e copiar o arquivo zImage para ela. O arquivo zImage fica localizado (dentro do reposit\u00f3rio do kernel) em: /arch/arm/boot/zImage $ cp ~/work/linux/arch/arm/boot/zImage /run/media/corsi/B0DA-B234/ $ sync Note Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. Quando fizer isso, ir\u00e1 reparar que a vers\u00e3o do kernel do Linux \u00e9 a que foi gerada na etapa de compila\u00e7\u00e3o do kernel. Atualizando o dts \u00b6 TBD FileSystem \u00b6 Para insierirmos nosso fileSystem no SDCARD, primeiramente deve montar a parti\u00e7\u00e3o 1. no meu caso : /media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ . Uma vez montada, devemos primeiramente excluir os arquivos ali salvo (apagar o fileSystem antigo) e ent\u00e3o extrair o que foi gerado pelo buildroot. Warning Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. A parti\u00e7\u00e3o \u00e9 aquela que possui o root / do linux embacado. Danger Se errar, pode ser destrutivo (para seus arquivos) # Limpando fs antigo $ sudo rm -r /media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync # Extraindo novo fs $ sudo tar xvf rootfs.tar -C /media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync","title":"Atualizando o SDCARD"},{"location":"info-SDcard/#atualizando-o-sdcard","text":"Informa\u00e7\u00f5es de como ataulizar o sdcard.","title":"Atualizando o SDCARD"},{"location":"info-SDcard/#atualizando-o-preload","text":"TBD","title":"Atualizando o preload"},{"location":"info-SDcard/#atualizando-o-uboot","text":"TBD","title":"Atualizando o uboot"},{"location":"info-SDcard/#uboot-script","text":"$ cp u-boot.scr /run/media/corsi/B0DA-B234/","title":"uboot script"},{"location":"info-SDcard/#atualizando-kernel","text":"Para atualizar o kernel basta montar a parti\u00e7\u00e3o 0 (819,2 M). No meu caso o path \u00e9: /run/media/corsi/B0DA-B234/ e copiar o arquivo zImage para ela. O arquivo zImage fica localizado (dentro do reposit\u00f3rio do kernel) em: /arch/arm/boot/zImage $ cp ~/work/linux/arch/arm/boot/zImage /run/media/corsi/B0DA-B234/ $ sync Note Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. Quando fizer isso, ir\u00e1 reparar que a vers\u00e3o do kernel do Linux \u00e9 a que foi gerada na etapa de compila\u00e7\u00e3o do kernel.","title":"Atualizando Kernel"},{"location":"info-SDcard/#atualizando-o-dts","text":"TBD","title":"Atualizando o dts"},{"location":"info-SDcard/#filesystem","text":"Para insierirmos nosso fileSystem no SDCARD, primeiramente deve montar a parti\u00e7\u00e3o 1. no meu caso : /media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ . Uma vez montada, devemos primeiramente excluir os arquivos ali salvo (apagar o fileSystem antigo) e ent\u00e3o extrair o que foi gerado pelo buildroot. Warning Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. A parti\u00e7\u00e3o \u00e9 aquela que possui o root / do linux embacado. Danger Se errar, pode ser destrutivo (para seus arquivos) # Limpando fs antigo $ sudo rm -r /media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync # Extraindo novo fs $ sudo tar xvf rootfs.tar -C /media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync","title":"FileSystem"},{"location":"info-VHDL/","text":"VHDL \u00b6 Boas refer\u00eancias da linguagem: Livros (bibliografia): [DESCHAMPS, 2012] DESCHAMPS, J. P.; SUTTER, G. D.; CANT\u00d3 E. Guide to FPGA implementation of arithmetic functions. Springer Science & Business Media; 2012, Apr 5. [CHU, 2011] CHU, PONG P. Embedded SoPC design with Nios II processor and VHDL examples. John Wiley & Sons, 2011. [SIMPSON, 2015] Simpson, Philip Andrew; FPGA Design: Best Practices for Team-based Reuse 2 nd ed. Springer, 2015 Edition. Sites: http://esd.cs.ucr.edu/labs/tutorial/ http://github.com/insper/Z01.1/wiki","title":"VHDL"},{"location":"info-VHDL/#vhdl","text":"Boas refer\u00eancias da linguagem: Livros (bibliografia): [DESCHAMPS, 2012] DESCHAMPS, J. P.; SUTTER, G. D.; CANT\u00d3 E. Guide to FPGA implementation of arithmetic functions. Springer Science & Business Media; 2012, Apr 5. [CHU, 2011] CHU, PONG P. Embedded SoPC design with Nios II processor and VHDL examples. John Wiley & Sons, 2011. [SIMPSON, 2015] Simpson, Philip Andrew; FPGA Design: Best Practices for Team-based Reuse 2 nd ed. Springer, 2015 Edition. Sites: http://esd.cs.ucr.edu/labs/tutorial/ http://github.com/insper/Z01.1/wiki","title":"VHDL"},{"location":"note/","text":"Limite RAM linux: https://www.intel.com/content/www/us/en/programmable/support/support-resources/knowledge-base/solutions/rd06132014_165.html https://ece453.engr.wisc.edu/u-boot-script/ ARM boot: https://people.kernel.org/linusw/how-the-arm32-linux-kernel-decompresses https://www.armlinux.org.uk/developer/booting.php","title":"Note"},{"location":"2019/Elisa-Yocto/","text":"Elisa Malzoni - Yocto \u00b6 Aluna: Elisa Monteiro Curso: Engenharia da Computa\u00e7\u00e3o Semestre: 9 Contato: Link tutorial oficial: https://github.com/elisamalzoni/Embarcados-Avancados Ano: 2019 Hardware utilizado no tutorial DE10-Standard Raspberry 3 O que \u00e9 o Yocto Project \u00b6 Projeto open source para cria\u00e7\u00e3o de sistemas customizados baseados em Linux, para embarcados, independentemente da arquiterura do hardware. Layer Model \u00b6 S\u00e3o reposit\u00f3rios que cont\u00e9m os conjuntos de instru\u00e7\u00f5es que s\u00e3o mandadas para o OpenEmbedded build system. Voc\u00ea pode modificar, compartilhar e reusar as layers . Essas layers podem conter mudan\u00e7as nas instru\u00e7\u00f5es ou configura\u00e7\u00f5es anteriores ou novas intru\u00e7\u00f5es e configura\u00e7\u00f5es. Separar as camadas dependendo das suas informa\u00e7\u00f5es pode aumentar a personaliza\u00e7\u00e3oe facilitar a reutiliza\u00e7\u00e3o das camadas. ex.: camadas de BSP, GUI, configura\u00e7\u00e3o da distro, middleware ou at\u00e9 a camada da aplica\u00e7\u00e3o. Layers geralmente tem nomes que come\u00e7am com meta- . BitBake \u00b6 Derivado do OpenEmbedded build system, \u00e9 utilizado para gerar as imagens. Poky \u00b6 \u00c9 a distribui\u00e7\u00e3o refer\u00eancia do Yocto e ser\u00e1 tamb\u00e9m utilizada na demonstra\u00e7\u00e3o. J\u00e1 vem com um conjunto de metadados, para come\u00e7ar a contru\u00e7\u00e3o da sua pr\u00f3pria distro. Poky \u00e9 a combina\u00e7\u00e3o dos reposit\u00f3rios do BitBake, OpenEmbedded-Core (dentro do meta ), meta-poky , meta-yocto-bsp , tamb\u00e9m a documenta\u00e7\u00e3o. BitBake agenda e executa as tarefas. Principal componente do OpenEmbedded build system. meta-poky metadados espec\u00edficos do poky. meta-yocto-bsp Board Support Packages (BSPs). OpenEmbedded-Core (OE-Core) metadata metadados de configura\u00e7\u00f5es compartilhadas, defini\u00e7\u00e3o de vari\u00e1veis globais, classes compartilhadas, pacotes, e recipes . Classes definem o encapsulamento e as heran\u00e7as da l\u00f3gica de build. Recipes s\u00e3o as unidades l\u00f3gicas de software e de imagens para buildar. Documenta\u00e7\u00e3o cont\u00e9m o c\u00f3digo fonte utilizado para gerar os manuais de usu\u00e1rio do Yocto Project. Uma Recipe \u00e9 uma cole\u00e7\u00e3o de metadados n\u00e3o execut\u00e1veis usada pelo BitBake para definir var\u00e1veis ou tarefas no tempo de build. Uma Recipe pode conter: Descri\u00e7\u00e3o da recipe vers\u00e3o licen\u00e7a do pacote reposit\u00f3rio de origem indicar os processos de build adi\u00e7\u00e3o de tarefas ou prerequisitos das tarefas Buildroot vs Yocto \u00b6 Tanto Yocto quanto Buildroot no final ter\u00e3o: root filesystem, para seu sitema embarcado kernel bootloader e uma toolchain compat\u00edvel O buildroot foca em simplicidade. Seu n\u00facleo \u00e9 mantido o qu\u00e3o simples e pequeno for poss\u00edvel, fazendo com que seja f\u00e1cil seu uso e compreens\u00e3o. Enquanto o Yocto tenta ser vers\u00e1til e suporta uma grande variedade de sistemas embarcados. O Buildroot gera somente a imagem do sistema de arquivos. Assim quando um sistema precisar se atualizado a imagem inteira deve ser gerada novamente. J\u00e1 a sa\u00edda do Yocto \u00e9 uma distribui\u00e7\u00e3o, onde pode exitir um sistema de gerenciamento de pacotes no qual pacotes podem ser atualizados individualmente, ou at\u00e9 mesmo serem removidas. No Yocto \u00e9 mais f\u00e1cil gerar altera\u00e7\u00f5es com mequenas mudan\u00e7as e sua escalabilidade tamb\u00e9m \u00e9 maior. Enquanto o Buildroot tenta se manter simples a curva de aprendizado do Yocto \u00e9 um pouco mais desafiadora e sua terminologia \u00e9 masi complicada. O conjunto de pacotes suportados pelo Buildroot \u00e9 menor. Tamb\u00e9m n\u00e3o possui mecanismo para detectar mudan\u00e7as entre builds. Compilando uma iso \u00b6 Warning Mesmo seguindo os tutoriais do Yocto e guias da altera, n\u00e3o consegui compilar para a placa usada no curso, assim utilizarei um Raspberry Pi 3 Model B. Links uteis \u00b6 Reference Manual Yocto Overview manual Deciding between Buildroot & Yocto Yocto e Raspberry Pi 3 Prepara\u00e7\u00e3o do host \u00b6 Voc\u00ea deve ter: 20 gbytes livres no disco Usar uma das vers\u00f5es recentes dos seguintes sistemas: Fedora, openSUSE, CentOS, Debian ou Ubuntu git 1.8.3.1 ou maior tar 1.27 ou maior python 3.4 ou maior Para instalar os pacotes essenciais no host rode o comando abaixo, se voc\u00ea usar uma distribui\u00e7\u00e3o ubuntu. $ sudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib build-essential chrpath socat libsdl1.2-dev xterm Clone o Yocto $ git clone -b thud http://git.yoctoproject.org/git/poky yocto $ git clone -b thud git://git.openembedded.org/meta-openembedded yocto/meta-openembedded Clone a layer do Angstrom $ git clone -b angstrom-v2018.12-thud git://github.com/Angstrom-distribution/meta-angstrom.git yocto/meta-angstrom Clone a layer do Raspberry Pi $ git clone -b thud git://git.yoctoproject.org/meta-raspberrypi yocto/meta-raspberrypi Clone a layer do Qt 5 $ git clone -b thud https://github.com/meta-qt5/meta-qt5.git yocto/meta-qt5 Iniciando o sistema de desenvolvimento. Isso precisa ser feito sempre que abrir um novo terminal $ cd yocto $ source oe-init-build-env Precisamos agora incluir as layers clonadas acima. Modifique o arquivo /yocto/build/conf/bblayers.conf para isso: # POKY_BBLAYERS_CONF_VERSION is increased each time build/conf/bblayers.conf # changes incompatibly POKY_BBLAYERS_CONF_VERSION = \"2\" BBPATH = \"${TOPDIR}\" BBFILES ?= \"\" BBLAYERS ?= \" \\ ${TOPDIR}/../meta \\ ${TOPDIR}/../meta-angstrom \\ ${TOPDIR}/../meta-poky \\ ${TOPDIR}/../meta-yocto-bsp \\ ${TOPDIR}/../meta-raspberrypi \\ ${TOPDIR}/../meta-qt5 \\ ${TOPDIR}/../meta-openembedded/meta-multimedia \\ ${TOPDIR}/../meta-openembedded/meta-networking \\ ${TOPDIR}/../meta-openembedded/meta-oe \\ ${TOPDIR}/../meta-openembedded/meta-python \\ ${TOPDIR}/../meta-openembedded/meta-webserver \\ \" No arquivo yocto/build/conf/local.conf adicione as seguintes linhas: MACHINE ??= \"raspberrypi3\" DISTRO ?= \"angstrom\" RPI_USE_U_BOOT = \"1\" Compilando \u00b6 $ bitbake core-image-base Voc\u00ea dever\u00e1 ter a seguinte sa\u00edda: Build Configuration: BB_VERSION = \"1.40.0\" BUILD_SYS = \"x86_64-linux\" NATIVELSBSTRING = \"ubuntu-18.04\" TARGET_SYS = \"arm-angstrom-linux-gnueabi\" MACHINE = \"raspberrypi3\" DISTRO = \"angstrom\" DISTRO_VERSION = \"v2018.12\" TUNE_FEATURES = \"arm armv7a vfp thumb neon callconvention-hard\" TARGET_FPU = \"hard\" meta = \"thud:8cd3ee6e1a50ad9f40466bcadb236c619c42ef19\" meta-angstrom = \"angstrom-v2018.12-thud:fdf4ca41ba6d455a906465a4d2f0d71dbb70224c\" meta-poky meta-yocto-bsp = \"thud:8cd3ee6e1a50ad9f40466bcadb236c619c42ef19\" meta-raspberrypi = \"thud:4e5be97d75668804694412f9b86e9291edb38b9d\" meta-qt5 = \"thud:1520d5b2b2beec5e1c3209d3178219e93ef08bca\" meta-multimedia meta-networking meta-oe meta-python meta-webserver = \"thud:446bd615fd7cb9bc7a159fe5c2019ed08d1a7a93\" Depois de compilado procure um desses arquivos e transfira a imagem para o arquivo. Eu utilizei o etcher para isso. /yocto/build/tmp-glibc/deploy/images/raspberrypi3/Angstrom-core-image-base-glibc-ipk-v2018.12-raspberrypi3.rootfs.rpi-sdimg /yocto/deploy/images/raspberrypi3/Angstrom-core-image-base-glibc-ipk-v2018.12-raspberrypi3.rootfs.rpi-sdimg At\u00e9 onde cheguei com a cyclone5? \u00b6 Clone o reposit\u00f3rio do Poky $ git clone git://git.yoctoproject.org/poky Cria\u00e7\u00e3o da Imagem \u00b6 Primeiro precisamos inicializar o ambiente de desenvolvimento: $ cd poky $ source oe-init-build-env Clone a layer da altera da seguinte maneira: $ cd poky $ git clone https://github.com/kraj/meta-altera.git Mude a vari\u00e1vel MACHINE para \"cyclone5\" no arquivo de configura\u00e7\u00e3o local.conf Adicione uma layer ao arquivo de configura\u00e7\u00e3o de layers: $ cd ~/poky/build $ bitbake-layers add-layer ../meta-altera Mas nao consegui nem compilar usando BitBake.","title":"Elisa Malzoni - Yocto"},{"location":"2019/Elisa-Yocto/#elisa-malzoni-yocto","text":"Aluna: Elisa Monteiro Curso: Engenharia da Computa\u00e7\u00e3o Semestre: 9 Contato: Link tutorial oficial: https://github.com/elisamalzoni/Embarcados-Avancados Ano: 2019 Hardware utilizado no tutorial DE10-Standard Raspberry 3","title":"Elisa Malzoni - Yocto"},{"location":"2019/Elisa-Yocto/#o-que-e-o-yocto-project","text":"Projeto open source para cria\u00e7\u00e3o de sistemas customizados baseados em Linux, para embarcados, independentemente da arquiterura do hardware.","title":"O que \u00e9 o Yocto Project"},{"location":"2019/Elisa-Yocto/#layer-model","text":"S\u00e3o reposit\u00f3rios que cont\u00e9m os conjuntos de instru\u00e7\u00f5es que s\u00e3o mandadas para o OpenEmbedded build system. Voc\u00ea pode modificar, compartilhar e reusar as layers . Essas layers podem conter mudan\u00e7as nas instru\u00e7\u00f5es ou configura\u00e7\u00f5es anteriores ou novas intru\u00e7\u00f5es e configura\u00e7\u00f5es. Separar as camadas dependendo das suas informa\u00e7\u00f5es pode aumentar a personaliza\u00e7\u00e3oe facilitar a reutiliza\u00e7\u00e3o das camadas. ex.: camadas de BSP, GUI, configura\u00e7\u00e3o da distro, middleware ou at\u00e9 a camada da aplica\u00e7\u00e3o. Layers geralmente tem nomes que come\u00e7am com meta- .","title":"Layer Model"},{"location":"2019/Elisa-Yocto/#bitbake","text":"Derivado do OpenEmbedded build system, \u00e9 utilizado para gerar as imagens.","title":"BitBake"},{"location":"2019/Elisa-Yocto/#poky","text":"\u00c9 a distribui\u00e7\u00e3o refer\u00eancia do Yocto e ser\u00e1 tamb\u00e9m utilizada na demonstra\u00e7\u00e3o. J\u00e1 vem com um conjunto de metadados, para come\u00e7ar a contru\u00e7\u00e3o da sua pr\u00f3pria distro. Poky \u00e9 a combina\u00e7\u00e3o dos reposit\u00f3rios do BitBake, OpenEmbedded-Core (dentro do meta ), meta-poky , meta-yocto-bsp , tamb\u00e9m a documenta\u00e7\u00e3o. BitBake agenda e executa as tarefas. Principal componente do OpenEmbedded build system. meta-poky metadados espec\u00edficos do poky. meta-yocto-bsp Board Support Packages (BSPs). OpenEmbedded-Core (OE-Core) metadata metadados de configura\u00e7\u00f5es compartilhadas, defini\u00e7\u00e3o de vari\u00e1veis globais, classes compartilhadas, pacotes, e recipes . Classes definem o encapsulamento e as heran\u00e7as da l\u00f3gica de build. Recipes s\u00e3o as unidades l\u00f3gicas de software e de imagens para buildar. Documenta\u00e7\u00e3o cont\u00e9m o c\u00f3digo fonte utilizado para gerar os manuais de usu\u00e1rio do Yocto Project. Uma Recipe \u00e9 uma cole\u00e7\u00e3o de metadados n\u00e3o execut\u00e1veis usada pelo BitBake para definir var\u00e1veis ou tarefas no tempo de build. Uma Recipe pode conter: Descri\u00e7\u00e3o da recipe vers\u00e3o licen\u00e7a do pacote reposit\u00f3rio de origem indicar os processos de build adi\u00e7\u00e3o de tarefas ou prerequisitos das tarefas","title":"Poky"},{"location":"2019/Elisa-Yocto/#buildroot-vs-yocto","text":"Tanto Yocto quanto Buildroot no final ter\u00e3o: root filesystem, para seu sitema embarcado kernel bootloader e uma toolchain compat\u00edvel O buildroot foca em simplicidade. Seu n\u00facleo \u00e9 mantido o qu\u00e3o simples e pequeno for poss\u00edvel, fazendo com que seja f\u00e1cil seu uso e compreens\u00e3o. Enquanto o Yocto tenta ser vers\u00e1til e suporta uma grande variedade de sistemas embarcados. O Buildroot gera somente a imagem do sistema de arquivos. Assim quando um sistema precisar se atualizado a imagem inteira deve ser gerada novamente. J\u00e1 a sa\u00edda do Yocto \u00e9 uma distribui\u00e7\u00e3o, onde pode exitir um sistema de gerenciamento de pacotes no qual pacotes podem ser atualizados individualmente, ou at\u00e9 mesmo serem removidas. No Yocto \u00e9 mais f\u00e1cil gerar altera\u00e7\u00f5es com mequenas mudan\u00e7as e sua escalabilidade tamb\u00e9m \u00e9 maior. Enquanto o Buildroot tenta se manter simples a curva de aprendizado do Yocto \u00e9 um pouco mais desafiadora e sua terminologia \u00e9 masi complicada. O conjunto de pacotes suportados pelo Buildroot \u00e9 menor. Tamb\u00e9m n\u00e3o possui mecanismo para detectar mudan\u00e7as entre builds.","title":"Buildroot vs Yocto"},{"location":"2019/Elisa-Yocto/#compilando-uma-iso","text":"Warning Mesmo seguindo os tutoriais do Yocto e guias da altera, n\u00e3o consegui compilar para a placa usada no curso, assim utilizarei um Raspberry Pi 3 Model B.","title":"Compilando uma iso"},{"location":"2019/Elisa-Yocto/#links-uteis","text":"Reference Manual Yocto Overview manual Deciding between Buildroot & Yocto Yocto e Raspberry Pi 3","title":"Links uteis"},{"location":"2019/Elisa-Yocto/#preparacao-do-host","text":"Voc\u00ea deve ter: 20 gbytes livres no disco Usar uma das vers\u00f5es recentes dos seguintes sistemas: Fedora, openSUSE, CentOS, Debian ou Ubuntu git 1.8.3.1 ou maior tar 1.27 ou maior python 3.4 ou maior Para instalar os pacotes essenciais no host rode o comando abaixo, se voc\u00ea usar uma distribui\u00e7\u00e3o ubuntu. $ sudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib build-essential chrpath socat libsdl1.2-dev xterm Clone o Yocto $ git clone -b thud http://git.yoctoproject.org/git/poky yocto $ git clone -b thud git://git.openembedded.org/meta-openembedded yocto/meta-openembedded Clone a layer do Angstrom $ git clone -b angstrom-v2018.12-thud git://github.com/Angstrom-distribution/meta-angstrom.git yocto/meta-angstrom Clone a layer do Raspberry Pi $ git clone -b thud git://git.yoctoproject.org/meta-raspberrypi yocto/meta-raspberrypi Clone a layer do Qt 5 $ git clone -b thud https://github.com/meta-qt5/meta-qt5.git yocto/meta-qt5 Iniciando o sistema de desenvolvimento. Isso precisa ser feito sempre que abrir um novo terminal $ cd yocto $ source oe-init-build-env Precisamos agora incluir as layers clonadas acima. Modifique o arquivo /yocto/build/conf/bblayers.conf para isso: # POKY_BBLAYERS_CONF_VERSION is increased each time build/conf/bblayers.conf # changes incompatibly POKY_BBLAYERS_CONF_VERSION = \"2\" BBPATH = \"${TOPDIR}\" BBFILES ?= \"\" BBLAYERS ?= \" \\ ${TOPDIR}/../meta \\ ${TOPDIR}/../meta-angstrom \\ ${TOPDIR}/../meta-poky \\ ${TOPDIR}/../meta-yocto-bsp \\ ${TOPDIR}/../meta-raspberrypi \\ ${TOPDIR}/../meta-qt5 \\ ${TOPDIR}/../meta-openembedded/meta-multimedia \\ ${TOPDIR}/../meta-openembedded/meta-networking \\ ${TOPDIR}/../meta-openembedded/meta-oe \\ ${TOPDIR}/../meta-openembedded/meta-python \\ ${TOPDIR}/../meta-openembedded/meta-webserver \\ \" No arquivo yocto/build/conf/local.conf adicione as seguintes linhas: MACHINE ??= \"raspberrypi3\" DISTRO ?= \"angstrom\" RPI_USE_U_BOOT = \"1\"","title":"Prepara\u00e7\u00e3o do host"},{"location":"2019/Elisa-Yocto/#compilando","text":"$ bitbake core-image-base Voc\u00ea dever\u00e1 ter a seguinte sa\u00edda: Build Configuration: BB_VERSION = \"1.40.0\" BUILD_SYS = \"x86_64-linux\" NATIVELSBSTRING = \"ubuntu-18.04\" TARGET_SYS = \"arm-angstrom-linux-gnueabi\" MACHINE = \"raspberrypi3\" DISTRO = \"angstrom\" DISTRO_VERSION = \"v2018.12\" TUNE_FEATURES = \"arm armv7a vfp thumb neon callconvention-hard\" TARGET_FPU = \"hard\" meta = \"thud:8cd3ee6e1a50ad9f40466bcadb236c619c42ef19\" meta-angstrom = \"angstrom-v2018.12-thud:fdf4ca41ba6d455a906465a4d2f0d71dbb70224c\" meta-poky meta-yocto-bsp = \"thud:8cd3ee6e1a50ad9f40466bcadb236c619c42ef19\" meta-raspberrypi = \"thud:4e5be97d75668804694412f9b86e9291edb38b9d\" meta-qt5 = \"thud:1520d5b2b2beec5e1c3209d3178219e93ef08bca\" meta-multimedia meta-networking meta-oe meta-python meta-webserver = \"thud:446bd615fd7cb9bc7a159fe5c2019ed08d1a7a93\" Depois de compilado procure um desses arquivos e transfira a imagem para o arquivo. Eu utilizei o etcher para isso. /yocto/build/tmp-glibc/deploy/images/raspberrypi3/Angstrom-core-image-base-glibc-ipk-v2018.12-raspberrypi3.rootfs.rpi-sdimg /yocto/deploy/images/raspberrypi3/Angstrom-core-image-base-glibc-ipk-v2018.12-raspberrypi3.rootfs.rpi-sdimg","title":"Compilando"},{"location":"2019/Elisa-Yocto/#ate-onde-cheguei-com-a-cyclone5","text":"Clone o reposit\u00f3rio do Poky $ git clone git://git.yoctoproject.org/poky","title":"At\u00e9 onde cheguei com a cyclone5?"},{"location":"2019/Elisa-Yocto/#criacao-da-imagem","text":"Primeiro precisamos inicializar o ambiente de desenvolvimento: $ cd poky $ source oe-init-build-env Clone a layer da altera da seguinte maneira: $ cd poky $ git clone https://github.com/kraj/meta-altera.git Mude a vari\u00e1vel MACHINE para \"cyclone5\" no arquivo de configura\u00e7\u00e3o local.conf Adicione uma layer ao arquivo de configura\u00e7\u00e3o de layers: $ cd ~/poky/build $ bitbake-layers add-layer ../meta-altera Mas nao consegui nem compilar usando BitBake.","title":"Cria\u00e7\u00e3o da Imagem"},{"location":"2019/Gabriel-TensorFlow/","text":"Gabriel Moreira - TensorFlow \u00b6 Aluno: Gabriel Moreira Curso: Engenharia da Computa\u00e7\u00e3o Semestre: 9 Contato: Link tutorial oficial: https://github.com/gabsmoreira/speech_recognition Ano: 2019 Hardware utilizado no tutorial Jetson Nano JetBot O objetivo do tutorial \u00e9 implementar um simples sistema de reconhecimento de comandos por voz com alguns ajustes em uma placa da NVIDIA Jetson Nano. Tal placa possui uma GPU incluida, o que a torna ideal para executar programas que fazem uso de redes neurais. Configurando Jetson Nano \u00b6 ISO \u00b6 Antes de tudo, precisamos preparar a placa Jetson Nano para a prototipa\u00e7\u00e3o. Para isso, \u00e9 necess\u00e1rio fazer o download da imagem do sistema operacional oferecido pela pr\u00f3pria NVIDIA. Fa\u00e7a o download da imagem nesse link: https://developer.nvidia.com/jetson-nano-sd-card-image-r3223 Em seguida, fa\u00e7a o download do programa que escreve a imagem no cart\u00e3o SD, chamado Etcher. Isso facilitar\u00e1 muito o desenvolvimento. Link do Etcher: https://www.balena.io/etcher Instale o Etcher e execute-o. A seguinte tela ir\u00e1 aparecer. Selecione a imagem e o disco corretamente e clique em Flash! Isso pode levar de 10-15 minutos para ser feito. V\u00e1 tomar um caf\u00e9! \u2615 Assim que o processo for conclu\u00eddo, remova o cart\u00e3o do computador e coloque na placa. Conectar o hardware \u00b6 Antes de tudo, conecte a placa Jetson em um monitor usando a sa\u00edda HDMI. Conecte tamb\u00e9m o mouse, teclado e o cabo Ethernet. Est\u00e1 na hora de completar os passos para a configura\u00e7\u00e3o do sistema operacional. Isso requer a escolha de um usu\u00e1rio, senha e mais algumas configura\u00e7\u00f5es que n\u00e3o s\u00e3o relevantes para o projeto. Conecte agora o microfone na placa usando um adaptador USB. Para verificar se o microfone foi devidamente reconhecido pelo sistema operacional execute o comando dmesg . $ sudo dmesg | tail -n10 Atualizando e instalando depend\u00eancias \u00b6 No linux da Jetson Nano, executar: Update de libs e packages: $ sudo apt update $ sudo apt upgrade Instalar Pip3: $ sudo apt install python3-pip $ sudo pip3 install -U pip Instalar depend\u00eancias do TensorFlow: $ sudo apt install libhdf5-serial-dev hdf5-tools libhdf5-dev zlib1g-dev zip libjpeg8-dev $ sudo pip3 install -U numpy == 1 .16.1 future == 0 .17.1 mock == 3 .0.5 h5py == 2 .9.0 keras_preprocessing == 1 .0.5 keras_applications == 1 .0.6 enum34 futures testresources setuptools protobuf Instalar Tensorflow: $ sudo pip3 install --pre --extra-index-url https://developer.download.nvidia.com/compute/redist/jp/v42 tensorflow-gpu $ sudo pip3 install -U pip Testando \u00b6 Testar instala\u00e7\u00e3o do TensorFlow: $ python3 >>> import tensorflow as tf O comando acima deve executar sem nenhum erro se o TensorFlow tiver sido instalado corretamente. Download do exemplo do TensorFlow \u00b6 O TensorFlow possui um exemplo em seu reposit\u00f3rio de utiliza\u00e7\u00e3o de redes neurais para reconhecimento de comandos por voz. Nesse tutorial, utilizaremos esse mesmo exemplo com algumas adapta\u00e7\u00f5es, uma vez que o modelo fornecido recebe como input um arquivo de \u00e1udio .wav . Nosso objetivo \u00e9 criar um programa que recebe um stream de \u00e1udio que deve ser processado continuamente, assim como \u00e9 visto em assistentes de voz (Google e Siri). O primeiro passo \u00e9 clonar o reposit\u00f3rio raiz do TensorFlow. $ git clone https://github.com/tensorflow/tensorflow.git Esse comando pode demorar um pouco para ser executado, uma vez que o reposit\u00f3rio \u00e9 grande. V\u00e1 tomar um caf\u00e9! \u2615 V\u00e1 at\u00e9 a pasta do exemplo que queremos executar. $ cd tensorflow/tensorflow/examples/speech_commands/ Note que na pasta existem diversos arquivos, os principais s\u00e3o: train.py : utilizado para treinar o modelo. freeze.py : utilizado para compilar o modelo treinado. label_wav.py : utilizado para reconhecer um comando, dado um arquivo .wav de input e um modelo previamente treinado O segundo passo \u00e9 treinar a rede neural para que fique com uma boa acur\u00e1cia e consiga processar os nossos comandos de voz. Para isso execute o script train.py com os seguintes par\u00e2metros. $ python3 train.py Para que o modelo fique aceit\u00e1vel, \u00e9 necess\u00e1rio deixar pelo menos 8 horas treinando. Caso voc\u00ea n\u00e3o tenha esse tempo, o link para o modelo treinado (e compilado) est\u00e1 aqui: https://github.com/gabsmoreira/speech_recognition/raw/master/my_frozen_graph.pb A placa Jetson n\u00e3o foi projetada para treinar redes neurais, o ideal seria fazer isso em um computador mais potente e depois transferir o arquivo contento os pesos da rede neural via SCP . Com o modelo treinado, agora compile usando o checkpoint que quiser: $ python3 freeze.py --start_checkpoint = conv.ckpt-12000 --output_file = my_frozen_graph.pb Agora teste o modelo treinado. Para isso, \u00e9 necess\u00e1rio ter o path das labels do modelo (que normalmente est\u00e1 localizado no /tmp/speech_commands_train/conv_labels.txt ) $ python3 label_wav.py --graph = my_frozen_graph.pb --labels ={ PATH DAS LABELS } --wav ={ PATH DO WAV FILE } Modificando o script \u00b6 O primeiro passo \u00e9 criar um pequeno exemplo de captura e processamento de stream de \u00e1udio usando o pyaudio . Antes de criar o novo arquivo, instale a biblioteca acima. $ pip3 install pyaudio Crie um arquivo com o nome audio_stream.py e coloque o seguinte c\u00f3digo: from __future__ import absolute_import from __future__ import division from __future__ import print_function import argparse import sys import pyaudio import numpy as np import audioop import wave import tensorflow as tf import time FLAGS = None CHUNK = 4096 # number of data points to read at a time RATE = 16000 # time resolution of the recording device (Hz) CHANNELS = 1 # number of channels FORMAT = pyaudio . paInt16 # audio format from pyaudio p = pyaudio . PyAudio () # start the PyAudio class devinfo = p . get_device_info_by_index ( 0 ) # get the first recorder device # stream from pyaudio stream = p . open ( format = FORMAT , channels = CHANNELS , rate = RATE , input = True , frames_per_buffer = CHUNK ) while True : # transform data into a numpy array data = np . fromstring ( stream . read ( CHUNK ), dtype = np . int16 ) # get audio rms rms = audioop . rms ( data , 2 ) # if audio rms reaches 900 or more set recording for true # and start appending the data into the frames array. # this means someone is talking if rms > 900 : if recording == False : recording = True frames . append ( data ) else : if recording == True : time_from_previous = time . time () # get data from stream for the next 0.5 seconds # after the volume while time . time () - time_from_previous < 0.5 : data = np . fromstring ( stream . read ( CHUNK ), dtype = np . int16 ) frames . append ( data ) # write frames inside wav file _file = wave . open ( \"out.wav\" , \"wb\" ) _file . setnchannels ( CHANNELS ) _file . setsampwidth ( p . get_sample_size ( FORMAT )) _file . setframerate ( RATE ) _file . writeframes ( b '' . join ( frames )) _file . close () # clear frames array since the data was # written inside wav file frames = [] recording = False A ideia \u00e9 criar um stream que comeca a gravar os dados do \u00e1udio em uma array assim que o \"volume\" do \u00e1udio passa de 900 (isso pode depender do microfone usado) e para depois de 0.5 segundos assim que o audio volta a ficar com um valor menor que 900. Tal array \u00e9 escrita em um arquivo .wav constantemente. Com esse c\u00f3digo, transformamos um stream de \u00e1udio em diversos .wav que agora podem ser usados no modelo treinado. O que falta ent\u00e3o \u00e9 unir esse c\u00f3digo do stream de \u00e1udio com a predi\u00e7\u00e3o do modelo. C\u00f3digo fonte, python from __future__ import absolute_import from __future__ import division from __future__ import print_function import argparse import sys import pyaudio import numpy as np import audioop import wave import tensorflow as tf import time FLAGS = None CHUNK = 4096 # number of data points to read at a time RATE = 16000 # time resolution of the recording device (Hz) CHANNELS = 1 # number of channels FORMAT = pyaudio . paInt16 # audio format from pyaudio p = pyaudio . PyAudio () # start the PyAudio class devinfo = p . get_device_info_by_index ( 0 ) # get the first recorder device # stream from pyaudio stream = p . open ( format = FORMAT , channels = CHANNELS , rate = RATE , input = True , frames_per_buffer = CHUNK ) def load_graph ( filename ): \"\"\"Unpersists graph from file as default graph.\"\"\" with tf . io . gfile . GFile ( filename , 'rb' ) as f : graph_def = tf . compat . v1 . GraphDef () graph_def . ParseFromString ( f . read ()) tf . import_graph_def ( graph_def , name = '' ) def load_labels ( filename ): \"\"\"Read in labels, one label per line.\"\"\" return [ line . rstrip () for line in tf . io . gfile . GFile ( filename )] def run_graph ( wav_data , labels , input_layer_name , output_layer_name , num_top_predictions ): \"\"\"Runs the audio data through the graph and prints predictions.\"\"\" with tf . compat . v1 . Session () as sess : # Feed the audio data as input to the graph. # predictions will contain a two-dimensional array, where one # dimension represents the input image count, and the other has # predictions per class softmax_tensor = sess . graph . get_tensor_by_name ( output_layer_name ) predictions , = sess . run ( softmax_tensor , { input_layer_name : wav_data }) # Sort to show labels in order of confidence top_k = predictions . argsort ()[ - num_top_predictions :][:: - 1 ] for node_id in top_k : human_string = labels [ node_id ] score = predictions [ node_id ] print ( ' %s (score = %.5f )' % ( human_string , score )) return 0 def label_wav ( wav , labels , graph , input_name , output_name , how_many_labels ): \"\"\"Loads the model and labels, and runs the inference to print predictions.\"\"\" if not wav or not tf . io . gfile . exists ( wav ): tf . compat . v1 . logging . fatal ( 'Audio file does not exist %s ' , wav ) if not labels or not tf . io . gfile . exists ( labels ): tf . compat . v1 . logging . fatal ( 'Labels file does not exist %s ' , labels ) if not graph or not tf . io . gfile . exists ( graph ): tf . compat . v1 . logging . fatal ( 'Graph file does not exist %s ' , graph ) labels_list = load_labels ( labels ) # load graph, which is stored in the default session load_graph ( graph ) with open ( wav , 'rb' ) as wav_file : wav_data = wav_file . read () run_graph ( wav_data , labels_list , input_name , output_name , how_many_labels ) def prepare ( graph , labels ): \"\"\"Loads data labels and tensor graphs\"\"\" labels_list = load_labels ( labels ) load_graph ( graph ) return labels_list def main ( _ ): # initialize variables and prepare graph labels = prepare ( FLAGS . graph , FLAGS . labels ) recording = False frames = [] time_from_previous = 0 with tf . compat . v1 . Session () as sess : # loads softmax tensor softmax_tensor = sess . graph . get_tensor_by_name ( FLAGS . output_name ) while True : # transform data into a numpy array data = np . fromstring ( stream . read ( CHUNK ), dtype = np . int16 ) # get audio rms rms = audioop . rms ( data , 2 ) # if audio rms reaches 900 or more set recording for true # and start appending the data into the frames array. # this means someone is talking if rms > 900 : if recording == False : recording = True frames . append ( data ) else : if recording == True : time_from_previous = time . time () # get data from stream for the next 0.5 seconds # after the volume while time . time () - time_from_previous < 0.5 : data = np . fromstring ( stream . read ( CHUNK ), dtype = np . int16 ) frames . append ( data ) # write frames inside wav file _file = wave . open ( \"out.wav\" , \"wb\" ) _file . setnchannels ( CHANNELS ) _file . setsampwidth ( p . get_sample_size ( FORMAT )) _file . setframerate ( RATE ) _file . writeframes ( b '' . join ( frames )) _file . close () # clear frames array since the data was # written inside wav file frames = [] # read wav file to get the input data for # our neural network with open ( 'out.wav' , 'rb' ) as wav_file : wav_data = wav_file . read () # this is where the model predicts based on the input data predictions , = sess . run ( softmax_tensor , { FLAGS . input_name : wav_data }) # Sort to show labels in order of confidence top_k = predictions . argsort ()[ - FLAGS . how_many_labels :][:: - 1 ] for node_id in top_k : human_string = labels [ node_id ] score = predictions [ node_id ] print ( ' %s (score = %.5f )' % ( human_string , score )) recording = False if __name__ == '__main__' : parser = argparse . ArgumentParser () parser . add_argument ( '--wav' , type = str , default = '' , help = 'Audio file to be identified.' ) parser . add_argument ( '--graph' , type = str , default = '' , help = 'Model to use for identification.' ) parser . add_argument ( '--labels' , type = str , default = '' , help = 'Path to file containing labels.' ) parser . add_argument ( '--input_name' , type = str , default = 'wav_data:0' , help = 'Name of WAVE data input node in model.' ) parser . add_argument ( '--output_name' , type = str , default = 'labels_softmax:0' , help = 'Name of node outputting a prediction in the model.' ) parser . add_argument ( '--how_many_labels' , type = int , default = 1 , help = 'Number of results to show.' ) FLAGS , unparsed = parser . parse_known_args () tf . compat . v1 . app . run ( main = main , argv = [ sys . argv [ 0 ]] + unparsed ) Agora para testar o script, basta executar o arquivo python. $ python3 audio_stream.py Veja o v\u00eddeo da demonstra\u00e7\u00e3o Extra - controle do JetBot por comando de voz \u00b6 Para fazer essa parte do tutorial, \u00e9 necess\u00e1rio ter o mesmo material/recursos propostos no link do JetBot. Link do tutorial do JetBot: https://github.com/NVIDIA-AI-IOT/jetbot/wiki/bill-of-materials Para montar a parte de hardware, basta seguir esse tutorial: https://github.com/NVIDIA-AI-IOT/jetbot/wiki/Hardware-Setup A parte de software j\u00e1 temos, basta instalar s\u00f3 mais alguns pacotes. Intalar bibliotecas adicionais \u00b6 $ cd $ wget https://nvidia.box.com/shared/static/phqe92v26cbhqjohwtvxorrwnmrnfx1o.whl -O torch-1.3.0-cp36-cp36m-linux_aarch64.whl $ pip3 install numpy torch-1.3.0-cp36-cp36m-linux_aarch64.whl $ pip3 install traitlets Instalar biblioteca do JetBot \u00b6 $ git clone https://github.com/NVIDIA-AI-IOT/jetbot $ cd jetbot $ sudo python3 setup.py install Para transformar o c\u00f3digo anterior que temos para controlar o robo \u00e9 bem simples: Basta instanciar um objeto robot antes de todo o script, lembrando sempre de importar a biblioteca do JetBot. Eu tamb\u00e9m optei por fazer um dicion\u00e1rio de a\u00e7\u00f5es poss\u00edveis do rob\u00f4, para ser mais econ\u00f4mico nos \"ifs\". from jetbot import Robot robot = Robot () function_chooser = { 'left' : robot . left , 'right' : robot . right , 'go' : robot . forward , 'down' : robot . backward } Agora o que resta \u00e9 fazer o rob\u00f4 executar a a\u00e7\u00e3o assim que ele reconhece o comando. for node_id in top_k : human_string = labels [ node_id ] score = predictions [ node_id ] if human_string in [ 'left' , 'right' , 'go' , 'down' ]: # run robot action function_chooser [ human_string ]( velocity = 0.3 ) time . sleep ( 0.5 ) robot . stop () O c\u00f3digo inteiro do movimento do rob\u00f4 est\u00e1 no arquivo chamado robot_control.py A foto da montagem final ficou assim: Veja o v\u00eddeo da demonstra\u00e7\u00e3o:","title":"Gabriel Moreira - TensorFlow"},{"location":"2019/Gabriel-TensorFlow/#gabriel-moreira-tensorflow","text":"Aluno: Gabriel Moreira Curso: Engenharia da Computa\u00e7\u00e3o Semestre: 9 Contato: Link tutorial oficial: https://github.com/gabsmoreira/speech_recognition Ano: 2019 Hardware utilizado no tutorial Jetson Nano JetBot O objetivo do tutorial \u00e9 implementar um simples sistema de reconhecimento de comandos por voz com alguns ajustes em uma placa da NVIDIA Jetson Nano. Tal placa possui uma GPU incluida, o que a torna ideal para executar programas que fazem uso de redes neurais.","title":"Gabriel Moreira - TensorFlow"},{"location":"2019/Gabriel-TensorFlow/#configurando-jetson-nano","text":"","title":"Configurando Jetson Nano"},{"location":"2019/Gabriel-TensorFlow/#iso","text":"Antes de tudo, precisamos preparar a placa Jetson Nano para a prototipa\u00e7\u00e3o. Para isso, \u00e9 necess\u00e1rio fazer o download da imagem do sistema operacional oferecido pela pr\u00f3pria NVIDIA. Fa\u00e7a o download da imagem nesse link: https://developer.nvidia.com/jetson-nano-sd-card-image-r3223 Em seguida, fa\u00e7a o download do programa que escreve a imagem no cart\u00e3o SD, chamado Etcher. Isso facilitar\u00e1 muito o desenvolvimento. Link do Etcher: https://www.balena.io/etcher Instale o Etcher e execute-o. A seguinte tela ir\u00e1 aparecer. Selecione a imagem e o disco corretamente e clique em Flash! Isso pode levar de 10-15 minutos para ser feito. V\u00e1 tomar um caf\u00e9! \u2615 Assim que o processo for conclu\u00eddo, remova o cart\u00e3o do computador e coloque na placa.","title":"ISO"},{"location":"2019/Gabriel-TensorFlow/#conectar-o-hardware","text":"Antes de tudo, conecte a placa Jetson em um monitor usando a sa\u00edda HDMI. Conecte tamb\u00e9m o mouse, teclado e o cabo Ethernet. Est\u00e1 na hora de completar os passos para a configura\u00e7\u00e3o do sistema operacional. Isso requer a escolha de um usu\u00e1rio, senha e mais algumas configura\u00e7\u00f5es que n\u00e3o s\u00e3o relevantes para o projeto. Conecte agora o microfone na placa usando um adaptador USB. Para verificar se o microfone foi devidamente reconhecido pelo sistema operacional execute o comando dmesg . $ sudo dmesg | tail -n10","title":"Conectar o hardware"},{"location":"2019/Gabriel-TensorFlow/#atualizando-e-instalando-dependencias","text":"No linux da Jetson Nano, executar: Update de libs e packages: $ sudo apt update $ sudo apt upgrade Instalar Pip3: $ sudo apt install python3-pip $ sudo pip3 install -U pip Instalar depend\u00eancias do TensorFlow: $ sudo apt install libhdf5-serial-dev hdf5-tools libhdf5-dev zlib1g-dev zip libjpeg8-dev $ sudo pip3 install -U numpy == 1 .16.1 future == 0 .17.1 mock == 3 .0.5 h5py == 2 .9.0 keras_preprocessing == 1 .0.5 keras_applications == 1 .0.6 enum34 futures testresources setuptools protobuf Instalar Tensorflow: $ sudo pip3 install --pre --extra-index-url https://developer.download.nvidia.com/compute/redist/jp/v42 tensorflow-gpu $ sudo pip3 install -U pip","title":"Atualizando e instalando depend\u00eancias"},{"location":"2019/Gabriel-TensorFlow/#testando","text":"Testar instala\u00e7\u00e3o do TensorFlow: $ python3 >>> import tensorflow as tf O comando acima deve executar sem nenhum erro se o TensorFlow tiver sido instalado corretamente.","title":"Testando"},{"location":"2019/Gabriel-TensorFlow/#download-do-exemplo-do-tensorflow","text":"O TensorFlow possui um exemplo em seu reposit\u00f3rio de utiliza\u00e7\u00e3o de redes neurais para reconhecimento de comandos por voz. Nesse tutorial, utilizaremos esse mesmo exemplo com algumas adapta\u00e7\u00f5es, uma vez que o modelo fornecido recebe como input um arquivo de \u00e1udio .wav . Nosso objetivo \u00e9 criar um programa que recebe um stream de \u00e1udio que deve ser processado continuamente, assim como \u00e9 visto em assistentes de voz (Google e Siri). O primeiro passo \u00e9 clonar o reposit\u00f3rio raiz do TensorFlow. $ git clone https://github.com/tensorflow/tensorflow.git Esse comando pode demorar um pouco para ser executado, uma vez que o reposit\u00f3rio \u00e9 grande. V\u00e1 tomar um caf\u00e9! \u2615 V\u00e1 at\u00e9 a pasta do exemplo que queremos executar. $ cd tensorflow/tensorflow/examples/speech_commands/ Note que na pasta existem diversos arquivos, os principais s\u00e3o: train.py : utilizado para treinar o modelo. freeze.py : utilizado para compilar o modelo treinado. label_wav.py : utilizado para reconhecer um comando, dado um arquivo .wav de input e um modelo previamente treinado O segundo passo \u00e9 treinar a rede neural para que fique com uma boa acur\u00e1cia e consiga processar os nossos comandos de voz. Para isso execute o script train.py com os seguintes par\u00e2metros. $ python3 train.py Para que o modelo fique aceit\u00e1vel, \u00e9 necess\u00e1rio deixar pelo menos 8 horas treinando. Caso voc\u00ea n\u00e3o tenha esse tempo, o link para o modelo treinado (e compilado) est\u00e1 aqui: https://github.com/gabsmoreira/speech_recognition/raw/master/my_frozen_graph.pb A placa Jetson n\u00e3o foi projetada para treinar redes neurais, o ideal seria fazer isso em um computador mais potente e depois transferir o arquivo contento os pesos da rede neural via SCP . Com o modelo treinado, agora compile usando o checkpoint que quiser: $ python3 freeze.py --start_checkpoint = conv.ckpt-12000 --output_file = my_frozen_graph.pb Agora teste o modelo treinado. Para isso, \u00e9 necess\u00e1rio ter o path das labels do modelo (que normalmente est\u00e1 localizado no /tmp/speech_commands_train/conv_labels.txt ) $ python3 label_wav.py --graph = my_frozen_graph.pb --labels ={ PATH DAS LABELS } --wav ={ PATH DO WAV FILE }","title":"Download do exemplo do TensorFlow"},{"location":"2019/Gabriel-TensorFlow/#modificando-o-script","text":"O primeiro passo \u00e9 criar um pequeno exemplo de captura e processamento de stream de \u00e1udio usando o pyaudio . Antes de criar o novo arquivo, instale a biblioteca acima. $ pip3 install pyaudio Crie um arquivo com o nome audio_stream.py e coloque o seguinte c\u00f3digo: from __future__ import absolute_import from __future__ import division from __future__ import print_function import argparse import sys import pyaudio import numpy as np import audioop import wave import tensorflow as tf import time FLAGS = None CHUNK = 4096 # number of data points to read at a time RATE = 16000 # time resolution of the recording device (Hz) CHANNELS = 1 # number of channels FORMAT = pyaudio . paInt16 # audio format from pyaudio p = pyaudio . PyAudio () # start the PyAudio class devinfo = p . get_device_info_by_index ( 0 ) # get the first recorder device # stream from pyaudio stream = p . open ( format = FORMAT , channels = CHANNELS , rate = RATE , input = True , frames_per_buffer = CHUNK ) while True : # transform data into a numpy array data = np . fromstring ( stream . read ( CHUNK ), dtype = np . int16 ) # get audio rms rms = audioop . rms ( data , 2 ) # if audio rms reaches 900 or more set recording for true # and start appending the data into the frames array. # this means someone is talking if rms > 900 : if recording == False : recording = True frames . append ( data ) else : if recording == True : time_from_previous = time . time () # get data from stream for the next 0.5 seconds # after the volume while time . time () - time_from_previous < 0.5 : data = np . fromstring ( stream . read ( CHUNK ), dtype = np . int16 ) frames . append ( data ) # write frames inside wav file _file = wave . open ( \"out.wav\" , \"wb\" ) _file . setnchannels ( CHANNELS ) _file . setsampwidth ( p . get_sample_size ( FORMAT )) _file . setframerate ( RATE ) _file . writeframes ( b '' . join ( frames )) _file . close () # clear frames array since the data was # written inside wav file frames = [] recording = False A ideia \u00e9 criar um stream que comeca a gravar os dados do \u00e1udio em uma array assim que o \"volume\" do \u00e1udio passa de 900 (isso pode depender do microfone usado) e para depois de 0.5 segundos assim que o audio volta a ficar com um valor menor que 900. Tal array \u00e9 escrita em um arquivo .wav constantemente. Com esse c\u00f3digo, transformamos um stream de \u00e1udio em diversos .wav que agora podem ser usados no modelo treinado. O que falta ent\u00e3o \u00e9 unir esse c\u00f3digo do stream de \u00e1udio com a predi\u00e7\u00e3o do modelo. C\u00f3digo fonte, python from __future__ import absolute_import from __future__ import division from __future__ import print_function import argparse import sys import pyaudio import numpy as np import audioop import wave import tensorflow as tf import time FLAGS = None CHUNK = 4096 # number of data points to read at a time RATE = 16000 # time resolution of the recording device (Hz) CHANNELS = 1 # number of channels FORMAT = pyaudio . paInt16 # audio format from pyaudio p = pyaudio . PyAudio () # start the PyAudio class devinfo = p . get_device_info_by_index ( 0 ) # get the first recorder device # stream from pyaudio stream = p . open ( format = FORMAT , channels = CHANNELS , rate = RATE , input = True , frames_per_buffer = CHUNK ) def load_graph ( filename ): \"\"\"Unpersists graph from file as default graph.\"\"\" with tf . io . gfile . GFile ( filename , 'rb' ) as f : graph_def = tf . compat . v1 . GraphDef () graph_def . ParseFromString ( f . read ()) tf . import_graph_def ( graph_def , name = '' ) def load_labels ( filename ): \"\"\"Read in labels, one label per line.\"\"\" return [ line . rstrip () for line in tf . io . gfile . GFile ( filename )] def run_graph ( wav_data , labels , input_layer_name , output_layer_name , num_top_predictions ): \"\"\"Runs the audio data through the graph and prints predictions.\"\"\" with tf . compat . v1 . Session () as sess : # Feed the audio data as input to the graph. # predictions will contain a two-dimensional array, where one # dimension represents the input image count, and the other has # predictions per class softmax_tensor = sess . graph . get_tensor_by_name ( output_layer_name ) predictions , = sess . run ( softmax_tensor , { input_layer_name : wav_data }) # Sort to show labels in order of confidence top_k = predictions . argsort ()[ - num_top_predictions :][:: - 1 ] for node_id in top_k : human_string = labels [ node_id ] score = predictions [ node_id ] print ( ' %s (score = %.5f )' % ( human_string , score )) return 0 def label_wav ( wav , labels , graph , input_name , output_name , how_many_labels ): \"\"\"Loads the model and labels, and runs the inference to print predictions.\"\"\" if not wav or not tf . io . gfile . exists ( wav ): tf . compat . v1 . logging . fatal ( 'Audio file does not exist %s ' , wav ) if not labels or not tf . io . gfile . exists ( labels ): tf . compat . v1 . logging . fatal ( 'Labels file does not exist %s ' , labels ) if not graph or not tf . io . gfile . exists ( graph ): tf . compat . v1 . logging . fatal ( 'Graph file does not exist %s ' , graph ) labels_list = load_labels ( labels ) # load graph, which is stored in the default session load_graph ( graph ) with open ( wav , 'rb' ) as wav_file : wav_data = wav_file . read () run_graph ( wav_data , labels_list , input_name , output_name , how_many_labels ) def prepare ( graph , labels ): \"\"\"Loads data labels and tensor graphs\"\"\" labels_list = load_labels ( labels ) load_graph ( graph ) return labels_list def main ( _ ): # initialize variables and prepare graph labels = prepare ( FLAGS . graph , FLAGS . labels ) recording = False frames = [] time_from_previous = 0 with tf . compat . v1 . Session () as sess : # loads softmax tensor softmax_tensor = sess . graph . get_tensor_by_name ( FLAGS . output_name ) while True : # transform data into a numpy array data = np . fromstring ( stream . read ( CHUNK ), dtype = np . int16 ) # get audio rms rms = audioop . rms ( data , 2 ) # if audio rms reaches 900 or more set recording for true # and start appending the data into the frames array. # this means someone is talking if rms > 900 : if recording == False : recording = True frames . append ( data ) else : if recording == True : time_from_previous = time . time () # get data from stream for the next 0.5 seconds # after the volume while time . time () - time_from_previous < 0.5 : data = np . fromstring ( stream . read ( CHUNK ), dtype = np . int16 ) frames . append ( data ) # write frames inside wav file _file = wave . open ( \"out.wav\" , \"wb\" ) _file . setnchannels ( CHANNELS ) _file . setsampwidth ( p . get_sample_size ( FORMAT )) _file . setframerate ( RATE ) _file . writeframes ( b '' . join ( frames )) _file . close () # clear frames array since the data was # written inside wav file frames = [] # read wav file to get the input data for # our neural network with open ( 'out.wav' , 'rb' ) as wav_file : wav_data = wav_file . read () # this is where the model predicts based on the input data predictions , = sess . run ( softmax_tensor , { FLAGS . input_name : wav_data }) # Sort to show labels in order of confidence top_k = predictions . argsort ()[ - FLAGS . how_many_labels :][:: - 1 ] for node_id in top_k : human_string = labels [ node_id ] score = predictions [ node_id ] print ( ' %s (score = %.5f )' % ( human_string , score )) recording = False if __name__ == '__main__' : parser = argparse . ArgumentParser () parser . add_argument ( '--wav' , type = str , default = '' , help = 'Audio file to be identified.' ) parser . add_argument ( '--graph' , type = str , default = '' , help = 'Model to use for identification.' ) parser . add_argument ( '--labels' , type = str , default = '' , help = 'Path to file containing labels.' ) parser . add_argument ( '--input_name' , type = str , default = 'wav_data:0' , help = 'Name of WAVE data input node in model.' ) parser . add_argument ( '--output_name' , type = str , default = 'labels_softmax:0' , help = 'Name of node outputting a prediction in the model.' ) parser . add_argument ( '--how_many_labels' , type = int , default = 1 , help = 'Number of results to show.' ) FLAGS , unparsed = parser . parse_known_args () tf . compat . v1 . app . run ( main = main , argv = [ sys . argv [ 0 ]] + unparsed ) Agora para testar o script, basta executar o arquivo python. $ python3 audio_stream.py Veja o v\u00eddeo da demonstra\u00e7\u00e3o","title":"Modificando o script"},{"location":"2019/Gabriel-TensorFlow/#extra-controle-do-jetbot-por-comando-de-voz","text":"Para fazer essa parte do tutorial, \u00e9 necess\u00e1rio ter o mesmo material/recursos propostos no link do JetBot. Link do tutorial do JetBot: https://github.com/NVIDIA-AI-IOT/jetbot/wiki/bill-of-materials Para montar a parte de hardware, basta seguir esse tutorial: https://github.com/NVIDIA-AI-IOT/jetbot/wiki/Hardware-Setup A parte de software j\u00e1 temos, basta instalar s\u00f3 mais alguns pacotes.","title":"Extra - controle do JetBot por comando de voz"},{"location":"2019/Gabriel-TensorFlow/#intalar-bibliotecas-adicionais","text":"$ cd $ wget https://nvidia.box.com/shared/static/phqe92v26cbhqjohwtvxorrwnmrnfx1o.whl -O torch-1.3.0-cp36-cp36m-linux_aarch64.whl $ pip3 install numpy torch-1.3.0-cp36-cp36m-linux_aarch64.whl $ pip3 install traitlets","title":"Intalar bibliotecas adicionais"},{"location":"2019/Gabriel-TensorFlow/#instalar-biblioteca-do-jetbot","text":"$ git clone https://github.com/NVIDIA-AI-IOT/jetbot $ cd jetbot $ sudo python3 setup.py install Para transformar o c\u00f3digo anterior que temos para controlar o robo \u00e9 bem simples: Basta instanciar um objeto robot antes de todo o script, lembrando sempre de importar a biblioteca do JetBot. Eu tamb\u00e9m optei por fazer um dicion\u00e1rio de a\u00e7\u00f5es poss\u00edveis do rob\u00f4, para ser mais econ\u00f4mico nos \"ifs\". from jetbot import Robot robot = Robot () function_chooser = { 'left' : robot . left , 'right' : robot . right , 'go' : robot . forward , 'down' : robot . backward } Agora o que resta \u00e9 fazer o rob\u00f4 executar a a\u00e7\u00e3o assim que ele reconhece o comando. for node_id in top_k : human_string = labels [ node_id ] score = predictions [ node_id ] if human_string in [ 'left' , 'right' , 'go' , 'down' ]: # run robot action function_chooser [ human_string ]( velocity = 0.3 ) time . sleep ( 0.5 ) robot . stop () O c\u00f3digo inteiro do movimento do rob\u00f4 est\u00e1 no arquivo chamado robot_control.py A foto da montagem final ficou assim: Veja o v\u00eddeo da demonstra\u00e7\u00e3o:","title":"Instalar biblioteca do JetBot"},{"location":"2019/Leo-OpenCL/","text":"Leonardo Medeiros - Tutorial OpenCL \u00b6 Aluno: Leonardo Medeiros Curso: Engenharia da Computa\u00e7\u00e3o Semestre: 9 Contato: Link tutorial oficial: https://github.com/Leotayner/Tutorial-OpenCL Ano: 2019 Hardware utilizado no tutorial DE10-Standard OpenCL \u00b6 OpenCL (Open Computing Language) \u00e9 uma API de baixo n\u00edvel para programa\u00e7\u00e3o de alto desempenho em ambientes computacionais heterog\u00eaneos compostos por CPUs, GPUs, e outros processadores paralelos como FPGA, permitindo desenvolver aplica\u00e7\u00f5es port\u00e1veis e eficientes. Arquitetura OpenCL \u00b6 O padr\u00e3o OpenCL prop\u00f5e uma arquitetura em que h\u00e1 um host que agrega um ou mais devices, cada device possui unidades de computa\u00e7\u00e3o que cont\u00e9m elementos de processamento. O host \u00e9 respons\u00e1vel pelo reconhecimento e inicializa\u00e7\u00e3o dos dispositivos, bem como pela transfer\u00eancia de dados e tarefas para execu\u00e7\u00e3o. O device \u00e9 respons\u00e1vel por processar todos esses dados ao executar as tarefas programadas. Na arquitetura do device, considerando o contexto de programa\u00e7\u00e3o paralela, o equivalente a uma thread \u00e9 o work-item, que representa a menor unidade de tarefa. Esses works-itens s\u00e3o agrupados em blocos denominados work-group, onde os works-itens de um mesmo bloco podem se comunicar e se sincronizar Os work-groups por sua vez s\u00e3o organizados em grids, onde dever\u00e3o ter a mesma dimens\u00e3o, podendo a grid ser unidimensional, bidimensional ou tridimensional. Figura 1 - Arquitetura OpenCL De forma geral essa estrutura possui tr\u00eas tipos de mem\u00f3rias: Private Memory Estritamente atrelada ao seu respectivo worker, apenas seu worker pode acessa-la Local memory Estritamente atrelada ao seu respectivo bloco, todos os workers dentro do bloco podem acess\u00e1-la Global Constant Memory data Cache Cache da memoria global do device, todos os blocos podem acessa-la Global Constant Memory memoria global do device Figura 1 - Arquitetura OpenCL FPGA vs CPU \u00b6 A arquitetura de funcionamento de acessos de mem\u00f3ria e configura\u00e7\u00e3o do programa na estrutura OpenCL \u00e9 um pouco diferente da estrutura geral apresentada anteriormente, a \u00fanica diferen\u00e7a \u00e9 que a mem\u00f3ria do host e do device est\u00e3o contidas no mesmo dispositivo, consequentemente o tempo de transfer\u00eancia dos dados entre Host e o device \u00e9 muito menor, nessa estrutura o ARM \u00e9 respons\u00e1vel por programar a FPGA atrav\u00e9s do barramento AxI, e transmitir dados para a mem\u00f3ria global DDR3, da qual a FPGA faz uso para executar suas tarefas como device. Ao analisar os ganhos ao utilizar o OpenCL em FPGA, al\u00e9m da vantagem do baixo tempo de transfer\u00eancia de dados citado anteriormente, tamb\u00e9m h\u00e1 as vantagens caracter\u00edsticas desse processador, como flexibilidade de hardware e sua quantidade massiva de cores. Figura 2 - Arquitetura OpenCL-FPGA Enquanto que a estrutura em CPU, possui uma quantidade reduzida de cores com unidades aritm\u00e9ticas potentes para reduzir lat\u00eancia de opera\u00e7\u00f5es. Figura 4 - Arquitetura CPU Logo a estrutura em FPGA apresenta maior desempenho comparada a CPU para programas paralelos, devido a seu grande n\u00famero de cores e baixo tempo de transfer\u00eancia de dados, enquanto a CPU apresenta maior desempenho que a fpga para programas sequenciais, devido a suas unidades aritm\u00e9ticas potentes. Tutorial OpenCL-DE-10 \u00b6 1. Requerimentos de Sistema \u00b6 Placa Terasic DE10-Standard Cart\u00e3o microSD com ao menos 4GB Leitor de cart\u00e3o microSD Cabo USB (tipo A para mini-B) Host PC com Porta USB 64-bit Windows 7 ou Linux ( este tutorial utiliza linux) 32GB de memoria \u00e9 recomendado PuTTY ou Minicom(Linux) utility Intel Quartus Prime v18.1 instalado com licen\u00e7a valida Intel OpenCL v18.1 instalado com licen\u00e7a valida Intel SoC EDS v18.1 instalado 2. Configurando a Infra Estrutura \u00b6 Essa etapa descreve como configurar o ambiente de desenvolvimento do OpenCL no Padr\u00e3o DE10-Standard. 2.1 Instala\u00e7\u00e3o de Software \u00b6 \u00c9 necess\u00e1rio instalar os seguintes softwares: Intel Quartus Standard e OpenCL SDK Intel SoC EDS DE10-Standard OpenCL Board Support Package (BSP) Ap\u00f3s a instala\u00e7\u00e3o do Quartus Prime e do OpenCL SDK, crie uma pasta com o nome terasic, a qual deve conter a pasta DE10-Standard-Opencl. A pasta criada deve estar no diret\u00f3rio board: /intelFPGA/18.1/hld/board 2.2 Instala\u00e7\u00e3o da Licensa Opencl \u00b6 \u00c9 necess\u00e1ria uma licen\u00e7a OpenCL para o Intel OpenCL SDK compilar o projeto. Em posse da licen\u00e7a \u00e9 necess\u00e1rio criar uma vari\u00e1vel de ambiente LM_LICENSE_FILE com a atribui\u00e7\u00e3o do diret\u00f3rio da licen\u00e7a. 2.3 Configurando variaveis de ambiente \u00b6 As seguintes vari\u00e1veis de ambiente devem ser configuradas para o funcionamento do projeto, isso pode ser feito adicionando as vari\u00e1veis a seguir ao arquivo .bash-rc (configura\u00e7\u00e3o permanente), ou em um arquivo.sh (configura\u00e7\u00e3o temporaria, utilizar $source arquivo.sh para ativar o ambiente). echo Opencl 18 .1 export LOCAL = /media/leonardo export QUARTUS_ROOTDIR = $LOCAL /FPGA/intelFPGA/18.1/quartus export ALTERAOCLSDKROOT = $LOCAL /FPGA/intelFPGA/18.1/hld export PATH = $PATH : $QUARTUS_ROOTDIR /bin: $LOCAL /FPGA/intelFPGA/18.1/embedded/ds-5/bin: $LOCAL /FPGA/intelFPGA/18.1/embedded/ds-5/sw/gcc/bin: $ALTERAOCLSDKROOT /bin: $ALTERAOCLSDKROOT /linux64/bin: export LD_LIBRARY_PATH = $ALTERAOCLSDKROOT /linux64/lib export AOCL_BOARD_PACKAGE_ROOT = $ALTERAOCLSDKROOT /board/terasic/de10_standard export QUARTUS_64BIT = 1 export LM_LICENSE_FILE = \"/home/leonardo/Downloads/1-R3OQLF_License.dat\" export INTELFPGAOCLSDKROOT = $LOCAL /FPGA/intelFPGA/18.1/hld 2.3 Verifica\u00e7\u00e3o do Ambiente \u00b6 Esta se\u00e7\u00e3o mostra como verificar se o ambiente OpenCL est\u00e1 configurado corretamente. Verificar Vers\u00e3o $ aocl version aocl 18.1.0.625 (Intel(R) FPGA SDK for OpenCL(TM), Version 18.1.0 Build 625 Standard Edition, Copyright (C) 2018 Intel Corporation) Verificar placa de destino $ aoc -list-boards Board list: de10_standard_sharedonly``` Board Package: /media/leonardo/FPGA/intelFPGA/18.1/hld/board/terasic/de10_standard 3. Compilar Projeto \u00b6 Esta se\u00e7\u00e3o mostra como compilar o kernel e o programa host do OpenCL, necess\u00e1rios para executar um programa em OpenCL. Compilar Kernel $ cd /media/leonardo/FPGA/intelFPGA/18.1/hld/board/terasic/de10_standard/test/vector_add_2 $ aoc device/vector_add.cl -o bin/vector_add.aocx --sw-dimm-partition -board=de10_standard_sharedonly -report Um arquivo .aocx ser\u00e1 gerado, este \u00e9 utilizado para a configura\u00e7\u00e3o dos kernels programados, configurando a execu\u00e7\u00e3o de tarefas e troca de informa\u00e7\u00f5es entre FPGA e sistema host. Warning A copila\u00e7\u00e3o do kernel \u00e9 muito lenta, pode levar horas. Compilar Programa Host $ cd /media/leonardo/FPGA/intelFPGA/18.1/embedded $ embedded_command_shell.sh $ cd /media/leonardo/FPGA/intelFPGA/18.1/hld/board/terasic/de10_standard/test/vector_add_2 $ make Um arquivo host ser\u00e1 gerado, esse arquivo \u00e9 basicamente o .o usual de uma compila\u00e7\u00e3o do GCC, arquivo intermedi\u00e1rio que ser\u00e1 utilizado em est\u00e1gios de execu\u00e7\u00e3o. Se ao executar o comando make ocorrer erros de include na biblioteca Cl adicione o par\u00e2metro ../../../../../host/include/ ao INC_DIRS no arquivo makefile 4. Embarcar Kernel \u00b6 Utilizaremos uma imagem .iso j\u00e1 gerada com as especifica\u00e7\u00f5es e que j\u00e1 possui todo o sistema necess\u00e1rio para executar o linux com OpenCL. Atrav\u00e9s da pasta DE10_standard_opencl extraia o arquivo de10_standard_opencl.img, esse arquivo \u00e9 uma c\u00f3pia bit a bit do que deve ser salvo no SDCard. Quando inserirmos um disco externo no linux o mesmo o associa a um 'device' na pasta '/dev/', para sabermos qual o nome do device que foi atribu\u00eddo ao SDcard, podemos usar o comando dmesg, que exibe o log do sistema operacional e nele podemos ver qual foi o \u00faltimo hardware detectado e qual device foi atribu\u00eddo: $ dmesg | tail 4789.207972] mmc0: new ultra high speed SDR50 SDHC card at address aaaa [4789.211680] mmcblk0: mmc0:aaaa SL16G 14.8 GiB [ 4789.215857] mmcblk0: p1 p2 p3 [ 4988.443942] mmcblk0: p1 p2 p3 Agora vamos salvar a .iso no SDcard. $ sudo dd bs=1M if=de10_standard_opencl.img of=/dev/sdc conv=fsync status=progress $ sync O sync \u00e9 necess\u00e1rio para que o kernel fa\u00e7a um flush do cache escrevendo realmente no SDCard todos os dados que foram endere\u00e7ados a ele. Agora devemos ter duas parti\u00e7\u00f5es vis\u00edveis: 524 MiB: FAT32 Script de configura\u00e7\u00e3o do uboot; Kernel comprimido; Device Tree Blob file u-boot.scr; zImage; socfpga.dtb 1 GiB: Filesystem (/) Os arquivos obtidos na compila\u00e7\u00e3o do kernel e host, respectivamente arquivo.ocx e host devem ser colocados na pasta /home/root/ da parti\u00e7\u00e3o de 1GiB, para serem executadas posteriormente na placa. 5. Ajustar a placa \u00b6 Verifique se o interruptor DIP (SW10) MSEL [4: 0] = 01010. 5. Conectar-se a placa \u00b6 Com a placa conectada ao USB do computador, para conectar-se ao kernel da sistema, deve-se utilizar o seguinte comando: $ screen /dev/ttyUSB0 115200,cs8 6. Executar o projeto \u00b6 Dentro do terminal do sistema: $ source ./init_opencl.sh $ aocl program /dev/acl0 vector_add.aocx $ ./host An\u00e1lises de Desempenho CPU vs OPENCL \u00b6 Ao comparar o tempo de execu\u00e7\u00e3o do programa vector_add , que realiza uma simples soma de vetores, entre a CPU e a FPGA foram obtidos os seguintes resultados. Size-Vector CPU FPGA 1000000 32.011 6.924 5000000 159.805 34.278 10000000 304.255 68.462 20000000 617.676 180.13 Como pode-se observar o desempenho da execu\u00e7\u00e3o na FPGA \u00e9 muito maior, embora a diferen\u00e7a num\u00e9rica seja pequena, deve-se lembrar que o arquivo de teste realiza uma simples opera\u00e7\u00e3o de soma de vetor, logo para programas mais complexos, o ganho de desempenho na FPGA seria mais expressivo. Note O teste da CPU \u00e9 single thread","title":"Leonardo Medeiros  - Tutorial OpenCL"},{"location":"2019/Leo-OpenCL/#leonardo-medeiros-tutorial-opencl","text":"Aluno: Leonardo Medeiros Curso: Engenharia da Computa\u00e7\u00e3o Semestre: 9 Contato: Link tutorial oficial: https://github.com/Leotayner/Tutorial-OpenCL Ano: 2019 Hardware utilizado no tutorial DE10-Standard","title":"Leonardo Medeiros  - Tutorial OpenCL"},{"location":"2019/Leo-OpenCL/#opencl","text":"OpenCL (Open Computing Language) \u00e9 uma API de baixo n\u00edvel para programa\u00e7\u00e3o de alto desempenho em ambientes computacionais heterog\u00eaneos compostos por CPUs, GPUs, e outros processadores paralelos como FPGA, permitindo desenvolver aplica\u00e7\u00f5es port\u00e1veis e eficientes.","title":"OpenCL"},{"location":"2019/Leo-OpenCL/#arquitetura-opencl","text":"O padr\u00e3o OpenCL prop\u00f5e uma arquitetura em que h\u00e1 um host que agrega um ou mais devices, cada device possui unidades de computa\u00e7\u00e3o que cont\u00e9m elementos de processamento. O host \u00e9 respons\u00e1vel pelo reconhecimento e inicializa\u00e7\u00e3o dos dispositivos, bem como pela transfer\u00eancia de dados e tarefas para execu\u00e7\u00e3o. O device \u00e9 respons\u00e1vel por processar todos esses dados ao executar as tarefas programadas. Na arquitetura do device, considerando o contexto de programa\u00e7\u00e3o paralela, o equivalente a uma thread \u00e9 o work-item, que representa a menor unidade de tarefa. Esses works-itens s\u00e3o agrupados em blocos denominados work-group, onde os works-itens de um mesmo bloco podem se comunicar e se sincronizar Os work-groups por sua vez s\u00e3o organizados em grids, onde dever\u00e3o ter a mesma dimens\u00e3o, podendo a grid ser unidimensional, bidimensional ou tridimensional. Figura 1 - Arquitetura OpenCL De forma geral essa estrutura possui tr\u00eas tipos de mem\u00f3rias: Private Memory Estritamente atrelada ao seu respectivo worker, apenas seu worker pode acessa-la Local memory Estritamente atrelada ao seu respectivo bloco, todos os workers dentro do bloco podem acess\u00e1-la Global Constant Memory data Cache Cache da memoria global do device, todos os blocos podem acessa-la Global Constant Memory memoria global do device Figura 1 - Arquitetura OpenCL","title":"Arquitetura OpenCL"},{"location":"2019/Leo-OpenCL/#fpga-vs-cpu","text":"A arquitetura de funcionamento de acessos de mem\u00f3ria e configura\u00e7\u00e3o do programa na estrutura OpenCL \u00e9 um pouco diferente da estrutura geral apresentada anteriormente, a \u00fanica diferen\u00e7a \u00e9 que a mem\u00f3ria do host e do device est\u00e3o contidas no mesmo dispositivo, consequentemente o tempo de transfer\u00eancia dos dados entre Host e o device \u00e9 muito menor, nessa estrutura o ARM \u00e9 respons\u00e1vel por programar a FPGA atrav\u00e9s do barramento AxI, e transmitir dados para a mem\u00f3ria global DDR3, da qual a FPGA faz uso para executar suas tarefas como device. Ao analisar os ganhos ao utilizar o OpenCL em FPGA, al\u00e9m da vantagem do baixo tempo de transfer\u00eancia de dados citado anteriormente, tamb\u00e9m h\u00e1 as vantagens caracter\u00edsticas desse processador, como flexibilidade de hardware e sua quantidade massiva de cores. Figura 2 - Arquitetura OpenCL-FPGA Enquanto que a estrutura em CPU, possui uma quantidade reduzida de cores com unidades aritm\u00e9ticas potentes para reduzir lat\u00eancia de opera\u00e7\u00f5es. Figura 4 - Arquitetura CPU Logo a estrutura em FPGA apresenta maior desempenho comparada a CPU para programas paralelos, devido a seu grande n\u00famero de cores e baixo tempo de transfer\u00eancia de dados, enquanto a CPU apresenta maior desempenho que a fpga para programas sequenciais, devido a suas unidades aritm\u00e9ticas potentes.","title":"FPGA vs CPU"},{"location":"2019/Leo-OpenCL/#tutorial-opencl-de-10","text":"","title":"Tutorial OpenCL-DE-10"},{"location":"2019/Leo-OpenCL/#1-requerimentos-de-sistema","text":"Placa Terasic DE10-Standard Cart\u00e3o microSD com ao menos 4GB Leitor de cart\u00e3o microSD Cabo USB (tipo A para mini-B) Host PC com Porta USB 64-bit Windows 7 ou Linux ( este tutorial utiliza linux) 32GB de memoria \u00e9 recomendado PuTTY ou Minicom(Linux) utility Intel Quartus Prime v18.1 instalado com licen\u00e7a valida Intel OpenCL v18.1 instalado com licen\u00e7a valida Intel SoC EDS v18.1 instalado","title":"1. Requerimentos de Sistema"},{"location":"2019/Leo-OpenCL/#2-configurando-a-infra-estrutura","text":"Essa etapa descreve como configurar o ambiente de desenvolvimento do OpenCL no Padr\u00e3o DE10-Standard.","title":"2. Configurando a Infra Estrutura"},{"location":"2019/Leo-OpenCL/#21-instalacao-de-software","text":"\u00c9 necess\u00e1rio instalar os seguintes softwares: Intel Quartus Standard e OpenCL SDK Intel SoC EDS DE10-Standard OpenCL Board Support Package (BSP) Ap\u00f3s a instala\u00e7\u00e3o do Quartus Prime e do OpenCL SDK, crie uma pasta com o nome terasic, a qual deve conter a pasta DE10-Standard-Opencl. A pasta criada deve estar no diret\u00f3rio board: /intelFPGA/18.1/hld/board","title":"2.1 Instala\u00e7\u00e3o de Software"},{"location":"2019/Leo-OpenCL/#22-instalacao-da-licensa-opencl","text":"\u00c9 necess\u00e1ria uma licen\u00e7a OpenCL para o Intel OpenCL SDK compilar o projeto. Em posse da licen\u00e7a \u00e9 necess\u00e1rio criar uma vari\u00e1vel de ambiente LM_LICENSE_FILE com a atribui\u00e7\u00e3o do diret\u00f3rio da licen\u00e7a.","title":"2.2 Instala\u00e7\u00e3o da Licensa Opencl"},{"location":"2019/Leo-OpenCL/#23-configurando-variaveis-de-ambiente","text":"As seguintes vari\u00e1veis de ambiente devem ser configuradas para o funcionamento do projeto, isso pode ser feito adicionando as vari\u00e1veis a seguir ao arquivo .bash-rc (configura\u00e7\u00e3o permanente), ou em um arquivo.sh (configura\u00e7\u00e3o temporaria, utilizar $source arquivo.sh para ativar o ambiente). echo Opencl 18 .1 export LOCAL = /media/leonardo export QUARTUS_ROOTDIR = $LOCAL /FPGA/intelFPGA/18.1/quartus export ALTERAOCLSDKROOT = $LOCAL /FPGA/intelFPGA/18.1/hld export PATH = $PATH : $QUARTUS_ROOTDIR /bin: $LOCAL /FPGA/intelFPGA/18.1/embedded/ds-5/bin: $LOCAL /FPGA/intelFPGA/18.1/embedded/ds-5/sw/gcc/bin: $ALTERAOCLSDKROOT /bin: $ALTERAOCLSDKROOT /linux64/bin: export LD_LIBRARY_PATH = $ALTERAOCLSDKROOT /linux64/lib export AOCL_BOARD_PACKAGE_ROOT = $ALTERAOCLSDKROOT /board/terasic/de10_standard export QUARTUS_64BIT = 1 export LM_LICENSE_FILE = \"/home/leonardo/Downloads/1-R3OQLF_License.dat\" export INTELFPGAOCLSDKROOT = $LOCAL /FPGA/intelFPGA/18.1/hld","title":"2.3 Configurando variaveis de ambiente"},{"location":"2019/Leo-OpenCL/#23-verificacao-do-ambiente","text":"Esta se\u00e7\u00e3o mostra como verificar se o ambiente OpenCL est\u00e1 configurado corretamente. Verificar Vers\u00e3o $ aocl version aocl 18.1.0.625 (Intel(R) FPGA SDK for OpenCL(TM), Version 18.1.0 Build 625 Standard Edition, Copyright (C) 2018 Intel Corporation) Verificar placa de destino $ aoc -list-boards Board list: de10_standard_sharedonly``` Board Package: /media/leonardo/FPGA/intelFPGA/18.1/hld/board/terasic/de10_standard","title":"2.3 Verifica\u00e7\u00e3o do Ambiente"},{"location":"2019/Leo-OpenCL/#3-compilar-projeto","text":"Esta se\u00e7\u00e3o mostra como compilar o kernel e o programa host do OpenCL, necess\u00e1rios para executar um programa em OpenCL. Compilar Kernel $ cd /media/leonardo/FPGA/intelFPGA/18.1/hld/board/terasic/de10_standard/test/vector_add_2 $ aoc device/vector_add.cl -o bin/vector_add.aocx --sw-dimm-partition -board=de10_standard_sharedonly -report Um arquivo .aocx ser\u00e1 gerado, este \u00e9 utilizado para a configura\u00e7\u00e3o dos kernels programados, configurando a execu\u00e7\u00e3o de tarefas e troca de informa\u00e7\u00f5es entre FPGA e sistema host. Warning A copila\u00e7\u00e3o do kernel \u00e9 muito lenta, pode levar horas. Compilar Programa Host $ cd /media/leonardo/FPGA/intelFPGA/18.1/embedded $ embedded_command_shell.sh $ cd /media/leonardo/FPGA/intelFPGA/18.1/hld/board/terasic/de10_standard/test/vector_add_2 $ make Um arquivo host ser\u00e1 gerado, esse arquivo \u00e9 basicamente o .o usual de uma compila\u00e7\u00e3o do GCC, arquivo intermedi\u00e1rio que ser\u00e1 utilizado em est\u00e1gios de execu\u00e7\u00e3o. Se ao executar o comando make ocorrer erros de include na biblioteca Cl adicione o par\u00e2metro ../../../../../host/include/ ao INC_DIRS no arquivo makefile","title":"3. Compilar Projeto"},{"location":"2019/Leo-OpenCL/#4-embarcar-kernel","text":"Utilizaremos uma imagem .iso j\u00e1 gerada com as especifica\u00e7\u00f5es e que j\u00e1 possui todo o sistema necess\u00e1rio para executar o linux com OpenCL. Atrav\u00e9s da pasta DE10_standard_opencl extraia o arquivo de10_standard_opencl.img, esse arquivo \u00e9 uma c\u00f3pia bit a bit do que deve ser salvo no SDCard. Quando inserirmos um disco externo no linux o mesmo o associa a um 'device' na pasta '/dev/', para sabermos qual o nome do device que foi atribu\u00eddo ao SDcard, podemos usar o comando dmesg, que exibe o log do sistema operacional e nele podemos ver qual foi o \u00faltimo hardware detectado e qual device foi atribu\u00eddo: $ dmesg | tail 4789.207972] mmc0: new ultra high speed SDR50 SDHC card at address aaaa [4789.211680] mmcblk0: mmc0:aaaa SL16G 14.8 GiB [ 4789.215857] mmcblk0: p1 p2 p3 [ 4988.443942] mmcblk0: p1 p2 p3 Agora vamos salvar a .iso no SDcard. $ sudo dd bs=1M if=de10_standard_opencl.img of=/dev/sdc conv=fsync status=progress $ sync O sync \u00e9 necess\u00e1rio para que o kernel fa\u00e7a um flush do cache escrevendo realmente no SDCard todos os dados que foram endere\u00e7ados a ele. Agora devemos ter duas parti\u00e7\u00f5es vis\u00edveis: 524 MiB: FAT32 Script de configura\u00e7\u00e3o do uboot; Kernel comprimido; Device Tree Blob file u-boot.scr; zImage; socfpga.dtb 1 GiB: Filesystem (/) Os arquivos obtidos na compila\u00e7\u00e3o do kernel e host, respectivamente arquivo.ocx e host devem ser colocados na pasta /home/root/ da parti\u00e7\u00e3o de 1GiB, para serem executadas posteriormente na placa.","title":"4. Embarcar Kernel"},{"location":"2019/Leo-OpenCL/#5-ajustar-a-placa","text":"Verifique se o interruptor DIP (SW10) MSEL [4: 0] = 01010.","title":"5. Ajustar a placa"},{"location":"2019/Leo-OpenCL/#5-conectar-se-a-placa","text":"Com a placa conectada ao USB do computador, para conectar-se ao kernel da sistema, deve-se utilizar o seguinte comando: $ screen /dev/ttyUSB0 115200,cs8","title":"5. Conectar-se a placa"},{"location":"2019/Leo-OpenCL/#6-executar-o-projeto","text":"Dentro do terminal do sistema: $ source ./init_opencl.sh $ aocl program /dev/acl0 vector_add.aocx $ ./host","title":"6. Executar o projeto"},{"location":"2019/Leo-OpenCL/#analises-de-desempenho-cpu-vs-opencl","text":"Ao comparar o tempo de execu\u00e7\u00e3o do programa vector_add , que realiza uma simples soma de vetores, entre a CPU e a FPGA foram obtidos os seguintes resultados. Size-Vector CPU FPGA 1000000 32.011 6.924 5000000 159.805 34.278 10000000 304.255 68.462 20000000 617.676 180.13 Como pode-se observar o desempenho da execu\u00e7\u00e3o na FPGA \u00e9 muito maior, embora a diferen\u00e7a num\u00e9rica seja pequena, deve-se lembrar que o arquivo de teste realiza uma simples opera\u00e7\u00e3o de soma de vetor, logo para programas mais complexos, o ganho de desempenho na FPGA seria mais expressivo. Note O teste da CPU \u00e9 single thread","title":"An\u00e1lises de Desempenho CPU vs OPENCL"},{"location":"2019/Martim-F1/","text":"Martim F. Jos\u00e9 - FPGA na AWS \u00b6 Aluno: Martim Ferreira Jos\u00e9 Curso: Engenharia da Computa\u00e7\u00e3o Semestre: 9 Contato: Link tutorial oficial: Ano: 2019 Hardware utilizado no tutorial Inst\u00e2ncia F1 na AWS Introdu\u00e7\u00e3o \u00b6 A AWS disp\u00f5em de inst\u00e2ncias F1, que s\u00e3o m\u00e1quinas de alta performance que cont\u00e9m uma FPGA no barramento PCI, permitindo a execu\u00e7\u00e3o de programas acelerados por meio de hardware personalizado. Para executar um programa em uma FPGA na nuvem, \u00e9 preciso primeiro desenvolver, simular, depurar e compilar o c\u00f3digo. Tudo isso \u00e9 feito em uma inst\u00e2ncia de desenvolvimento, predefinida por uma AMI (Amazon Machine Image) fornecida pela AWS. Na inst\u00e2ncia de desenvolvedor, o programa \u00e9 compilado e \u00e9 gerada uma imagem para a FPGA Xilinx presente na inst\u00e2ncia F1. O programa a ser implementado na FPGA pode ser desenvolvido utilizando tr\u00eas ambientes de desenvolvimento diferentes, documentados a seguir: Development Environment Description Accelerator Language Software Defined Accelerator Development - SDAccel Development experience leverages an optimized compiler to allow easy new accelerator development or migration of existing C/C++/openCL, Verilog/VHDL to AWS FPGA instances C/C++/OpenCL, Verilog/VHDL (RTL) Hardware Accelerator Development - HDK Fully custom hardware development experience provides hardware developers with the tools required for developing AFIs for AWS FPGA instances Verilog/VHDL IP Integrator or High Level Synthesis (HLx) Graphical interface development experience for integrating IP and high level synthesis development Verilog/VHDL/C Pela facilidade e maior conhecimento de C++, opta-se pela escolha do ambiente SDAccel. Portando, o programa a ser implementado \u00e9 programado em sua maioria em C++ utilizando a arquitetura OpenCL, que \u00e9 amplamente utilizada na programa\u00e7\u00e3o de alto desempenho em diversas plataformas. Este tutorial faz a implementa\u00e7\u00e3o do exemplo Hello World, que consiste na adi\u00e7\u00e3o de dois vetores. O c\u00f3digo deste exemplo pode ser examinado a fundo no seguinte reposit\u00f3rio: https://github.com/Xilinx/SDAccel_Examples/tree/a41b58921188ad90ace2d34a22a2513d8f74b549/getting_started/host/helloworld_ocl No reposit\u00f3rio h\u00e1 dois arquivos na pasta src : host.cpp e vector_addition.cl , que correspondem ao programa da m\u00e1quina e ao kernel da FPGA, respectivamente. O arquivo host consiste em um programa C++ em que: S\u00e3o definidos tr\u00eas vetores: A, B e results. A placa Xilinx \u00e9 selecionada e adicionada para o contexto da execu\u00e7\u00e3o. O bin\u00e1rio do kernel \u00e9 carregado e adicionado para um programa Para migrar os dados entre host e device, s\u00e3o criados dois buffers de leitura referenciando A e B; E um buffer de escrita referenciando result. Os dados armazenados nos buffers de leitura s\u00e3o transferidos da mem\u00f3ria da m\u00e1quina para mem\u00f3ria da FPGA. O kernel \u00e9 extra\u00eddo do programa, os argumentos s\u00e3o determinados (result, A, B, tamanho) e ele \u00e9 lan\u00e7ado. Os resultados s\u00e3o requisitados da FPGA e armazenados no buffer de escrita. E por fim, o resultado recebido \u00e9 comparados com o resultado esperado. O arquivo do kernel consiste em uma fun\u00e7\u00e3o em OpenCL que: Recebe quatro argumentos (result, A, B, tamanho) Define os arrays A e B Percorre os arrays recebidos como argumento, populando os arrays declarados Percorre o tamanho das arrays escrevendo no buffer de escrita (result) a soma de A e B em cada \u00edndice. Aplica\u00e7\u00f5es \u00b6 As inst\u00e2ncias com FPGA s\u00e3o amplamente utilizadas em situa\u00e7\u00f5es em que h\u00e1 uma grande quantidade de dados e o processamento precisa ser feito com rapidez. O desenvolvimento de um hardware personalizado para executar um programa fornece um custo de computa\u00e7\u00e3o 30x melhor comparado com inst\u00e2ncias de CPU. Entre essas aplica\u00e7\u00f5es pode-se citar o encoding de video em tempo real e an\u00e1lise de risco financeiro. Custos \u00b6 A inst\u00e2ncia de desenvolvimento m5.xlarge custa US 0.1920 por hora. E a inst\u00e2ncia f1.2xlarge custa US 0.1920 por hora. E a inst\u00e2ncia f1.2xlarge custa US 1.65 por hora. A implementa\u00e7\u00e3o deste exemplo \u00e9 estimada consumir por volta de 3hrs da inst\u00e2ncia de desenvolvimento e meia hora da inst\u00e2ncia F1. Totalizando US$1.5. Passo a passo \u00b6 Refer\u00eancias \u00b6 https://aws.amazon.com/pt/ec2/instance-types/f1/ https://github.com/aws/aws-fpga/blob/master/SDAccel/README.md#overview https://github.com/Xilinx/SDAccel_Examples/tree/a41b58921188ad90ace2d34a22a2513d8f74b549/getting_started/host/helloworld_ocl/src Pr\u00e9-requisitos \u00b6 Pr\u00e9-requisitos: Ter uma conta na AWS com acesso ao EC2 e S3. Configurando a AWS \u00b6 Em seu computador, baixe a CLI da AWS configure suas credenciais: $ aws configure Inst\u00e2ncia de desenvolvedor \u00b6 Para criar a inst\u00e2ncia de desenvolvimento, clique em Launch Instance e: - Utilize a AMI chamada \u201cFPGA Developer AMI\u201d. - Utilize o flavor m5.xlarge ou m5.2xlarge (quanto mais n\u00facleos e mem\u00f3ria, mais r\u00e1pido ser\u00e1 a compilac\u00e3o). - Crie e salve sua Keypair. Bucket setup \u00b6 Para utilizar a imagem compilada da F1, \u00e9 necess\u00e1rio salv\u00e1-la em um bucket, permitindo o seu acesso pelo servi\u00e7o EC2. O bucket e suas pastas podem ser criados manualmente pela dashboard ou pela CLI: $ aws s3 mb s3://embarcados-f1-tutorial --region us-east-1 $ touch FILES_GO_HERE.txt $ aws s3 cp FILES_GO_HERE.txt s3://embarcados-f1-tutorial/files/ $ touch LOGS_FILES_GO_HERE.txt $ aws s3 cp LOGS_FILES_GO_HERE.txt s3://embarcados-f1-tutorial/logs/ Setting up the dev house \u00b6 Acesse a inst\u00e2ncia de desenvolvimento: ssh -i \"<sua-keypair>.pem\" <ip-da-m\u00e1quina> Dentro da inst\u00e2ncia, clone o reposit\u00f3rio, instale os drivers e bibliotecas necess\u00e1rias e determine a plataforma de desenvolvimento: $ git clone https://github.com/aws/aws-fpga.git $AWS_FPGA_REPO_DIR $ cd $AWS_FPGA_REPO_DIR $ source sdaccel_setup.sh $ export AWS_PLATFORM = $AWS_PLATFORM_DYNAMIC_5_0 Acesse a pasta do exemplo no diret\u00f3rio: $ cd $SDACCEL_DIR/examples/xilinx/getting_started/host/helloworld_ocl/ Hora de compilar? N\u00c3O Check up \u00b6 A compila\u00e7\u00e3o do programa demora 2h06min. J\u00e1 imaginou desenvolver algo e cada vez que quiser testar ter que esperar 2h? E por isso que existem o emulador de software, que realiza uma r\u00e1pida compila\u00e7\u00e3o e executa nos ciclos da CPU. E o emulador de hardware, que invoca o simulador de hardware do ambiente SDAccel e testa a funcionalidade do c\u00f3digo a ser executado na FPGA. Para emular o software: $ make clean $ make check TARGETS = sw_emu DEVICES = $AWS_PLATFORM all Para emular o hardware: $ make clean $ make check TARGETS = hw_emu DEVICES = $AWS_PLATFORM all Compilando! \u00b6 O ambiente SDAccel tamb\u00e9m permite que o desenvolvedor compile tanto o bin\u00e1rio da placa FPGA, quanto a aplica\u00e7\u00e3o host. Isso \u00e9 feito por meio do mesmo Makefile: $ make clean $ make TARGETS = hw DEVICES = $AWS_PLATFORM all A compila\u00e7\u00e3o gera o arquivo bin\u00e1rio para a FPGA Xilinx (*.xclbin) e o execut\u00e1vel do programa host (exe), no nosso caso: helloworld . Cria\u00e7\u00e3o da Amazon FPGA Image (AFI) \u00b6 Agora, \u00e9 preciso gerar uma imagem FPGA que ser\u00e1 inserida na placa presente na PCI da inst\u00e2ncia. O script abaixo salva o kernel da FPGA no bucket, cria a AMI no servidor da AWS e salva um arquivo de metadados com informa\u00e7\u00f5es da imagem ( *.awsxclbin ), que tamb\u00e9m pode ser vistas no arquivo *_afi_id.txt . $ $SDACCEL_DIR /tools/create_sdaccel_afi.sh -xclbin = xclbin/vector_addition.hw.xilinx_aws-vu9p-f1-04261818_dynamic_5_0.xclbin -o = vector_addition.hw.xilinx_aws-vu9p-f1-04261818_dynamic_5_0 \\ -s3_bucket = embarcados-f1-tutorial -s3_dcp_key = files -s3_logs_key = logs A cria\u00e7\u00e3o da imagem n\u00e3o \u00e9 imediata, seu processo demora e pode ser acompanhado pela CLI da AWS: aws ec2 describe-fpga-images --fpga-image-ids <AFI ID ( eg: afi-06d0ffc989feeea2a ) > Quando a cria\u00e7\u00e3o da imagem for conclu\u00edda, o output dever\u00e1 ser: ... \"State\": { \"Code\": \"available\" }, ... Caso o c\u00f3digo do status retorne como \"failed\", procure os logs em: s3://embarcados-f1-tutorial/logs/ Exportando o programa \u00b6 Os arquivos necess\u00e1rios para executar o exemplo na FPGA s\u00e3o: <nome-do-arquivo>.awsxclbin helloworld Portanto, copie-os para o bucket: $ aws s3 cp <nome-do-arquivo>.awsxclbin s3://embarcados-f1-tutorial/files/ $ aws s3 cp helloworld s3://embarcados-f1-tutorial/files/ Criando a inst\u00e2ncia F1 \u00b6 Para criar a inst\u00e2ncia F1, clique em Launch Instance e: Utilize a AMI chamada \u201cFPGA Developer AMI\u201d. Utilize o flavor f1.2xlarge. Crie e salve sua Keypair. Executando \u00b6 Acesse a inst\u00e2ncia F1 Repita o passo Setting up the dev house Acesse o diret\u00f3rio do reposit\u00f3rio cd $AWS_FPGA_REPO_DIR Copie os arquivos salvos no bucket: $ aws s3 cp s3://embarcados-f1-tutorial/files/<nome-do-arquivo>.awsxclbin ./ $ aws s3 cp s3://embarcados-f1-tutorial/files/helloworld ./ Certifique-se que todos os arquivos possam ser achados na raiz do resposit\u00f3rio $ sudo -E /bin/bash $ source $AWS_FPGA_REPO_DIR/sdaccel_runtime_setup.sh chmod +x helloworld ./helloworld Pronto! O programa host importou a imagem da FPGA do servi\u00e7o AMI da AWS, criou os buffers para fazer a transfer\u00eancia de dados, determinou os argumentos e inseriu todo o kernel na placa. Notes Adicionar log do resultado","title":"Martim F. Jos\u00e9 - FPGA na AWS"},{"location":"2019/Martim-F1/#martim-f-jose-fpga-na-aws","text":"Aluno: Martim Ferreira Jos\u00e9 Curso: Engenharia da Computa\u00e7\u00e3o Semestre: 9 Contato: Link tutorial oficial: Ano: 2019 Hardware utilizado no tutorial Inst\u00e2ncia F1 na AWS","title":"Martim F. Jos\u00e9 - FPGA na AWS"},{"location":"2019/Martim-F1/#introducao","text":"A AWS disp\u00f5em de inst\u00e2ncias F1, que s\u00e3o m\u00e1quinas de alta performance que cont\u00e9m uma FPGA no barramento PCI, permitindo a execu\u00e7\u00e3o de programas acelerados por meio de hardware personalizado. Para executar um programa em uma FPGA na nuvem, \u00e9 preciso primeiro desenvolver, simular, depurar e compilar o c\u00f3digo. Tudo isso \u00e9 feito em uma inst\u00e2ncia de desenvolvimento, predefinida por uma AMI (Amazon Machine Image) fornecida pela AWS. Na inst\u00e2ncia de desenvolvedor, o programa \u00e9 compilado e \u00e9 gerada uma imagem para a FPGA Xilinx presente na inst\u00e2ncia F1. O programa a ser implementado na FPGA pode ser desenvolvido utilizando tr\u00eas ambientes de desenvolvimento diferentes, documentados a seguir: Development Environment Description Accelerator Language Software Defined Accelerator Development - SDAccel Development experience leverages an optimized compiler to allow easy new accelerator development or migration of existing C/C++/openCL, Verilog/VHDL to AWS FPGA instances C/C++/OpenCL, Verilog/VHDL (RTL) Hardware Accelerator Development - HDK Fully custom hardware development experience provides hardware developers with the tools required for developing AFIs for AWS FPGA instances Verilog/VHDL IP Integrator or High Level Synthesis (HLx) Graphical interface development experience for integrating IP and high level synthesis development Verilog/VHDL/C Pela facilidade e maior conhecimento de C++, opta-se pela escolha do ambiente SDAccel. Portando, o programa a ser implementado \u00e9 programado em sua maioria em C++ utilizando a arquitetura OpenCL, que \u00e9 amplamente utilizada na programa\u00e7\u00e3o de alto desempenho em diversas plataformas. Este tutorial faz a implementa\u00e7\u00e3o do exemplo Hello World, que consiste na adi\u00e7\u00e3o de dois vetores. O c\u00f3digo deste exemplo pode ser examinado a fundo no seguinte reposit\u00f3rio: https://github.com/Xilinx/SDAccel_Examples/tree/a41b58921188ad90ace2d34a22a2513d8f74b549/getting_started/host/helloworld_ocl No reposit\u00f3rio h\u00e1 dois arquivos na pasta src : host.cpp e vector_addition.cl , que correspondem ao programa da m\u00e1quina e ao kernel da FPGA, respectivamente. O arquivo host consiste em um programa C++ em que: S\u00e3o definidos tr\u00eas vetores: A, B e results. A placa Xilinx \u00e9 selecionada e adicionada para o contexto da execu\u00e7\u00e3o. O bin\u00e1rio do kernel \u00e9 carregado e adicionado para um programa Para migrar os dados entre host e device, s\u00e3o criados dois buffers de leitura referenciando A e B; E um buffer de escrita referenciando result. Os dados armazenados nos buffers de leitura s\u00e3o transferidos da mem\u00f3ria da m\u00e1quina para mem\u00f3ria da FPGA. O kernel \u00e9 extra\u00eddo do programa, os argumentos s\u00e3o determinados (result, A, B, tamanho) e ele \u00e9 lan\u00e7ado. Os resultados s\u00e3o requisitados da FPGA e armazenados no buffer de escrita. E por fim, o resultado recebido \u00e9 comparados com o resultado esperado. O arquivo do kernel consiste em uma fun\u00e7\u00e3o em OpenCL que: Recebe quatro argumentos (result, A, B, tamanho) Define os arrays A e B Percorre os arrays recebidos como argumento, populando os arrays declarados Percorre o tamanho das arrays escrevendo no buffer de escrita (result) a soma de A e B em cada \u00edndice.","title":"Introdu\u00e7\u00e3o"},{"location":"2019/Martim-F1/#aplicacoes","text":"As inst\u00e2ncias com FPGA s\u00e3o amplamente utilizadas em situa\u00e7\u00f5es em que h\u00e1 uma grande quantidade de dados e o processamento precisa ser feito com rapidez. O desenvolvimento de um hardware personalizado para executar um programa fornece um custo de computa\u00e7\u00e3o 30x melhor comparado com inst\u00e2ncias de CPU. Entre essas aplica\u00e7\u00f5es pode-se citar o encoding de video em tempo real e an\u00e1lise de risco financeiro.","title":"Aplica\u00e7\u00f5es"},{"location":"2019/Martim-F1/#custos","text":"A inst\u00e2ncia de desenvolvimento m5.xlarge custa US 0.1920 por hora. E a inst\u00e2ncia f1.2xlarge custa US 0.1920 por hora. E a inst\u00e2ncia f1.2xlarge custa US 1.65 por hora. A implementa\u00e7\u00e3o deste exemplo \u00e9 estimada consumir por volta de 3hrs da inst\u00e2ncia de desenvolvimento e meia hora da inst\u00e2ncia F1. Totalizando US$1.5.","title":"Custos"},{"location":"2019/Martim-F1/#passo-a-passo","text":"","title":"Passo a passo"},{"location":"2019/Martim-F1/#referencias","text":"https://aws.amazon.com/pt/ec2/instance-types/f1/ https://github.com/aws/aws-fpga/blob/master/SDAccel/README.md#overview https://github.com/Xilinx/SDAccel_Examples/tree/a41b58921188ad90ace2d34a22a2513d8f74b549/getting_started/host/helloworld_ocl/src","title":"Refer\u00eancias"},{"location":"2019/Martim-F1/#pre-requisitos","text":"Pr\u00e9-requisitos: Ter uma conta na AWS com acesso ao EC2 e S3.","title":"Pr\u00e9-requisitos"},{"location":"2019/Martim-F1/#configurando-a-aws","text":"Em seu computador, baixe a CLI da AWS configure suas credenciais: $ aws configure","title":"Configurando a AWS"},{"location":"2019/Martim-F1/#instancia-de-desenvolvedor","text":"Para criar a inst\u00e2ncia de desenvolvimento, clique em Launch Instance e: - Utilize a AMI chamada \u201cFPGA Developer AMI\u201d. - Utilize o flavor m5.xlarge ou m5.2xlarge (quanto mais n\u00facleos e mem\u00f3ria, mais r\u00e1pido ser\u00e1 a compilac\u00e3o). - Crie e salve sua Keypair.","title":"Inst\u00e2ncia de desenvolvedor"},{"location":"2019/Martim-F1/#bucket-setup","text":"Para utilizar a imagem compilada da F1, \u00e9 necess\u00e1rio salv\u00e1-la em um bucket, permitindo o seu acesso pelo servi\u00e7o EC2. O bucket e suas pastas podem ser criados manualmente pela dashboard ou pela CLI: $ aws s3 mb s3://embarcados-f1-tutorial --region us-east-1 $ touch FILES_GO_HERE.txt $ aws s3 cp FILES_GO_HERE.txt s3://embarcados-f1-tutorial/files/ $ touch LOGS_FILES_GO_HERE.txt $ aws s3 cp LOGS_FILES_GO_HERE.txt s3://embarcados-f1-tutorial/logs/","title":"Bucket setup"},{"location":"2019/Martim-F1/#setting-up-the-dev-house","text":"Acesse a inst\u00e2ncia de desenvolvimento: ssh -i \"<sua-keypair>.pem\" <ip-da-m\u00e1quina> Dentro da inst\u00e2ncia, clone o reposit\u00f3rio, instale os drivers e bibliotecas necess\u00e1rias e determine a plataforma de desenvolvimento: $ git clone https://github.com/aws/aws-fpga.git $AWS_FPGA_REPO_DIR $ cd $AWS_FPGA_REPO_DIR $ source sdaccel_setup.sh $ export AWS_PLATFORM = $AWS_PLATFORM_DYNAMIC_5_0 Acesse a pasta do exemplo no diret\u00f3rio: $ cd $SDACCEL_DIR/examples/xilinx/getting_started/host/helloworld_ocl/ Hora de compilar? N\u00c3O","title":"Setting up the dev house"},{"location":"2019/Martim-F1/#check-up","text":"A compila\u00e7\u00e3o do programa demora 2h06min. J\u00e1 imaginou desenvolver algo e cada vez que quiser testar ter que esperar 2h? E por isso que existem o emulador de software, que realiza uma r\u00e1pida compila\u00e7\u00e3o e executa nos ciclos da CPU. E o emulador de hardware, que invoca o simulador de hardware do ambiente SDAccel e testa a funcionalidade do c\u00f3digo a ser executado na FPGA. Para emular o software: $ make clean $ make check TARGETS = sw_emu DEVICES = $AWS_PLATFORM all Para emular o hardware: $ make clean $ make check TARGETS = hw_emu DEVICES = $AWS_PLATFORM all","title":"Check up"},{"location":"2019/Martim-F1/#compilando","text":"O ambiente SDAccel tamb\u00e9m permite que o desenvolvedor compile tanto o bin\u00e1rio da placa FPGA, quanto a aplica\u00e7\u00e3o host. Isso \u00e9 feito por meio do mesmo Makefile: $ make clean $ make TARGETS = hw DEVICES = $AWS_PLATFORM all A compila\u00e7\u00e3o gera o arquivo bin\u00e1rio para a FPGA Xilinx (*.xclbin) e o execut\u00e1vel do programa host (exe), no nosso caso: helloworld .","title":"Compilando!"},{"location":"2019/Martim-F1/#criacao-da-amazon-fpga-image-afi","text":"Agora, \u00e9 preciso gerar uma imagem FPGA que ser\u00e1 inserida na placa presente na PCI da inst\u00e2ncia. O script abaixo salva o kernel da FPGA no bucket, cria a AMI no servidor da AWS e salva um arquivo de metadados com informa\u00e7\u00f5es da imagem ( *.awsxclbin ), que tamb\u00e9m pode ser vistas no arquivo *_afi_id.txt . $ $SDACCEL_DIR /tools/create_sdaccel_afi.sh -xclbin = xclbin/vector_addition.hw.xilinx_aws-vu9p-f1-04261818_dynamic_5_0.xclbin -o = vector_addition.hw.xilinx_aws-vu9p-f1-04261818_dynamic_5_0 \\ -s3_bucket = embarcados-f1-tutorial -s3_dcp_key = files -s3_logs_key = logs A cria\u00e7\u00e3o da imagem n\u00e3o \u00e9 imediata, seu processo demora e pode ser acompanhado pela CLI da AWS: aws ec2 describe-fpga-images --fpga-image-ids <AFI ID ( eg: afi-06d0ffc989feeea2a ) > Quando a cria\u00e7\u00e3o da imagem for conclu\u00edda, o output dever\u00e1 ser: ... \"State\": { \"Code\": \"available\" }, ... Caso o c\u00f3digo do status retorne como \"failed\", procure os logs em: s3://embarcados-f1-tutorial/logs/","title":"Cria\u00e7\u00e3o da Amazon FPGA Image (AFI)"},{"location":"2019/Martim-F1/#exportando-o-programa","text":"Os arquivos necess\u00e1rios para executar o exemplo na FPGA s\u00e3o: <nome-do-arquivo>.awsxclbin helloworld Portanto, copie-os para o bucket: $ aws s3 cp <nome-do-arquivo>.awsxclbin s3://embarcados-f1-tutorial/files/ $ aws s3 cp helloworld s3://embarcados-f1-tutorial/files/","title":"Exportando o programa"},{"location":"2019/Martim-F1/#criando-a-instancia-f1","text":"Para criar a inst\u00e2ncia F1, clique em Launch Instance e: Utilize a AMI chamada \u201cFPGA Developer AMI\u201d. Utilize o flavor f1.2xlarge. Crie e salve sua Keypair.","title":"Criando a inst\u00e2ncia F1"},{"location":"2019/Martim-F1/#executando","text":"Acesse a inst\u00e2ncia F1 Repita o passo Setting up the dev house Acesse o diret\u00f3rio do reposit\u00f3rio cd $AWS_FPGA_REPO_DIR Copie os arquivos salvos no bucket: $ aws s3 cp s3://embarcados-f1-tutorial/files/<nome-do-arquivo>.awsxclbin ./ $ aws s3 cp s3://embarcados-f1-tutorial/files/helloworld ./ Certifique-se que todos os arquivos possam ser achados na raiz do resposit\u00f3rio $ sudo -E /bin/bash $ source $AWS_FPGA_REPO_DIR/sdaccel_runtime_setup.sh chmod +x helloworld ./helloworld Pronto! O programa host importou a imagem da FPGA do servi\u00e7o AMI da AWS, criou os buffers para fazer a transfer\u00eancia de dados, determinou os argumentos e inseriu todo o kernel na placa. Notes Adicionar log do resultado","title":"Executando"},{"location":"2019/Pedro-OpenCV/","text":"Pedro de la Pen\u00e3 - Jetson Nano GPU \u00b6 Aluno: Pedro de la Pen\u00e3 Curso: Engenharia da Computa\u00e7\u00e3o Semestre: 9 Contato: Link tutorial oficial: https://github.com/pedrodelapena/TutorialEmbarcados Ano: 2019 Hardware utilizado no tutorial Jetson Nano C\u00e2mera raspberry pi Neste projeto iremos utilizar uma placa Jetson Nano para comparar a diferen\u00e7a no desempenho de um c\u00f3digo sendo executado em CPU VS GPU. Pr\u00e9 Requisitos \u00b6 Para seguir este tutorial, \u00e9 necess\u00e1rio: - Conex\u00e3o com a internet ; - Hardware : Jetson Nano; - Hardware : SD Card 16 GB OU 32 GB (prefer\u00edvel); - Hardware : Teclado e Mouse USB; - Hardware : Monitor com entrada HDMI; - Hardware : C\u00e2mera Raspberry Pi 2.1 OU C\u00e2mera USB; - Software : Baixar imagem https://developer.nvidia.com/jetson-nano-sd-card-image-r3221 Arquitetura da placa Jetson Nano \u00b6 A placa Jetson Nano possui uma GPU integrada al\u00e9m de sua CPU ARM Cortex-A57 Quad-Core, o que a faz ser muito utilizada em aplica\u00e7\u00f5es de processamento de imagens e tamb\u00e9m em Machine Learning com o uso de redes neurais. A lista completa de seus componentes e especifica\u00e7\u00f5es est\u00e1 a seguir: NVIDIA Tegra X1 SoC (GPU) \u00b6 A Jetson Nano possui um System On a Chip (SoC) Tegra X1 Maxell, frequentemente encontrado em tablets que s\u00e3o baseados no sistema Android. Este SoC possibilita o uso softwares como OpenGL, CUDA e tamb\u00e9m DirectX. Com um clock m\u00e1ximo de at\u00e9 1000 MHz, a GPU oferece 256 shader-cores e \u00e9 capaz de codificar v\u00eddeos em 30fps e decodificar em 60fps. Gravando um SDCard e inicializando o Linux \u00b6 Configurando o sistema operacional no SD card \u00b6 Ap\u00f3s realizar o download da imagem, conecte o SD card em um adaptador e ent\u00e3o no seu computador. Agora \u00e9 preciso extrair a imagem e copi\u00e1-la para o driver de maneira que o sistema operacional funcione. Para realizar o processo utilizando utilizando uma interface gr\u00e1fica, fa\u00e7a o dowload do Etcher . O processo de flashing \u00e9 um pouco demorado, levando cerca de 10-15 minutos. Voc\u00ea pode meditar um pouco ou ent\u00e3o pode ir dar uma volta e tomar um caf\u00e9! Caso voc\u00ea prefira realizar o processo de forma mais raiz , voc\u00ea tamb\u00e9m o pode fazer pela linha de comando. Para isto, descubra o nome e localiza\u00e7\u00e3o do seu flash drive com dmesg | tail . Ap\u00f3s encontrar o drive, extraia o arquivo para o SD card com o comando: $ /usr/bin/unzip -p ~/ [ LOCAL_DE_DOWNLOAD ] /jetson_nano_devkit_sd_card.zip $ sudo /bin/dd of = /dev/sd [ NOME_DO_DRIVE ] bs = 1M status = progress Ap\u00f3s finalizado o processo, remova o drive de seu computador. Inserindo o SD card na placa Jetson Nano \u00b6 A entrada do cart\u00e3o de mem\u00f3ria n\u00e3o \u00e9 muito vis\u00edvel para aqueles que est\u00e3o tendo o primeiro contato com a placa. Aqui h\u00e1 uma imagem para auxilia-lo(a) a encontrar a entrada do cart\u00e3o: Primeiro boot \u00b6 Com o cart\u00e3o de mem\u00f3ria j\u00e1 inserido, \u00e9 preciso conectar os cabos na placa. N\u00e3o h\u00e1 \"bot\u00e3o de ligar ou desligar\" na placa, e o boot come\u00e7a automaticamente quando o cabo de alimenta\u00e7\u00e3o (supply de 5V (USB) OU fonte) estiver conectado. Al\u00e9m disso, lembre-se que ser\u00e1 preciso conex\u00e3o com a internet para os pr\u00f3ximos passos . Ap\u00f3s inserir as configura\u00e7\u00f5es de formato de teclado, regi\u00e3o e informa\u00e7\u00f5es 'pessoais' do ambiente Linux, a placa reiniciar\u00e1 e ent\u00e3o estar\u00e1 pronta para uso. Para maior comodidade, recomenda-se que a suspens\u00e3o autom\u00e1tica e screen lock sejam desativadas em All Settings -> Brightness & Lock , dado que alguns downloads e instala\u00e7\u00f5es possam demorar um pouco . Atualizando libs e packages \u00b6 J\u00e1 que acabamos de configurar o sistema operacional, \u00e9 necess\u00e1rio executar os comandos sudo apt-get update e sudo apt-get upgrade . Configurando o ambiente Python \u00b6 Para instalar bibliotecas adicionais, \u00e9 preciso instalar o pip. Para isto, execude os comandos a seguir: $ wget https://bootstrap.pypa.io/get-pip.py $ sudo python3 get-pip.py Configurando o ambiente CUDA \u00b6 $ wget http://developer.download.nvidia.com/compute/cuda/10.2/Prod/local_installers/cuda_10.2.89_440.33.01_linux.run $ sudo sh cuda_10.2.89_440.33.01_linux.run Configurando o Ambiente OpenCV \u00b6 Note Esse aqui demora... E MUITO! (~4 horas) Warning IMPORTANTE! Conecte um cooler \u00e0 placa e fa\u00e7a quest\u00e3o de utilizar a fonte de alimenta\u00e7\u00e3o normal em rela\u00e7\u00e3o \u00e0 USB para este processo, j\u00e1 que ele demanda MUITA pot\u00eancia e a placa atingir altas temperaturas, o que pode levar ao seu superaquecimento. Com o cooler instalado, rode as seguintes linhas de comando para instalar e compilar o OpenCV. E lembrando, \u00e9 uma looooooonga espera. $ wget https://github.com/AastaNV/JEP/blob/master/script/install_opencv4.1.1_Jetson.sh $ sudo sh install_opencv4.1.1_Jetson.sh $ export PYTHONPATH=/usr/local/python Ap\u00f3s realizada a build, abra um terminal python3 e rode o seguinte c\u00f3digo para testar o OpenCV: import cv2 print ( cv2 . getBuildInformation ()) A partir deste comando, \u00e9 possivel visualizar se o CUDA OpenCV est\u00e1 configurado, no campo NVIDIA CUDA Instala\u00e7\u00e3o Pytorch \u00b6 A biblioteca Pytorch possui fun\u00e7\u00f5es que tornam poss\u00edvel a utiliza\u00e7\u00e3o da GPU no ambiente Python. Esta biblioteca ser\u00e1 utilizada para fazer alguns testes e compara\u00e7\u00f5es mais para frente no tutorial. $ wget https://nvidia.box.com/shared/static/phqe92v26cbhqjohwtvxorrwnmrnfx1o.whl -O torch-1.3.0-cp36-cp36m-linux_aarch64.whl $ pip3 install numpy torch-1.3.0-cp36-cp36m-linux_aarch64.whl Caso algum erro de depend\u00eancia relacionado ao numpy ocorra, reinstale-o. $ sudo pip uninstall numpy $ pip3 install numpy --user CPU vs GPU \u00b6 A diferen\u00e7a no desempenho de certos c\u00f3digos executados em CPU ou GPU \u00e9 dada pela quantidade de c\u00e1lculos em paralelo que cada um dos hardwares consegue realizar. Dependendo da arquitetura dos hardwares, uma GPU pode executar centenas - ou at\u00e9 milhares - de vezes mais instru\u00e7\u00f5es por clock em rela\u00e7\u00e3o \u00e0 CPU. Por conta disto, GPUs s\u00e3o largamente utilizadas em processos que podem ser amplamente divididos e paralelizados em blocos, como \u00e9 o caso da multiplica\u00e7\u00e3o de matrizes com muitas linhas e colunas. O simples exemplo a seguir deixa evidente a diferen\u00e7a no desempenho. C\u00f3digo em CPU: import numpy as np import time x = np . random . rand ( 7000 , 16 ) y = np . random . rand ( 16 , 7000 ) start = time . time () z = np . matmul ( x , y ) end = time . time () print ( z ) print ( \" \\n Elapsed time CPU:\" , end - start , \"seconds\" ) C\u00f3digo em GPU: import torch import time x = torch . randn ( 7000 , 16 ) y = torch . randn ( 16 , 7000 ) start = time . time () z = torch . matmul ( x , y ) end = time . time () print ( z ) print ( \" \\n Elapsed time GPU:\" , end - start , \"seconds\" ) CUDA OpenCV \u00b6 A GPU tamb\u00e9m \u00e9 de fundamental uso em outras aplica\u00e7\u00f5es como a rederiza\u00e7\u00e3o de v\u00eddeos e imagens e tamb\u00e9m no treinamento de modelos de Machine Learning e redes neurais. Desta forma,a biblioteca OpenCV pode ser utilizada para realizar tais tarefas na GPU. Instala\u00e7\u00e3o da C\u00e2mera \u00b6 Caso esteja utilizando uma c\u00e2mera USB, pule esta etapa. Com a Jetson Nano desligada de todas as fontes de energia e com a c\u00e2mera Raspberry Pi 2.1 (1.3 n\u00e3o funciona), levante a trava localzada em um dos cantos da placa, for\u00e7ando-a para cima. Em seguida, insira o conector da c\u00e2mera (com \"a parte azul voltada para fora\") e ent\u00e3o pressione a trava novamente para baixo. Testando a C\u00e2mera Raspberry Pi \u00b6 Ap\u00f3s conectada, teste a c\u00e2mera para checar se ela realmente est\u00e1 funcional com a seguinte linha de c\u00f3digo no terminal. $ gst-launch-1.0 nvarguscamerasrc ! 'video/x-raw(memory:NVMM),width=3820, height=2464, framerate=21/1, format=NV12' ! nvvidconv flip-method = 0 ! 'video/x-raw,width=960, height=616' ! nvvidconv ! nvegltransform ! nveglglessink -e Exemplo e compara\u00e7\u00e3o OpenCV vs OpenCV CUDA \u00b6 O c\u00f3digo \u00e0 seguir foi adaptado do Jetson Nano Hacks, sendo que o original pode ser encontrado neste link . Neste c\u00f3digo \u00e9 testada a diferen\u00e7a de desempenho da CPU em rela\u00e7\u00e3o \u00e0 GPU. import cv2 import time def gstreamer_pipeline ( capture_width = 640 , capture_height = 360 , display_width = 640 , display_height = 360 , framerate = 60 , flip_method = 0 , ): return ( \"nvarguscamerasrc ! \" \"video/x-raw(memory:NVMM), \" \"width=(int) %d , height=(int) %d , \" \"format=(string)NV12, framerate=(fraction) %d /1 ! \" \"nvvidconv flip-method= %d ! \" \"video/x-raw, width=(int) %d , height=(int) %d , format=(string)BGRx ! \" \"videoconvert ! \" \"video/x-raw, format=(string)BGR ! appsink\" % ( capture_width , capture_height , framerate , flip_method , display_width , display_height , ) ) def show_camera (): # To flip the image, modify the flip_method parameter (0 and 2 are the most common) print ( gstreamer_pipeline ( flip_method = 0 )) cap = cv2 . VideoCapture ( gstreamer_pipeline ( flip_method = 0 ), cv2 . CAP_GSTREAMER ) if cap . isOpened (): window_handle = cv2 . namedWindow ( \"CSI Camera\" , cv2 . WINDOW_AUTOSIZE ) # Window while cv2 . getWindowProperty ( \"CSI Camera\" , 0 ) >= 0 : ret_val , img = cap . read (); start = time . time () #Alterar aqui para \"c2.cuda.flip()\" ou \"cv2.flip()\" img2 = cv2 . cuda . flip ( img , 1 ) end = time . time () print ( \"Elapsed time\" , end - start ) cv2 . imshow ( \"CSI Camera\" , img2 ) keyCode = cv2 . waitKey ( 30 ) & 0xFF # Stop the program on the ESC key if keyCode == 27 : break cap . release () cv2 . destroyAllWindows () else : print ( \"Unable to open camera\" ) if __name__ == \"__main__\" : show_camera () Neste caso, devido ao fato de ser uma simples altera\u00e7\u00e3o na imagem como um flip , o programa demora mais para enviar a imagem para a GPU que realizar todo o processo na CPU. Contudo, com mais processos e opera\u00e7\u00f5es, o ganho de desempenho da GPU fica evidente. Al\u00e9m disso, para descobrir todas as fun\u00e7\u00f5es do m\u00f3dulo CUDA, abra um terminal Python3 e insira a linha dir(cv2.cuda) .","title":"Pedro de la Pen\u00e3 - Jetson Nano GPU"},{"location":"2019/Pedro-OpenCV/#pedro-de-la-pena-jetson-nano-gpu","text":"Aluno: Pedro de la Pen\u00e3 Curso: Engenharia da Computa\u00e7\u00e3o Semestre: 9 Contato: Link tutorial oficial: https://github.com/pedrodelapena/TutorialEmbarcados Ano: 2019 Hardware utilizado no tutorial Jetson Nano C\u00e2mera raspberry pi Neste projeto iremos utilizar uma placa Jetson Nano para comparar a diferen\u00e7a no desempenho de um c\u00f3digo sendo executado em CPU VS GPU.","title":"Pedro de la Pen\u00e3 - Jetson Nano GPU"},{"location":"2019/Pedro-OpenCV/#pre-requisitos","text":"Para seguir este tutorial, \u00e9 necess\u00e1rio: - Conex\u00e3o com a internet ; - Hardware : Jetson Nano; - Hardware : SD Card 16 GB OU 32 GB (prefer\u00edvel); - Hardware : Teclado e Mouse USB; - Hardware : Monitor com entrada HDMI; - Hardware : C\u00e2mera Raspberry Pi 2.1 OU C\u00e2mera USB; - Software : Baixar imagem https://developer.nvidia.com/jetson-nano-sd-card-image-r3221","title":"Pr\u00e9 Requisitos"},{"location":"2019/Pedro-OpenCV/#arquitetura-da-placa-jetson-nano","text":"A placa Jetson Nano possui uma GPU integrada al\u00e9m de sua CPU ARM Cortex-A57 Quad-Core, o que a faz ser muito utilizada em aplica\u00e7\u00f5es de processamento de imagens e tamb\u00e9m em Machine Learning com o uso de redes neurais. A lista completa de seus componentes e especifica\u00e7\u00f5es est\u00e1 a seguir:","title":"Arquitetura da placa Jetson Nano"},{"location":"2019/Pedro-OpenCV/#nvidia-tegra-x1-soc-gpu","text":"A Jetson Nano possui um System On a Chip (SoC) Tegra X1 Maxell, frequentemente encontrado em tablets que s\u00e3o baseados no sistema Android. Este SoC possibilita o uso softwares como OpenGL, CUDA e tamb\u00e9m DirectX. Com um clock m\u00e1ximo de at\u00e9 1000 MHz, a GPU oferece 256 shader-cores e \u00e9 capaz de codificar v\u00eddeos em 30fps e decodificar em 60fps.","title":"NVIDIA Tegra X1 SoC (GPU)"},{"location":"2019/Pedro-OpenCV/#gravando-um-sdcard-e-inicializando-o-linux","text":"","title":"Gravando um SDCard e inicializando o Linux"},{"location":"2019/Pedro-OpenCV/#configurando-o-sistema-operacional-no-sd-card","text":"Ap\u00f3s realizar o download da imagem, conecte o SD card em um adaptador e ent\u00e3o no seu computador. Agora \u00e9 preciso extrair a imagem e copi\u00e1-la para o driver de maneira que o sistema operacional funcione. Para realizar o processo utilizando utilizando uma interface gr\u00e1fica, fa\u00e7a o dowload do Etcher . O processo de flashing \u00e9 um pouco demorado, levando cerca de 10-15 minutos. Voc\u00ea pode meditar um pouco ou ent\u00e3o pode ir dar uma volta e tomar um caf\u00e9! Caso voc\u00ea prefira realizar o processo de forma mais raiz , voc\u00ea tamb\u00e9m o pode fazer pela linha de comando. Para isto, descubra o nome e localiza\u00e7\u00e3o do seu flash drive com dmesg | tail . Ap\u00f3s encontrar o drive, extraia o arquivo para o SD card com o comando: $ /usr/bin/unzip -p ~/ [ LOCAL_DE_DOWNLOAD ] /jetson_nano_devkit_sd_card.zip $ sudo /bin/dd of = /dev/sd [ NOME_DO_DRIVE ] bs = 1M status = progress Ap\u00f3s finalizado o processo, remova o drive de seu computador.","title":"Configurando o sistema operacional no SD card"},{"location":"2019/Pedro-OpenCV/#inserindo-o-sd-card-na-placa-jetson-nano","text":"A entrada do cart\u00e3o de mem\u00f3ria n\u00e3o \u00e9 muito vis\u00edvel para aqueles que est\u00e3o tendo o primeiro contato com a placa. Aqui h\u00e1 uma imagem para auxilia-lo(a) a encontrar a entrada do cart\u00e3o:","title":"Inserindo o SD card na placa Jetson Nano"},{"location":"2019/Pedro-OpenCV/#primeiro-boot","text":"Com o cart\u00e3o de mem\u00f3ria j\u00e1 inserido, \u00e9 preciso conectar os cabos na placa. N\u00e3o h\u00e1 \"bot\u00e3o de ligar ou desligar\" na placa, e o boot come\u00e7a automaticamente quando o cabo de alimenta\u00e7\u00e3o (supply de 5V (USB) OU fonte) estiver conectado. Al\u00e9m disso, lembre-se que ser\u00e1 preciso conex\u00e3o com a internet para os pr\u00f3ximos passos . Ap\u00f3s inserir as configura\u00e7\u00f5es de formato de teclado, regi\u00e3o e informa\u00e7\u00f5es 'pessoais' do ambiente Linux, a placa reiniciar\u00e1 e ent\u00e3o estar\u00e1 pronta para uso. Para maior comodidade, recomenda-se que a suspens\u00e3o autom\u00e1tica e screen lock sejam desativadas em All Settings -> Brightness & Lock , dado que alguns downloads e instala\u00e7\u00f5es possam demorar um pouco .","title":"Primeiro boot"},{"location":"2019/Pedro-OpenCV/#atualizando-libs-e-packages","text":"J\u00e1 que acabamos de configurar o sistema operacional, \u00e9 necess\u00e1rio executar os comandos sudo apt-get update e sudo apt-get upgrade .","title":"Atualizando libs e packages"},{"location":"2019/Pedro-OpenCV/#configurando-o-ambiente-python","text":"Para instalar bibliotecas adicionais, \u00e9 preciso instalar o pip. Para isto, execude os comandos a seguir: $ wget https://bootstrap.pypa.io/get-pip.py $ sudo python3 get-pip.py","title":"Configurando o ambiente Python"},{"location":"2019/Pedro-OpenCV/#configurando-o-ambiente-cuda","text":"$ wget http://developer.download.nvidia.com/compute/cuda/10.2/Prod/local_installers/cuda_10.2.89_440.33.01_linux.run $ sudo sh cuda_10.2.89_440.33.01_linux.run","title":"Configurando o ambiente CUDA"},{"location":"2019/Pedro-OpenCV/#configurando-o-ambiente-opencv","text":"Note Esse aqui demora... E MUITO! (~4 horas) Warning IMPORTANTE! Conecte um cooler \u00e0 placa e fa\u00e7a quest\u00e3o de utilizar a fonte de alimenta\u00e7\u00e3o normal em rela\u00e7\u00e3o \u00e0 USB para este processo, j\u00e1 que ele demanda MUITA pot\u00eancia e a placa atingir altas temperaturas, o que pode levar ao seu superaquecimento. Com o cooler instalado, rode as seguintes linhas de comando para instalar e compilar o OpenCV. E lembrando, \u00e9 uma looooooonga espera. $ wget https://github.com/AastaNV/JEP/blob/master/script/install_opencv4.1.1_Jetson.sh $ sudo sh install_opencv4.1.1_Jetson.sh $ export PYTHONPATH=/usr/local/python Ap\u00f3s realizada a build, abra um terminal python3 e rode o seguinte c\u00f3digo para testar o OpenCV: import cv2 print ( cv2 . getBuildInformation ()) A partir deste comando, \u00e9 possivel visualizar se o CUDA OpenCV est\u00e1 configurado, no campo NVIDIA CUDA","title":"Configurando o Ambiente OpenCV"},{"location":"2019/Pedro-OpenCV/#instalacao-pytorch","text":"A biblioteca Pytorch possui fun\u00e7\u00f5es que tornam poss\u00edvel a utiliza\u00e7\u00e3o da GPU no ambiente Python. Esta biblioteca ser\u00e1 utilizada para fazer alguns testes e compara\u00e7\u00f5es mais para frente no tutorial. $ wget https://nvidia.box.com/shared/static/phqe92v26cbhqjohwtvxorrwnmrnfx1o.whl -O torch-1.3.0-cp36-cp36m-linux_aarch64.whl $ pip3 install numpy torch-1.3.0-cp36-cp36m-linux_aarch64.whl Caso algum erro de depend\u00eancia relacionado ao numpy ocorra, reinstale-o. $ sudo pip uninstall numpy $ pip3 install numpy --user","title":"Instala\u00e7\u00e3o Pytorch"},{"location":"2019/Pedro-OpenCV/#cpu-vs-gpu","text":"A diferen\u00e7a no desempenho de certos c\u00f3digos executados em CPU ou GPU \u00e9 dada pela quantidade de c\u00e1lculos em paralelo que cada um dos hardwares consegue realizar. Dependendo da arquitetura dos hardwares, uma GPU pode executar centenas - ou at\u00e9 milhares - de vezes mais instru\u00e7\u00f5es por clock em rela\u00e7\u00e3o \u00e0 CPU. Por conta disto, GPUs s\u00e3o largamente utilizadas em processos que podem ser amplamente divididos e paralelizados em blocos, como \u00e9 o caso da multiplica\u00e7\u00e3o de matrizes com muitas linhas e colunas. O simples exemplo a seguir deixa evidente a diferen\u00e7a no desempenho. C\u00f3digo em CPU: import numpy as np import time x = np . random . rand ( 7000 , 16 ) y = np . random . rand ( 16 , 7000 ) start = time . time () z = np . matmul ( x , y ) end = time . time () print ( z ) print ( \" \\n Elapsed time CPU:\" , end - start , \"seconds\" ) C\u00f3digo em GPU: import torch import time x = torch . randn ( 7000 , 16 ) y = torch . randn ( 16 , 7000 ) start = time . time () z = torch . matmul ( x , y ) end = time . time () print ( z ) print ( \" \\n Elapsed time GPU:\" , end - start , \"seconds\" )","title":"CPU vs GPU"},{"location":"2019/Pedro-OpenCV/#cuda-opencv","text":"A GPU tamb\u00e9m \u00e9 de fundamental uso em outras aplica\u00e7\u00f5es como a rederiza\u00e7\u00e3o de v\u00eddeos e imagens e tamb\u00e9m no treinamento de modelos de Machine Learning e redes neurais. Desta forma,a biblioteca OpenCV pode ser utilizada para realizar tais tarefas na GPU.","title":"CUDA OpenCV"},{"location":"2019/Pedro-OpenCV/#instalacao-da-camera","text":"Caso esteja utilizando uma c\u00e2mera USB, pule esta etapa. Com a Jetson Nano desligada de todas as fontes de energia e com a c\u00e2mera Raspberry Pi 2.1 (1.3 n\u00e3o funciona), levante a trava localzada em um dos cantos da placa, for\u00e7ando-a para cima. Em seguida, insira o conector da c\u00e2mera (com \"a parte azul voltada para fora\") e ent\u00e3o pressione a trava novamente para baixo.","title":"Instala\u00e7\u00e3o da C\u00e2mera"},{"location":"2019/Pedro-OpenCV/#testando-a-camera-raspberry-pi","text":"Ap\u00f3s conectada, teste a c\u00e2mera para checar se ela realmente est\u00e1 funcional com a seguinte linha de c\u00f3digo no terminal. $ gst-launch-1.0 nvarguscamerasrc ! 'video/x-raw(memory:NVMM),width=3820, height=2464, framerate=21/1, format=NV12' ! nvvidconv flip-method = 0 ! 'video/x-raw,width=960, height=616' ! nvvidconv ! nvegltransform ! nveglglessink -e","title":"Testando a C\u00e2mera Raspberry Pi"},{"location":"2019/Pedro-OpenCV/#exemplo-e-comparacao-opencv-vs-opencv-cuda","text":"O c\u00f3digo \u00e0 seguir foi adaptado do Jetson Nano Hacks, sendo que o original pode ser encontrado neste link . Neste c\u00f3digo \u00e9 testada a diferen\u00e7a de desempenho da CPU em rela\u00e7\u00e3o \u00e0 GPU. import cv2 import time def gstreamer_pipeline ( capture_width = 640 , capture_height = 360 , display_width = 640 , display_height = 360 , framerate = 60 , flip_method = 0 , ): return ( \"nvarguscamerasrc ! \" \"video/x-raw(memory:NVMM), \" \"width=(int) %d , height=(int) %d , \" \"format=(string)NV12, framerate=(fraction) %d /1 ! \" \"nvvidconv flip-method= %d ! \" \"video/x-raw, width=(int) %d , height=(int) %d , format=(string)BGRx ! \" \"videoconvert ! \" \"video/x-raw, format=(string)BGR ! appsink\" % ( capture_width , capture_height , framerate , flip_method , display_width , display_height , ) ) def show_camera (): # To flip the image, modify the flip_method parameter (0 and 2 are the most common) print ( gstreamer_pipeline ( flip_method = 0 )) cap = cv2 . VideoCapture ( gstreamer_pipeline ( flip_method = 0 ), cv2 . CAP_GSTREAMER ) if cap . isOpened (): window_handle = cv2 . namedWindow ( \"CSI Camera\" , cv2 . WINDOW_AUTOSIZE ) # Window while cv2 . getWindowProperty ( \"CSI Camera\" , 0 ) >= 0 : ret_val , img = cap . read (); start = time . time () #Alterar aqui para \"c2.cuda.flip()\" ou \"cv2.flip()\" img2 = cv2 . cuda . flip ( img , 1 ) end = time . time () print ( \"Elapsed time\" , end - start ) cv2 . imshow ( \"CSI Camera\" , img2 ) keyCode = cv2 . waitKey ( 30 ) & 0xFF # Stop the program on the ESC key if keyCode == 27 : break cap . release () cv2 . destroyAllWindows () else : print ( \"Unable to open camera\" ) if __name__ == \"__main__\" : show_camera () Neste caso, devido ao fato de ser uma simples altera\u00e7\u00e3o na imagem como um flip , o programa demora mais para enviar a imagem para a GPU que realizar todo o processo na CPU. Contudo, com mais processos e opera\u00e7\u00f5es, o ganho de desempenho da GPU fica evidente. Al\u00e9m disso, para descobrir todas as fun\u00e7\u00f5es do m\u00f3dulo CUDA, abra um terminal Python3 e insira a linha dir(cv2.cuda) .","title":"Exemplo e compara\u00e7\u00e3o OpenCV vs OpenCV CUDA"},{"location":"2019/Toranja-DevDriver/","text":"Bruno Toranja - Linux Device Driver \u00b6 Aluno: Bruno Toranja Curso: Engenharia da Computa\u00e7\u00e3o Semestre: 7 Contato: Link tutorial oficial: https://github.com/brunoartc/virtual_com_driver Ano: 2019 Hardware utilizado no tutorial ? Introdu\u00e7\u00e3o \u00b6 Um driver de linux \u00e9 um programa que facilita a comunica\u00e7\u00e3o dos programas com a parte fisica do nosso dispositivo 1. Kernel space e user space \u00b6 Para entendermos como isso funciona primeiro temos que entender o que significam os programas e o kernel Os programas rodam em uma parte especial da nossa memoria chamada de espa\u00e7o de usuario, como por exemplo o python ou ate mesmo um bash, esses programas normalmente n\u00e3o precisam acessar itens de mais baixo nivel como por exemplo acesso direto a memoria ou portas UBS por exemplo. Essas tarefas sao executadas pelo kernel space que sabe lidar com o nosso hardware de uma maneira eficiente disponibilizando um tipo \"API\" para o user space lidar isso , e esse \u00e9 o trabalho dos drivers, a parte da tradu\u00e7\u00e3o dos comandos de usuario para que o kernel execute. 2. Como o driver conversa com o computador \u00b6 Os programas localizados no user space tem um momento especifico para pedir coisas para o kernel sobre o hardware como eh o caso de exploradores de arquivos e comunica\u00e7\u00e3o serial, caso algum desses programas queira se comunicar com um acessorio que n\u00e3o tenha seu proprio driver, temos um problema pois esse n\u00e3o conseguira ser comunicado Entao temos outra op\u00e7\u00e3o para isso, desenvolver nosso proprio driver, para ser compilado juntamente com o kernel e vir juntamente com ele, ou um simples modulo que \u00e9 compilado a parte e depois carregado no linux a partir do user space que ensinaremos nesse tutorial 3. cria\u00e7\u00e3o do modulo basico \u00b6 O nosso modulo precisa ser criado em alguma linguagem que o kernel do linux entenda, por isso utilizaremos o C a. Estrutura\u00e7\u00e3o de um modulo \u00b6 Primeiramente precisamo incluir a biblioteca de modulos do linux, para faremos um novo arquivo chamado de tcom.c touch tcom.c precisamos adicionar os headers no nosso arquivo tambem nano tcom.c dentro do arquivo temos que adicionar as duas linhas de bibliotecas para que possamos usar as fun\u00e7\u00f5es que conversam com o kernel alem de poder usar seus macros #include <linux/init.h> #include <linux/module.h> Com as bibliotecas importadas podemos come\u00e7ar o nosso codigo como por exemplo fazer dizer o que nosso driver far\u00e1 ao ser carregado e descarregado. Essas fun\u00e7\u00f5es tem um padr\u00e3o para se seguir em que a fun\u00e7\u00e3o de inicializa\u00e7\u00e3o retorna um inteiro e o exit nao retorna nada como mostrado acima referencia no linux static int init_com ( void ) { return 0 ; } static void finish_com ( void ) { return ; } module_init ( init_com ); module_exit ( finish_com ); essas duas funcoes podem ser chamadas pelas macros module_init e module_exit, que vao ser chamados no momento de inicio do modulo e saida do modulo referencia no linux tem tambem muitas outra op\u00e7\u00f5es para definir o autor do m\u00f3dulo e ate mesmo a licensa dele, mas nao entraremos em muitos detalhes b. Funcionalidades do modulo \u00b6 Podemos por exemplo fazer um driver que simplesmente mande um Hello World para o kernel quando ele \u00e9 inicializado para isso semelhante a um programa em C utilizaremos uma fun\u00e7\u00e3o print precisamos importar mais uma biblioteca para que essa fun\u00e7\u00e3o fique disponivel #include <linux/kernel.h> com essa func\u00e3o importada temos acesso ao printk uma fun\u00e7\u00e3o que printa ao log do kernel Ate agora temos um programa assim #include <linux/kernel.h> #include <linux/init.h> #include <linux/module.h> static int init_com ( void ) { printk ( \" \\n Hello World \\n \" ); return 0 ; } static void finish_com ( void ) { return ; } module_init ( init_com ); module_exit ( finish_com ); c. Compilando o modulo \u00b6 podemos entao compilar o nosso programa usando uma Makefile contendo obj-m := tcom.o usamos tambem por padrao o lib modules do nosso sistema que esta localizado em /lib/modules/$(uname -r)/build se for testar no seu linux deixe /lib/modules/$(uname -r)/build ou podemos gerar nosso proprio com um kernel do linux make modules_install INSTALL_MOD_PATH = /some/root/folder ou simplesmente dentro da sua pasta do linux make modules usando make -C /path/para/source/linux M = ` pwd ` modules para compilar ou use Makefile no repo d. Carregando o modulo e verificando \u00b6 com isso teremos um arquivo .ko que para todos os fins \u00e9 o nosso driver, este pode ser carregado e descarregado usando insmod e rmmod respectivamente como uma simples demosntra\u00e7\u00e3o podemos abrir um terminal e observar os logs do linux tail -f /var/log/kern.log enquanto em outro terminal compilamos o modulo e carregamos ele make -C /path/para/source/linux M = ` pwd ` modules sudo insmod ./tcom.ko sudo rmmod ./tcom.ko depois de executar esses comandos no linux voltamos ao nosso terminal que esta acompanhando o log do kernel e vemos que com sucesso obtivemos a mensagem kernel: [666.1337] Hello World Com isso temos a nossa primeira implementacao de um driver que simplesmesnte sobe uma mensagem para o kernel 4. cria\u00e7\u00e3o do modulo com funcionalidade (comunica\u00e7\u00e3o char) \u00b6 a. Adicionar novas funcionalidades \u00b6 Agora precisamos dar alguma funcionalidade para o nosso driver, como por exemplo interfacear com o hardware para simplesmente receber mensagens Como tudo no linux precisamos abrir um arquivo para fazer a comunicacao com o kernel space e este fazer a comunicacao com o hardware, para isso precisamos importar mais algumas bibliotecas /* para os codigos de erros que ser\u00e3o utilizados daqui para a frente */ #include <linux/errno.h> /* controlar o sistema de arquivos */ #include <linux/fs.h> #include <linux/proc_fs.h> /* alocar memoria no kernel space */ #include <linux/slab.h> /* medir o tamanho das variaveis usado no kmalloc */ #include <linux/types.h> #include <linux/fcntl.h> /* O_ACCMODE */ /* acessar o user space */ #include <asm/uaccess.h> com esses includes novos podemos trabalhar com algumas funcoes mais avancadas da criacao de drivers e dar mais um passo ao nosso vriver que interpreta mensagens do hardware fisico mas ainda preisamos fazer as funcoes que permitem que nosso driver funcione, no caso para excrever e ler apenas um char. b. Adicionar a rela\u00e7\u00e3o do driver com o hardware \u00b6 comecaremos declarando qual a regiao de memoria que iremos acessar com o numero de identifica\u00e7\u00e3o do driver para ele acessar os perifericos que utilizam desse driver /* o numero da versao do nosso driver */ int memory_major = 60 ; /* onde nossa memoria vai ser salva*/ char * memory_buffer ; c. Fun\u00e7\u00f5es de inicializa\u00e7\u00e3o de memoria \u00b6 temos tambem que mudar nossa fun\u00e7\u00e3o de inicializa\u00e7\u00e3o para que quando o driver se inicialize ele aloque um espa\u00e7o de memoria que ser\u00e1 usado, assim como um programa em C, sua libera\u00e7\u00e3o tambem deve ser criada, nossa fun\u00e7\u00e3o de inicializa\u00e7\u00e3o e saida deve ser mais ou menos assim int memory_init ( void ) { int result ; /* Registrar o nosso driver para os hardwares certos */ result = register_chrdev ( memory_major , \"memory\" , & memory_fops ); /* Alocar o espa\u00e7o de memoria para o programa*/ memory_buffer = kmalloc ( 1 , GFP_KERNEL ); if ( ! memory_buffer ) { result = - ENOMEM ; memory_exit (); return result ; } memset ( memory_buffer , 0 , 1 ); printk ( \"<1>Driver simples de memoria inicializado \\n \" ); return 0 ; } void memory_exit ( void ) { /* Liberando o numero de registro no sistema*/ unregister_chrdev ( memory_major , \"memory\" ); /* Liberando o espa\u00e7o de memoria */ if ( memory_buffer ) { kfree ( memory_buffer ); } printk ( \"<1>Liberando memorias e descarregando modulo \\n \" ); } d. Fun\u00e7\u00f5es para manipula\u00e7\u00e3o de memoria \u00b6 temos agora uma parte do nosso programa para iniciar e liberar espa\u00e7os de memoria que podemos trabalhar, mas nosso driver ainda nao executa nenhuma fun\u00e7\u00e3o para isso faremos uma funcao que abre o nosso \"arquivo\" e uma que deixa nosso arquivo disponivel para outros programas apos a execu\u00e7\u00e3o da primeira int memory_open ( struct inode * inode , struct file * filp ) { /* Success */ return 0 ; } int memory_release ( struct inode * inode , struct file * filp ) { /* Success */ return 0 ; } agora tambem precisamos que apos abrir o local de memoria do nosso driver nos possamos ler e escrever nele podemos fazer isso com uma fun\u00e7\u00e3o que copia do buffer para a nossa memoria e vice-versa ssize_t memory_read ( struct file * filp , const char * buf , size_t count , loff_t * f_pos ) { /* Transfering data to user space */ copy_to_user ( buf , memory_buffer , 1 ); /* Changing reading position as best suits */ if ( * f_pos == 0 ) { * f_pos += 1 ; return 1 ; } else { return 0 ; } } ssize_t memory_write ( struct file * filp , char * buf , size_t count , loff_t * f_pos ) { char * tmp ; tmp = buf + count -1 ; copy_from_user ( memory_buffer , tmp , 1 ); return 1 ; } ate agora fizemos um modulo para o nosso proprio linux mas podemos tambem fazer a compila\u00e7\u00e3o de um modulo para um dispositivo ARM embarcado simplesmente mudando algumas linhas do nosso Makefile export CROSS_COMPILE = export ARCH = x86_64 por export CROSS_COMPILE = gcc-arm-linux-gnueabi- export ARCH = arm agora que temos um driver simples que consegue compreender o que escrevemos e passar para um hardware virtual nosso podemos passar para coisas um pouco mais uteis e complexas como por exemplo controlar um led da placa, e \u00e9 isso que faremos nessa sess\u00e3o 5. driver que controla GPIO do raspberry \u00b6 primeiramente utilizaremos o outro codigo de esqueleto ele tem que estar mais ou menos assim #include <linux/kernel.h> #include <linux/init.h> #include <linux/module.h> /* para os codigos de erros que ser\u00e3o utilizados daqui para a frente */ #include <linux/errno.h> /* controlar o sistema de arquivos */ #include <linux/fs.h> #include <linux/proc_fs.h> #include <asm/uaccess.h> /* alocar memoria no kernel space */ #include <linux/slab.h> /* medir o tamanho das variaveis usado no kmalloc */ #include <linux/types.h> #include <linux/fcntl.h> /* O_ACCMODE */ int memory_major = 60 ; /* Buffer para guardar os dados */ char * memory_buffer ; static void finish_com ( void ) { /* liberando o numero de versao */ unregister_chrdev ( memory_major , \"memory\" ); /* liberando a memoria para outro programa */ if ( memory_buffer ) { kfree ( memory_buffer ); } printk ( \"<1>Removing memory module \\n \" ); } int memory_open ( struct inode * inode , struct file * filp ) { /* Success */ return 0 ; } int memory_release ( struct inode * inode , struct file * filp ) { /* Success */ return 0 ; } static ssize_t memory_read ( struct file * filp , char * buf , size_t count , loff_t * f_pos ) { /* Copia para o user space */ raw_copy_to_user ( buf , memory_buffer , 1 ); /* Changing reading position as best suits */ if ( * f_pos == 0 ) { * f_pos += 1 ; return 1 ; } else { return 0 ; } } static ssize_t memory_write ( struct file * filp , const char * buf , size_t count , loff_t * f_pos ) { char * tmp ; tmp = buf + count -1 ; raw_copy_from_user ( memory_buffer , tmp , 1 ); return 1 ; } static struct file_operations tcom_fops = { . owner = THIS_MODULE , . read = memory_read , . write = memory_write , . open = memory_open , . release = memory_release }; static int init_com ( void ) { int result ; /* registrando o driver */ register_chrdev ( memory_major , \"memory\" , & tcom_fops ); //TODO FIX NULL with pointer to file_operands /* alocar a memoria para o driver */ memory_buffer = kmalloc ( 1 , GFP_KERNEL ); if ( ! memory_buffer ) { result = - ENOMEM ; finish_com (); return result ; } memset ( memory_buffer , 0 , 1 ); return 0 ; } MODULE_LICENSE ( \"Dual BSD/GPL\" ); module_init ( init_com ); module_exit ( finish_com ); com esse codigo que fizemos na sessao anterior temos apensar que criar uma fun\u00e7\u00e3o que receba de input os nossos enderecos de memorias do pino e definir como os bits que precisam estar ligados como por exemplo vamos usar como base um raspbery e seus GPIOs ( https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf ) definimos primeiro a estrutura de um GPIO da rapberry como o exmplo abaixo struct GpioRegisters { uint32_t GPFSEL[6]; uint32_t Reserved1; uint32_t GPSET[2]; uint32_t Reserved2; uint32_t GPCLR[2]; }; struct GpioRegisters *s_pGpioRegisters; ent\u00e3o precisamos agora definir as funcoes para podermos fazer alguma coisa quando tivermos os registradores do raspberry para isso podemos utilizar das seguintes funcoes static void definirFuncaoDoGPIO ( int GPIO , int functionCode ) { int IndexRegistrador = GPIO / 10 ; int bit = ( GPIO % 10 ) * 3 ; unsigned oldValue = s_pGpioRegisters -> GPFSEL [ IndexRegistrador ]; unsigned mask = 0b111 << bit ; s_pGpioRegisters -> GPFSEL [ IndexRegistrador ] = ( oldValue & ~ mask ) | (( functionCode << bit ) & mask ); } static void SetGPIOOutputValue ( int GPIO , bool outputValue ) { if ( outputValue ) s_pGpioRegisters -> GPSET [ GPIO / 32 ] = ( 1 << ( GPIO % 32 )); else s_pGpioRegisters -> GPCLR [ GPIO / 32 ] = ( 1 << ( GPIO % 32 )); } com essas funcoes para a manipula\u00e7\u00e3o das GPIOs do nosso raspberry podemos criar um timer que aciona elas em momentos distintos para deixar o pino escolhido como alto ou baixo e verificar com o nosso led Poderiamos usar timer mas por questoes de tempo so deixaremos um pino no estado alto e veremos o seu efeito e logo em seguida ao descarregarmos o driver ele voltara ao seu estado normal de input caso alguem queria tentera depois com a biblioteca de timers tambem deixo o codigo fonte da biblioteca para ser estudado aqui static int __init LedBlinkModule_init ( void ) { int result ; s_pGpioRegisters = ( struct GpioRegisters * ) __io_address ( GPIO_BASE ); SetGPIOFunction ( LedGpioPin , 0b001 ); //Output SetGPIOOutputValue ( LedGpioPin , 1 ) } static void __exit LedBlinkModule_exit ( void ) { SetGPIOFunction ( LedGpioPin , 0 ); //Configure the pin as input del_timer ( & s_BlinkTimer ); } podedmos passar para algo mais avan\u00e7ado como \u00e9 o caso das interrup\u00e7\u00f5es, como ja temos um conhecimento geral de como sao feitos os drivers de linux podemos pular as etapas sobre a inicializa\u00e7\u00e3o e saida dos drivers bem como o Makefile e suas dependencias","title":"Bruno Toranja - Linux Device Driver"},{"location":"2019/Toranja-DevDriver/#bruno-toranja-linux-device-driver","text":"Aluno: Bruno Toranja Curso: Engenharia da Computa\u00e7\u00e3o Semestre: 7 Contato: Link tutorial oficial: https://github.com/brunoartc/virtual_com_driver Ano: 2019 Hardware utilizado no tutorial ?","title":"Bruno Toranja - Linux Device Driver"},{"location":"2019/Toranja-DevDriver/#introducao","text":"Um driver de linux \u00e9 um programa que facilita a comunica\u00e7\u00e3o dos programas com a parte fisica do nosso dispositivo","title":"Introdu\u00e7\u00e3o"},{"location":"2019/Toranja-DevDriver/#1-kernel-space-e-user-space","text":"Para entendermos como isso funciona primeiro temos que entender o que significam os programas e o kernel Os programas rodam em uma parte especial da nossa memoria chamada de espa\u00e7o de usuario, como por exemplo o python ou ate mesmo um bash, esses programas normalmente n\u00e3o precisam acessar itens de mais baixo nivel como por exemplo acesso direto a memoria ou portas UBS por exemplo. Essas tarefas sao executadas pelo kernel space que sabe lidar com o nosso hardware de uma maneira eficiente disponibilizando um tipo \"API\" para o user space lidar isso , e esse \u00e9 o trabalho dos drivers, a parte da tradu\u00e7\u00e3o dos comandos de usuario para que o kernel execute.","title":"1. Kernel space e user space"},{"location":"2019/Toranja-DevDriver/#2-como-o-driver-conversa-com-o-computador","text":"Os programas localizados no user space tem um momento especifico para pedir coisas para o kernel sobre o hardware como eh o caso de exploradores de arquivos e comunica\u00e7\u00e3o serial, caso algum desses programas queira se comunicar com um acessorio que n\u00e3o tenha seu proprio driver, temos um problema pois esse n\u00e3o conseguira ser comunicado Entao temos outra op\u00e7\u00e3o para isso, desenvolver nosso proprio driver, para ser compilado juntamente com o kernel e vir juntamente com ele, ou um simples modulo que \u00e9 compilado a parte e depois carregado no linux a partir do user space que ensinaremos nesse tutorial","title":"2. Como o driver conversa com o computador"},{"location":"2019/Toranja-DevDriver/#3-criacao-do-modulo-basico","text":"O nosso modulo precisa ser criado em alguma linguagem que o kernel do linux entenda, por isso utilizaremos o C","title":"3. cria\u00e7\u00e3o do modulo basico"},{"location":"2019/Toranja-DevDriver/#a-estruturacao-de-um-modulo","text":"Primeiramente precisamo incluir a biblioteca de modulos do linux, para faremos um novo arquivo chamado de tcom.c touch tcom.c precisamos adicionar os headers no nosso arquivo tambem nano tcom.c dentro do arquivo temos que adicionar as duas linhas de bibliotecas para que possamos usar as fun\u00e7\u00f5es que conversam com o kernel alem de poder usar seus macros #include <linux/init.h> #include <linux/module.h> Com as bibliotecas importadas podemos come\u00e7ar o nosso codigo como por exemplo fazer dizer o que nosso driver far\u00e1 ao ser carregado e descarregado. Essas fun\u00e7\u00f5es tem um padr\u00e3o para se seguir em que a fun\u00e7\u00e3o de inicializa\u00e7\u00e3o retorna um inteiro e o exit nao retorna nada como mostrado acima referencia no linux static int init_com ( void ) { return 0 ; } static void finish_com ( void ) { return ; } module_init ( init_com ); module_exit ( finish_com ); essas duas funcoes podem ser chamadas pelas macros module_init e module_exit, que vao ser chamados no momento de inicio do modulo e saida do modulo referencia no linux tem tambem muitas outra op\u00e7\u00f5es para definir o autor do m\u00f3dulo e ate mesmo a licensa dele, mas nao entraremos em muitos detalhes","title":"a. Estrutura\u00e7\u00e3o de um modulo"},{"location":"2019/Toranja-DevDriver/#b-funcionalidades-do-modulo","text":"Podemos por exemplo fazer um driver que simplesmente mande um Hello World para o kernel quando ele \u00e9 inicializado para isso semelhante a um programa em C utilizaremos uma fun\u00e7\u00e3o print precisamos importar mais uma biblioteca para que essa fun\u00e7\u00e3o fique disponivel #include <linux/kernel.h> com essa func\u00e3o importada temos acesso ao printk uma fun\u00e7\u00e3o que printa ao log do kernel Ate agora temos um programa assim #include <linux/kernel.h> #include <linux/init.h> #include <linux/module.h> static int init_com ( void ) { printk ( \" \\n Hello World \\n \" ); return 0 ; } static void finish_com ( void ) { return ; } module_init ( init_com ); module_exit ( finish_com );","title":"b. Funcionalidades do modulo"},{"location":"2019/Toranja-DevDriver/#c-compilando-o-modulo","text":"podemos entao compilar o nosso programa usando uma Makefile contendo obj-m := tcom.o usamos tambem por padrao o lib modules do nosso sistema que esta localizado em /lib/modules/$(uname -r)/build se for testar no seu linux deixe /lib/modules/$(uname -r)/build ou podemos gerar nosso proprio com um kernel do linux make modules_install INSTALL_MOD_PATH = /some/root/folder ou simplesmente dentro da sua pasta do linux make modules usando make -C /path/para/source/linux M = ` pwd ` modules para compilar ou use Makefile no repo","title":"c. Compilando o modulo"},{"location":"2019/Toranja-DevDriver/#d-carregando-o-modulo-e-verificando","text":"com isso teremos um arquivo .ko que para todos os fins \u00e9 o nosso driver, este pode ser carregado e descarregado usando insmod e rmmod respectivamente como uma simples demosntra\u00e7\u00e3o podemos abrir um terminal e observar os logs do linux tail -f /var/log/kern.log enquanto em outro terminal compilamos o modulo e carregamos ele make -C /path/para/source/linux M = ` pwd ` modules sudo insmod ./tcom.ko sudo rmmod ./tcom.ko depois de executar esses comandos no linux voltamos ao nosso terminal que esta acompanhando o log do kernel e vemos que com sucesso obtivemos a mensagem kernel: [666.1337] Hello World Com isso temos a nossa primeira implementacao de um driver que simplesmesnte sobe uma mensagem para o kernel","title":"d. Carregando o modulo e verificando"},{"location":"2019/Toranja-DevDriver/#4-criacao-do-modulo-com-funcionalidade-comunicacao-char","text":"","title":"4. cria\u00e7\u00e3o do modulo com funcionalidade (comunica\u00e7\u00e3o char)"},{"location":"2019/Toranja-DevDriver/#a-adicionar-novas-funcionalidades","text":"Agora precisamos dar alguma funcionalidade para o nosso driver, como por exemplo interfacear com o hardware para simplesmente receber mensagens Como tudo no linux precisamos abrir um arquivo para fazer a comunicacao com o kernel space e este fazer a comunicacao com o hardware, para isso precisamos importar mais algumas bibliotecas /* para os codigos de erros que ser\u00e3o utilizados daqui para a frente */ #include <linux/errno.h> /* controlar o sistema de arquivos */ #include <linux/fs.h> #include <linux/proc_fs.h> /* alocar memoria no kernel space */ #include <linux/slab.h> /* medir o tamanho das variaveis usado no kmalloc */ #include <linux/types.h> #include <linux/fcntl.h> /* O_ACCMODE */ /* acessar o user space */ #include <asm/uaccess.h> com esses includes novos podemos trabalhar com algumas funcoes mais avancadas da criacao de drivers e dar mais um passo ao nosso vriver que interpreta mensagens do hardware fisico mas ainda preisamos fazer as funcoes que permitem que nosso driver funcione, no caso para excrever e ler apenas um char.","title":"a. Adicionar novas funcionalidades"},{"location":"2019/Toranja-DevDriver/#b-adicionar-a-relacao-do-driver-com-o-hardware","text":"comecaremos declarando qual a regiao de memoria que iremos acessar com o numero de identifica\u00e7\u00e3o do driver para ele acessar os perifericos que utilizam desse driver /* o numero da versao do nosso driver */ int memory_major = 60 ; /* onde nossa memoria vai ser salva*/ char * memory_buffer ;","title":"b. Adicionar a rela\u00e7\u00e3o do driver com o hardware"},{"location":"2019/Toranja-DevDriver/#c-funcoes-de-inicializacao-de-memoria","text":"temos tambem que mudar nossa fun\u00e7\u00e3o de inicializa\u00e7\u00e3o para que quando o driver se inicialize ele aloque um espa\u00e7o de memoria que ser\u00e1 usado, assim como um programa em C, sua libera\u00e7\u00e3o tambem deve ser criada, nossa fun\u00e7\u00e3o de inicializa\u00e7\u00e3o e saida deve ser mais ou menos assim int memory_init ( void ) { int result ; /* Registrar o nosso driver para os hardwares certos */ result = register_chrdev ( memory_major , \"memory\" , & memory_fops ); /* Alocar o espa\u00e7o de memoria para o programa*/ memory_buffer = kmalloc ( 1 , GFP_KERNEL ); if ( ! memory_buffer ) { result = - ENOMEM ; memory_exit (); return result ; } memset ( memory_buffer , 0 , 1 ); printk ( \"<1>Driver simples de memoria inicializado \\n \" ); return 0 ; } void memory_exit ( void ) { /* Liberando o numero de registro no sistema*/ unregister_chrdev ( memory_major , \"memory\" ); /* Liberando o espa\u00e7o de memoria */ if ( memory_buffer ) { kfree ( memory_buffer ); } printk ( \"<1>Liberando memorias e descarregando modulo \\n \" ); }","title":"c. Fun\u00e7\u00f5es de inicializa\u00e7\u00e3o de memoria"},{"location":"2019/Toranja-DevDriver/#d-funcoes-para-manipulacao-de-memoria","text":"temos agora uma parte do nosso programa para iniciar e liberar espa\u00e7os de memoria que podemos trabalhar, mas nosso driver ainda nao executa nenhuma fun\u00e7\u00e3o para isso faremos uma funcao que abre o nosso \"arquivo\" e uma que deixa nosso arquivo disponivel para outros programas apos a execu\u00e7\u00e3o da primeira int memory_open ( struct inode * inode , struct file * filp ) { /* Success */ return 0 ; } int memory_release ( struct inode * inode , struct file * filp ) { /* Success */ return 0 ; } agora tambem precisamos que apos abrir o local de memoria do nosso driver nos possamos ler e escrever nele podemos fazer isso com uma fun\u00e7\u00e3o que copia do buffer para a nossa memoria e vice-versa ssize_t memory_read ( struct file * filp , const char * buf , size_t count , loff_t * f_pos ) { /* Transfering data to user space */ copy_to_user ( buf , memory_buffer , 1 ); /* Changing reading position as best suits */ if ( * f_pos == 0 ) { * f_pos += 1 ; return 1 ; } else { return 0 ; } } ssize_t memory_write ( struct file * filp , char * buf , size_t count , loff_t * f_pos ) { char * tmp ; tmp = buf + count -1 ; copy_from_user ( memory_buffer , tmp , 1 ); return 1 ; } ate agora fizemos um modulo para o nosso proprio linux mas podemos tambem fazer a compila\u00e7\u00e3o de um modulo para um dispositivo ARM embarcado simplesmente mudando algumas linhas do nosso Makefile export CROSS_COMPILE = export ARCH = x86_64 por export CROSS_COMPILE = gcc-arm-linux-gnueabi- export ARCH = arm agora que temos um driver simples que consegue compreender o que escrevemos e passar para um hardware virtual nosso podemos passar para coisas um pouco mais uteis e complexas como por exemplo controlar um led da placa, e \u00e9 isso que faremos nessa sess\u00e3o","title":"d. Fun\u00e7\u00f5es para manipula\u00e7\u00e3o de memoria"},{"location":"2019/Toranja-DevDriver/#5-driver-que-controla-gpio-do-raspberry","text":"primeiramente utilizaremos o outro codigo de esqueleto ele tem que estar mais ou menos assim #include <linux/kernel.h> #include <linux/init.h> #include <linux/module.h> /* para os codigos de erros que ser\u00e3o utilizados daqui para a frente */ #include <linux/errno.h> /* controlar o sistema de arquivos */ #include <linux/fs.h> #include <linux/proc_fs.h> #include <asm/uaccess.h> /* alocar memoria no kernel space */ #include <linux/slab.h> /* medir o tamanho das variaveis usado no kmalloc */ #include <linux/types.h> #include <linux/fcntl.h> /* O_ACCMODE */ int memory_major = 60 ; /* Buffer para guardar os dados */ char * memory_buffer ; static void finish_com ( void ) { /* liberando o numero de versao */ unregister_chrdev ( memory_major , \"memory\" ); /* liberando a memoria para outro programa */ if ( memory_buffer ) { kfree ( memory_buffer ); } printk ( \"<1>Removing memory module \\n \" ); } int memory_open ( struct inode * inode , struct file * filp ) { /* Success */ return 0 ; } int memory_release ( struct inode * inode , struct file * filp ) { /* Success */ return 0 ; } static ssize_t memory_read ( struct file * filp , char * buf , size_t count , loff_t * f_pos ) { /* Copia para o user space */ raw_copy_to_user ( buf , memory_buffer , 1 ); /* Changing reading position as best suits */ if ( * f_pos == 0 ) { * f_pos += 1 ; return 1 ; } else { return 0 ; } } static ssize_t memory_write ( struct file * filp , const char * buf , size_t count , loff_t * f_pos ) { char * tmp ; tmp = buf + count -1 ; raw_copy_from_user ( memory_buffer , tmp , 1 ); return 1 ; } static struct file_operations tcom_fops = { . owner = THIS_MODULE , . read = memory_read , . write = memory_write , . open = memory_open , . release = memory_release }; static int init_com ( void ) { int result ; /* registrando o driver */ register_chrdev ( memory_major , \"memory\" , & tcom_fops ); //TODO FIX NULL with pointer to file_operands /* alocar a memoria para o driver */ memory_buffer = kmalloc ( 1 , GFP_KERNEL ); if ( ! memory_buffer ) { result = - ENOMEM ; finish_com (); return result ; } memset ( memory_buffer , 0 , 1 ); return 0 ; } MODULE_LICENSE ( \"Dual BSD/GPL\" ); module_init ( init_com ); module_exit ( finish_com ); com esse codigo que fizemos na sessao anterior temos apensar que criar uma fun\u00e7\u00e3o que receba de input os nossos enderecos de memorias do pino e definir como os bits que precisam estar ligados como por exemplo vamos usar como base um raspbery e seus GPIOs ( https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf ) definimos primeiro a estrutura de um GPIO da rapberry como o exmplo abaixo struct GpioRegisters { uint32_t GPFSEL[6]; uint32_t Reserved1; uint32_t GPSET[2]; uint32_t Reserved2; uint32_t GPCLR[2]; }; struct GpioRegisters *s_pGpioRegisters; ent\u00e3o precisamos agora definir as funcoes para podermos fazer alguma coisa quando tivermos os registradores do raspberry para isso podemos utilizar das seguintes funcoes static void definirFuncaoDoGPIO ( int GPIO , int functionCode ) { int IndexRegistrador = GPIO / 10 ; int bit = ( GPIO % 10 ) * 3 ; unsigned oldValue = s_pGpioRegisters -> GPFSEL [ IndexRegistrador ]; unsigned mask = 0b111 << bit ; s_pGpioRegisters -> GPFSEL [ IndexRegistrador ] = ( oldValue & ~ mask ) | (( functionCode << bit ) & mask ); } static void SetGPIOOutputValue ( int GPIO , bool outputValue ) { if ( outputValue ) s_pGpioRegisters -> GPSET [ GPIO / 32 ] = ( 1 << ( GPIO % 32 )); else s_pGpioRegisters -> GPCLR [ GPIO / 32 ] = ( 1 << ( GPIO % 32 )); } com essas funcoes para a manipula\u00e7\u00e3o das GPIOs do nosso raspberry podemos criar um timer que aciona elas em momentos distintos para deixar o pino escolhido como alto ou baixo e verificar com o nosso led Poderiamos usar timer mas por questoes de tempo so deixaremos um pino no estado alto e veremos o seu efeito e logo em seguida ao descarregarmos o driver ele voltara ao seu estado normal de input caso alguem queria tentera depois com a biblioteca de timers tambem deixo o codigo fonte da biblioteca para ser estudado aqui static int __init LedBlinkModule_init ( void ) { int result ; s_pGpioRegisters = ( struct GpioRegisters * ) __io_address ( GPIO_BASE ); SetGPIOFunction ( LedGpioPin , 0b001 ); //Output SetGPIOOutputValue ( LedGpioPin , 1 ) } static void __exit LedBlinkModule_exit ( void ) { SetGPIOFunction ( LedGpioPin , 0 ); //Configure the pin as input del_timer ( & s_BlinkTimer ); } podedmos passar para algo mais avan\u00e7ado como \u00e9 o caso das interrup\u00e7\u00f5es, como ja temos um conhecimento geral de como sao feitos os drivers de linux podemos pular as etapas sobre a inicializa\u00e7\u00e3o e saida dos drivers bem como o Makefile e suas dependencias","title":"5. driver que controla GPIO do raspberry"},{"location":"2019/Tutoriais/","text":"Tutoriais 2019 \u00b6 Tutoriais desenvolvidos pelos alunos da eletiva de Embarcados Avan\u00e7ados.","title":"Tutoriais 2019"},{"location":"2019/Tutoriais/#tutoriais-2019","text":"Tutoriais desenvolvidos pelos alunos da eletiva de Embarcados Avan\u00e7ados.","title":"Tutoriais 2019"},{"location":"2020/Temas/","text":"Temas 20b \u00b6 Temas dos tutoriais da disciplina em 2020: Android embarcado AWS F1 Doom Criptografia PS3 hack \u00c1udio Android \u00b6 Como compilar e executar o android para a placa DE10-Standard raspberry-pi. Alunos: Emanuelle Silva Mo\u00e7o Lucas Leal Vale Leonardo Mendes de Moraes Rubrica: A: Desenvolver uma aplica\u00e7\u00e3o (tipo t\u00f3tem) B: Customizando o android (tempo de boot/ programas/ ...) C: Como compilar o android para rasp Preporcessamento de dados - AWS F1 \u00b6 Trabalhar com preprocessamento e extra\u00e7\u00e3o de features para uso de redes neurais, aplicado a um exemplo do tensorflow Alunos: Vinicius Gomes de Lima Lucca Delchiaro Costabile Rubrica: A: Solucionar algum problema B: Compara\u00e7\u00e3o com GPU/FPGA C: Metropolis python module \u00b6 ~Executar um port do doom na placa DE10-Standard~ Tutorial explicando como criar um lib em C que pode ser importada no python. Alunos: Henry Furquim Rocha Gustavo Beltr\u00e3o Braga Thomas de Quiroz Barros Schneider Rubricas: A: Crosscompile B: Compara\u00e7\u00e3o C: Explicar como funciona modulos do pythom em lib, mostrar um exemplo. Criptografia \u00b6 Trabalhar com criptografia em hardware Alunos: Antonio Jo\u00e3o Andraues Junior Samuel Vinicius Granato de Barros Gabriel Francato A: Realizar a pr\u00f3pria implementa\u00e7\u00e3o (RTL/HLS/opencl) B: Aumentar seguran\u00e7a dos dados (como proteger de ataques?) C: Escolher um algor\u00edtimo de cripto, explicar, criar um SoC com um m\u00f3dulo que queraliza a cripto, validar. PS3 Hack \u00b6 Hacker o playstation 3 executar Linux e bolar uma aplica\u00e7\u00e3o para ele. Alunos: Guilherme Peres Leite Gabriel Lopes Monteiro Hugo Ebert Carl Rubricas: A: Emulador B: Aplica\u00e7\u00e3o simples C+: Kernel C: PS3, explicar o console, como faz subir o linux customizado, buildroot \u00c1udio \u00b6 Trabalhar com \u00e1udio em sistemas embarcados. Alunos: Francisco","title":"Temas 20b"},{"location":"2020/Temas/#temas-20b","text":"Temas dos tutoriais da disciplina em 2020: Android embarcado AWS F1 Doom Criptografia PS3 hack \u00c1udio","title":"Temas 20b"},{"location":"2020/Temas/#android","text":"Como compilar e executar o android para a placa DE10-Standard raspberry-pi. Alunos: Emanuelle Silva Mo\u00e7o Lucas Leal Vale Leonardo Mendes de Moraes Rubrica: A: Desenvolver uma aplica\u00e7\u00e3o (tipo t\u00f3tem) B: Customizando o android (tempo de boot/ programas/ ...) C: Como compilar o android para rasp","title":"Android"},{"location":"2020/Temas/#preporcessamento-de-dados-aws-f1","text":"Trabalhar com preprocessamento e extra\u00e7\u00e3o de features para uso de redes neurais, aplicado a um exemplo do tensorflow Alunos: Vinicius Gomes de Lima Lucca Delchiaro Costabile Rubrica: A: Solucionar algum problema B: Compara\u00e7\u00e3o com GPU/FPGA C: Metropolis","title":"Preporcessamento de dados - AWS F1"},{"location":"2020/Temas/#python-module","text":"~Executar um port do doom na placa DE10-Standard~ Tutorial explicando como criar um lib em C que pode ser importada no python. Alunos: Henry Furquim Rocha Gustavo Beltr\u00e3o Braga Thomas de Quiroz Barros Schneider Rubricas: A: Crosscompile B: Compara\u00e7\u00e3o C: Explicar como funciona modulos do pythom em lib, mostrar um exemplo.","title":"python module"},{"location":"2020/Temas/#criptografia","text":"Trabalhar com criptografia em hardware Alunos: Antonio Jo\u00e3o Andraues Junior Samuel Vinicius Granato de Barros Gabriel Francato A: Realizar a pr\u00f3pria implementa\u00e7\u00e3o (RTL/HLS/opencl) B: Aumentar seguran\u00e7a dos dados (como proteger de ataques?) C: Escolher um algor\u00edtimo de cripto, explicar, criar um SoC com um m\u00f3dulo que queraliza a cripto, validar.","title":"Criptografia"},{"location":"2020/Temas/#ps3-hack","text":"Hacker o playstation 3 executar Linux e bolar uma aplica\u00e7\u00e3o para ele. Alunos: Guilherme Peres Leite Gabriel Lopes Monteiro Hugo Ebert Carl Rubricas: A: Emulador B: Aplica\u00e7\u00e3o simples C+: Kernel C: PS3, explicar o console, como faz subir o linux customizado, buildroot","title":"PS3 Hack"},{"location":"2020/Temas/#audio","text":"Trabalhar com \u00e1udio em sistemas embarcados. Alunos: Francisco","title":"\u00c1udio"},{"location":"2020/Android/","text":"Android para Raspbery Pi 3 \u00b6 Alunes: Emanuelle Mo\u00e7o / Leonardo Mendes / Lucas Leal Curso: Engenharia da Computa\u00e7\u00e3o Semestre: 6 Contato: corsiferrao@gmail.com , emanuellesm@al.insper.edu.br , leonardomm4@al.insper.edu.br , lucaslv1@al.insper.edu.br Ano: 2020 Come\u00e7ando \u00b6 Para seguir esse tutorial \u00e9 necess\u00e1rio: Hardware Raspberry Pi 3 Micro SD Card de 8 GB ou maior Monitor com entrada Mouse Adaptador Micro SD para USB Cabo Micro USB Computador com pelo menos 150GB de armazenamento dispon\u00edvel Softwares Ubuntu 18.04 Refer\u00eancias: device_brcm_rpi3 , Build Android for Raspberry Pi3 , Building Android for Raspberry Pi Motiva\u00e7\u00e3o \u00b6 A motiva\u00e7\u00e3o inicial era compilar Android em uma FPGA e o tema foi escolhido pois o grupo tinha o desejo de compilar um software de alto n\u00edvel em uma placa de desenvolvimento. Entretanto, por dificuldades t\u00e9cnicas, foi decidido migrar para uma Raspberry Pi, que por ser mais barata e acess\u00edvel ao p\u00fablico, existe uma quantidade significativa de refer\u00eancias, viabilizando a cria\u00e7\u00e3o de aplica\u00e7\u00f5es. Contexto \u00b6 O sistema operacional Android \u00e9 extremamente popular e muito presente em dispositivos mobile, presente em cerca de 70% de celulares no mundo. Este tutorial consiste em embarcar o Android utilizando LineageOS, uma distribui\u00e7\u00e3o open source de Android, numa Raspberry Pi 3 B+. Android \u00b6 Android \u00e9 um sistema operacional baseado no kernel do linux no qual \u00e9 poss\u00edvel compilar o seu pr\u00f3prio sistema para utilizar em um celular ou placas de desenvolvimento. Raspberry Pi \u00b6 Raspberry Pi \u00e9 um microcomputador do estilo System On a Chip que permite fazer tudo que um computador faz com baixo custo. O modelo utilizado neste roteiro \u00e9 o Raspberry Pi 3 B+, a qual possui um processador 64-bit quad-core de 1.4GHz, dual-band wireless e bluetooth. Ou seja, adequada para aplica\u00e7\u00f5es de automa\u00e7\u00e3o e IOT. Instala\u00e7\u00e3o \u00b6 Warning Alguns dos passos exigem alto poder computacional, caso voc\u00ea n\u00e3o tenha uma m\u00e1quina com o armazenamento m\u00ednimo necess\u00e1rio ou com um bom processador, sugerimos a utiliza\u00e7\u00e3o de uma m\u00e1quina na nuvem. Sugest\u00e3o Para esse tutorial, utilizamos uma inst\u00e2ncia da AWS t2.2xlarge. Configurando o ambiente \u00b6 Uma vez no Ubuntu 18.04, ser\u00e1 necess\u00e1rio a instala\u00e7\u00e3o de alguns pacotes ess\u00eanciais, para saber mais, entre na p\u00e1gina disponibilizada pelo Andoid . $ sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig openjdk-8-jdk gcc-arm-linux-gnueabihf libssl-dev python-mako Instale tamb\u00e9m o repo e rode o comando: $ repo init --depth=1 -u https://android.googlesource.com/platform/manifest -b android-10.0.0_r25 Clone o reposit\u00f3rio com as configura\u00e7\u00f5es da Raspberry para Android: $ git clone https://github.com/csimmonds/a4rpi-local-manifest .repo/local_manifests -b android10 Tip Para aumentar a velocidade de instala\u00e7\u00e3o use o argumento -c (branch atual) e -j threadcount $ repo sync -c j8 Warning Pausa para caf\u00e9, esta etapa demora cerca de 1- 2 horas. Configurando o U-boot \u00b6 U-boot \u00e9 um bootloader Opens Source utilizado em sistemas de linux embarcados. Os comandos abaixo criam a nossa imagem boot que ser\u00e1 utilizada para carregar o Android. $ cd $ANDROID_BUILD_TOP/u-boot $ PATH=$HOME/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf/bin:$PATH $ export ARCH=arm $ export CROSS_COMPILE=arm-linux-gnueabihf- $ cp $ANDROID_BUILD_TOP/device/rpiorg/rpi3/u-boot/rpi_3_32b_android_defconfig configs $ make rpi_3_32b_android_defconfig $ make Compilando o kernel \u00b6 \u00c9 necess\u00e1rio compilar o Kernel que ser\u00e1 respons\u00e1vel pela cria\u00e7\u00e3o do Android. Tamb\u00e9m \u00e9 criada a parti\u00e7\u00e3o DTBS, device tree blob source , que \u00e9 respons\u00e1vel por disponibilizar a estrutura do hardware. Como Android pode ser utilizado em dispositivos diferentes, Device Tree Overlays (DTOs) s\u00e3o necess\u00e1rios para mapear o hardware para o sistema. Rode os comandos: $ PATH=$HOME/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf/bin:$PATH $ export ARCH=arm $ export CROSS_COMPILE=arm-linux-gnueabihf- $ cd $ANDROID_BUILD_TOP/kernel/rpi $ scripts/kconfig/merge_config.sh arch/arm/configs/bcm2709_defconfig \\ kernel/configs/android-base.config kernel/configs/android-recommended.config $ make -j $(nproc) zImage $ cp arch/arm/boot/zImage $ANDROID_BUILD_TOP/device/rpiorg/rpi3 $ make dtbs $ croot Compilando o Android \u00b6 Com as imagens criadas anteriormente (zImage, boot e dtbs), agora temos tudo pronto para compilar o Android em si. Para isso, \u00e9 necess\u00e1rio configurar as vari\u00e1veis de ambiente e fazer a montagem. $ source build/envsetup.sh $ lunch aosp_rpi3-eng $ m Warning Esta etapa pode demorar em torno de 2 horas. A explica\u00e7\u00e3o dos comandos utilizadas pode ser encontrada aqui . \u00c9 criado as imagens VendorImage , SystemImage e UserData que posteriormente ser\u00e3o escritas no cart\u00e3o de mem\u00f3ria. SD Card \u00b6 A \u00faltima etapa \u00e9 criar as parti\u00e7\u00f5es e passar as imagens criadas no passo anterior para parti\u00e7\u00f5es no SD card, que s\u00e3o elas: Vendor: Drivers que conectam hardware e software; System: Sistema Android; UserData: Usado para resetar as configura\u00e7\u00f5es; Boot: Arquivos de inicializa\u00e7\u00e3o, como os DTOs e configura\u00e7\u00f5es do Uboot. Warning Caso voc\u00ea tenha feito as etapas anteriores em uma inst\u00e2ncia virtual, siga os passos abaixo, caso contr\u00e1rio, siga para a etapa Instalando Android localmente . Instalando Android na nuvem \u00b6 Como n\u00e3o \u00e9 poss\u00edvel conectar um cart\u00e3o SD diretamente em uma inst\u00e2ncia na nuvem, deve ser criado uma parti\u00e7\u00e3o virtual para simular um cart\u00e3o SD. Primeiro, \u00e9 necess\u00e1rio criar uma imagem vazia com o tamanho dispon\u00edvel do seu cart\u00e3o SD. $ dd if = /dev/zero of = zero.img bs = 4M count = 1536 Com isso, criaremos a parti\u00e7\u00e3o virtual a partir dessa imagem: $ sudo losetup -P -f --show zero.img Ao t\u00e9rmino do comando, a sua sa\u00edda ser\u00e1 o nome da sua parti\u00e7\u00e3o virtual. No nosso caso, obtivemos loop6 . Dentro da pasta do Android, modifique o arquivo /scripts/write-sdcard-rpi3.sh, alterando mmcblk0 para o nome da sua parti\u00e7\u00e3o virtual. ... # Unmount any partitions that have been automounted if [ $DRIVE == \"loop6\" ] ; then sudo umount /dev/ ${ DRIVE } * BOOT_PART = /dev/ ${ DRIVE } p1 SYSTEM_PART = /dev/ ${ DRIVE } p3 VENDOR_PART = /dev/ ${ DRIVE } p4 USER_PART = /dev/ ${ DRIVE } p5 else sudo umount /dev/ ${ DRIVE } [ 1 -9 ] BOOT_PART = /dev/ ${ DRIVE } 1 SYSTEM_PART = /dev/ ${ DRIVE } 3 VENDOR_PART = /dev/ ${ DRIVE } 4 USER_PART = /dev/ ${ DRIVE } 5 fi ... Fa\u00e7a um dd para transformar o Android instalado na parti\u00e7\u00e3o virtual em uma imagem. $ dd if = /dev/loop6 of = android.img bs = 4M Tip Mais uma vez, troque loop6 pelo nome de sua parti\u00e7\u00e3o virtual. Existem v\u00e1rias maneiras para transferir arquivos de uma inst\u00e2ncia virtual para outra m\u00e1quina, indicamos utilizar Secure Copy Protocol (SCP). Na sua m\u00e1quina, de posse da key utilizada na inst\u00e2ncia, basta rodar o comando abaixo: $ scp -i <chave_de_acesso> ubuntu@<ip_maquina>:/home/ubuntu/android.img . Tip Note que /home/ubuntu/android.img \u00e9 o nosso path da imagem criada pelo dd , mude para o seu path correspondente. Warning Essa etapa pode demorar em torno de 10 minutos dependendo da sua conex\u00e3o. O \u00faltimo passo \u00e9 transferir o arquivo android.img , que foi copiado para a sua m\u00e1quina, para o SD card. Para isso, insira o cart\u00e3o de mem\u00f3ria e utilize o comando lsblk para saber o nome do seu dispositivo e rode: $ dd if = android.img of = /dev/<nome_SDcard> bs = 4M Instalando Android localmente \u00b6 Nota Este t\u00f3pico s\u00f3 deve ser realizado se voc\u00ea est\u00e1 fazendo localmente. Insira o SD Card no seu computador e use comando lsblk para saber o nome do dispositivo. No exemplo abaixo, o nome do dispositivo \u00e9 sdc . Agora, para instalar o Android no SD Card \u00e9 necess\u00e1rio rodar o comando na pasta root do projeto: $ scripts/write-sdcard-rpi3.sh <nome_SDcard> Rodando Android na Raspberry \u00b6 Ao inserir o SD Card na Raspberry e conect\u00e1-la \u00e0 uma fonte de energia via cabo Micro USB, se tudo foi feito corretamente, o Android deve inicializar, podendo ser observado ao conectar uma da sa\u00edda de v\u00eddeo (HDMI), como visto abaixo: Pronto! Voc\u00ea tem um Andoid rodando em uma Raspberry Pi. Para utiliza\u00e7\u00e3o completa dos recursos disponibilizados pelo Android, o usu\u00e1rio pode optar por utilizar um mouse com entrada USB ou at\u00e9 mesmo uma tela touch, ambos conectados diretamente na Raspberry.","title":"Android para Raspbery Pi 3"},{"location":"2020/Android/#android-para-raspbery-pi-3","text":"Alunes: Emanuelle Mo\u00e7o / Leonardo Mendes / Lucas Leal Curso: Engenharia da Computa\u00e7\u00e3o Semestre: 6 Contato: corsiferrao@gmail.com , emanuellesm@al.insper.edu.br , leonardomm4@al.insper.edu.br , lucaslv1@al.insper.edu.br Ano: 2020","title":"Android para Raspbery Pi 3"},{"location":"2020/Android/#comecando","text":"Para seguir esse tutorial \u00e9 necess\u00e1rio: Hardware Raspberry Pi 3 Micro SD Card de 8 GB ou maior Monitor com entrada Mouse Adaptador Micro SD para USB Cabo Micro USB Computador com pelo menos 150GB de armazenamento dispon\u00edvel Softwares Ubuntu 18.04 Refer\u00eancias: device_brcm_rpi3 , Build Android for Raspberry Pi3 , Building Android for Raspberry Pi","title":"Come\u00e7ando"},{"location":"2020/Android/#motivacao","text":"A motiva\u00e7\u00e3o inicial era compilar Android em uma FPGA e o tema foi escolhido pois o grupo tinha o desejo de compilar um software de alto n\u00edvel em uma placa de desenvolvimento. Entretanto, por dificuldades t\u00e9cnicas, foi decidido migrar para uma Raspberry Pi, que por ser mais barata e acess\u00edvel ao p\u00fablico, existe uma quantidade significativa de refer\u00eancias, viabilizando a cria\u00e7\u00e3o de aplica\u00e7\u00f5es.","title":"Motiva\u00e7\u00e3o"},{"location":"2020/Android/#contexto","text":"O sistema operacional Android \u00e9 extremamente popular e muito presente em dispositivos mobile, presente em cerca de 70% de celulares no mundo. Este tutorial consiste em embarcar o Android utilizando LineageOS, uma distribui\u00e7\u00e3o open source de Android, numa Raspberry Pi 3 B+.","title":"Contexto"},{"location":"2020/Android/#android","text":"Android \u00e9 um sistema operacional baseado no kernel do linux no qual \u00e9 poss\u00edvel compilar o seu pr\u00f3prio sistema para utilizar em um celular ou placas de desenvolvimento.","title":"Android"},{"location":"2020/Android/#raspberry-pi","text":"Raspberry Pi \u00e9 um microcomputador do estilo System On a Chip que permite fazer tudo que um computador faz com baixo custo. O modelo utilizado neste roteiro \u00e9 o Raspberry Pi 3 B+, a qual possui um processador 64-bit quad-core de 1.4GHz, dual-band wireless e bluetooth. Ou seja, adequada para aplica\u00e7\u00f5es de automa\u00e7\u00e3o e IOT.","title":"Raspberry Pi"},{"location":"2020/Android/#instalacao","text":"Warning Alguns dos passos exigem alto poder computacional, caso voc\u00ea n\u00e3o tenha uma m\u00e1quina com o armazenamento m\u00ednimo necess\u00e1rio ou com um bom processador, sugerimos a utiliza\u00e7\u00e3o de uma m\u00e1quina na nuvem. Sugest\u00e3o Para esse tutorial, utilizamos uma inst\u00e2ncia da AWS t2.2xlarge.","title":"Instala\u00e7\u00e3o"},{"location":"2020/Android/#configurando-o-ambiente","text":"Uma vez no Ubuntu 18.04, ser\u00e1 necess\u00e1rio a instala\u00e7\u00e3o de alguns pacotes ess\u00eanciais, para saber mais, entre na p\u00e1gina disponibilizada pelo Andoid . $ sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig openjdk-8-jdk gcc-arm-linux-gnueabihf libssl-dev python-mako Instale tamb\u00e9m o repo e rode o comando: $ repo init --depth=1 -u https://android.googlesource.com/platform/manifest -b android-10.0.0_r25 Clone o reposit\u00f3rio com as configura\u00e7\u00f5es da Raspberry para Android: $ git clone https://github.com/csimmonds/a4rpi-local-manifest .repo/local_manifests -b android10 Tip Para aumentar a velocidade de instala\u00e7\u00e3o use o argumento -c (branch atual) e -j threadcount $ repo sync -c j8 Warning Pausa para caf\u00e9, esta etapa demora cerca de 1- 2 horas.","title":"Configurando o ambiente"},{"location":"2020/Android/#configurando-o-u-boot","text":"U-boot \u00e9 um bootloader Opens Source utilizado em sistemas de linux embarcados. Os comandos abaixo criam a nossa imagem boot que ser\u00e1 utilizada para carregar o Android. $ cd $ANDROID_BUILD_TOP/u-boot $ PATH=$HOME/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf/bin:$PATH $ export ARCH=arm $ export CROSS_COMPILE=arm-linux-gnueabihf- $ cp $ANDROID_BUILD_TOP/device/rpiorg/rpi3/u-boot/rpi_3_32b_android_defconfig configs $ make rpi_3_32b_android_defconfig $ make","title":"Configurando o U-boot"},{"location":"2020/Android/#compilando-o-kernel","text":"\u00c9 necess\u00e1rio compilar o Kernel que ser\u00e1 respons\u00e1vel pela cria\u00e7\u00e3o do Android. Tamb\u00e9m \u00e9 criada a parti\u00e7\u00e3o DTBS, device tree blob source , que \u00e9 respons\u00e1vel por disponibilizar a estrutura do hardware. Como Android pode ser utilizado em dispositivos diferentes, Device Tree Overlays (DTOs) s\u00e3o necess\u00e1rios para mapear o hardware para o sistema. Rode os comandos: $ PATH=$HOME/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf/bin:$PATH $ export ARCH=arm $ export CROSS_COMPILE=arm-linux-gnueabihf- $ cd $ANDROID_BUILD_TOP/kernel/rpi $ scripts/kconfig/merge_config.sh arch/arm/configs/bcm2709_defconfig \\ kernel/configs/android-base.config kernel/configs/android-recommended.config $ make -j $(nproc) zImage $ cp arch/arm/boot/zImage $ANDROID_BUILD_TOP/device/rpiorg/rpi3 $ make dtbs $ croot","title":"Compilando o kernel"},{"location":"2020/Android/#compilando-o-android","text":"Com as imagens criadas anteriormente (zImage, boot e dtbs), agora temos tudo pronto para compilar o Android em si. Para isso, \u00e9 necess\u00e1rio configurar as vari\u00e1veis de ambiente e fazer a montagem. $ source build/envsetup.sh $ lunch aosp_rpi3-eng $ m Warning Esta etapa pode demorar em torno de 2 horas. A explica\u00e7\u00e3o dos comandos utilizadas pode ser encontrada aqui . \u00c9 criado as imagens VendorImage , SystemImage e UserData que posteriormente ser\u00e3o escritas no cart\u00e3o de mem\u00f3ria.","title":"Compilando o Android"},{"location":"2020/Android/#sd-card","text":"A \u00faltima etapa \u00e9 criar as parti\u00e7\u00f5es e passar as imagens criadas no passo anterior para parti\u00e7\u00f5es no SD card, que s\u00e3o elas: Vendor: Drivers que conectam hardware e software; System: Sistema Android; UserData: Usado para resetar as configura\u00e7\u00f5es; Boot: Arquivos de inicializa\u00e7\u00e3o, como os DTOs e configura\u00e7\u00f5es do Uboot. Warning Caso voc\u00ea tenha feito as etapas anteriores em uma inst\u00e2ncia virtual, siga os passos abaixo, caso contr\u00e1rio, siga para a etapa Instalando Android localmente .","title":"SD Card"},{"location":"2020/Android/#instalando-android-na-nuvem","text":"Como n\u00e3o \u00e9 poss\u00edvel conectar um cart\u00e3o SD diretamente em uma inst\u00e2ncia na nuvem, deve ser criado uma parti\u00e7\u00e3o virtual para simular um cart\u00e3o SD. Primeiro, \u00e9 necess\u00e1rio criar uma imagem vazia com o tamanho dispon\u00edvel do seu cart\u00e3o SD. $ dd if = /dev/zero of = zero.img bs = 4M count = 1536 Com isso, criaremos a parti\u00e7\u00e3o virtual a partir dessa imagem: $ sudo losetup -P -f --show zero.img Ao t\u00e9rmino do comando, a sua sa\u00edda ser\u00e1 o nome da sua parti\u00e7\u00e3o virtual. No nosso caso, obtivemos loop6 . Dentro da pasta do Android, modifique o arquivo /scripts/write-sdcard-rpi3.sh, alterando mmcblk0 para o nome da sua parti\u00e7\u00e3o virtual. ... # Unmount any partitions that have been automounted if [ $DRIVE == \"loop6\" ] ; then sudo umount /dev/ ${ DRIVE } * BOOT_PART = /dev/ ${ DRIVE } p1 SYSTEM_PART = /dev/ ${ DRIVE } p3 VENDOR_PART = /dev/ ${ DRIVE } p4 USER_PART = /dev/ ${ DRIVE } p5 else sudo umount /dev/ ${ DRIVE } [ 1 -9 ] BOOT_PART = /dev/ ${ DRIVE } 1 SYSTEM_PART = /dev/ ${ DRIVE } 3 VENDOR_PART = /dev/ ${ DRIVE } 4 USER_PART = /dev/ ${ DRIVE } 5 fi ... Fa\u00e7a um dd para transformar o Android instalado na parti\u00e7\u00e3o virtual em uma imagem. $ dd if = /dev/loop6 of = android.img bs = 4M Tip Mais uma vez, troque loop6 pelo nome de sua parti\u00e7\u00e3o virtual. Existem v\u00e1rias maneiras para transferir arquivos de uma inst\u00e2ncia virtual para outra m\u00e1quina, indicamos utilizar Secure Copy Protocol (SCP). Na sua m\u00e1quina, de posse da key utilizada na inst\u00e2ncia, basta rodar o comando abaixo: $ scp -i <chave_de_acesso> ubuntu@<ip_maquina>:/home/ubuntu/android.img . Tip Note que /home/ubuntu/android.img \u00e9 o nosso path da imagem criada pelo dd , mude para o seu path correspondente. Warning Essa etapa pode demorar em torno de 10 minutos dependendo da sua conex\u00e3o. O \u00faltimo passo \u00e9 transferir o arquivo android.img , que foi copiado para a sua m\u00e1quina, para o SD card. Para isso, insira o cart\u00e3o de mem\u00f3ria e utilize o comando lsblk para saber o nome do seu dispositivo e rode: $ dd if = android.img of = /dev/<nome_SDcard> bs = 4M","title":"Instalando Android na nuvem"},{"location":"2020/Android/#instalando-android-localmente","text":"Nota Este t\u00f3pico s\u00f3 deve ser realizado se voc\u00ea est\u00e1 fazendo localmente. Insira o SD Card no seu computador e use comando lsblk para saber o nome do dispositivo. No exemplo abaixo, o nome do dispositivo \u00e9 sdc . Agora, para instalar o Android no SD Card \u00e9 necess\u00e1rio rodar o comando na pasta root do projeto: $ scripts/write-sdcard-rpi3.sh <nome_SDcard>","title":"Instalando Android localmente"},{"location":"2020/Android/#rodando-android-na-raspberry","text":"Ao inserir o SD Card na Raspberry e conect\u00e1-la \u00e0 uma fonte de energia via cabo Micro USB, se tudo foi feito corretamente, o Android deve inicializar, podendo ser observado ao conectar uma da sa\u00edda de v\u00eddeo (HDMI), como visto abaixo: Pronto! Voc\u00ea tem um Andoid rodando em uma Raspberry Pi. Para utiliza\u00e7\u00e3o completa dos recursos disponibilizados pelo Android, o usu\u00e1rio pode optar por utilizar um mouse com entrada USB ou at\u00e9 mesmo uma tela touch, ambos conectados diretamente na Raspberry.","title":"Rodando Android na Raspberry"},{"location":"2020/PS3-Linux-Tutorial/","text":"PS3 Hack \u00b6 Alunes: Gabriel Monteiro / Guilherme Leite / Hugo Carl Curso: Engenharia da Computa\u00e7\u00e3o Semestre: 9 Contato: corsiferrao@gmail.com , guilhermepl3@al.insper.edu.br Ano: 2020 Info Original repo: https://github.com/guipleite/PS3-Linux-Tutorial Starting \u00b6 To follow this tutorial you will need: Hardware: PS3 (Jailbroken), USB Flash Drive, Keyboard, Mouse Software: A Linux distribution, we will be using Ubuntu Info If you need to Jailbreak your PS3 you can follow this tutorial: https://www.youtube.com/watch?v=q-06YPB18N4&t=12s&has_verified=1 Motivation \u00b6 Many people tend to buy new gaming consoles in their launch, meanig a large number of obsolete consoles are left unused the objective of this tutorial is to repurpose these old pieces of hardware by installing GNU/Linux enabliing them to be used for a vast number of applications. Linux on the PS3 \u00b6 The history of Linux in PlayStation started with researchers messing with ideas of using graphics processors to boost their computing powers for years. The main idea is that you can use the same power that is used to run heavy games to run nearly everything, including massive calculations like complicated mathematic models. The necessity of cheap hardware in a moment when supercomputers were very expensive created the plan to use PlayStations as cluster computers. This idea born in 2002 when Sony released a kit called Linux for the Playstation 2, making it easy to create applications using PS2. Things didn't go very well for the PS2 since they started to get unstable when used as clusters to process any kind of data. Only with the PS3 entering the scene in 2006 the applications started to get more interesting. PlayStations 3 have more powerful and stable hardware in comparison to PlayStation 2, and also Sony made available a feature called OtherOS, capable of booting Linux in an easy way. With this new piece of hardware, a lot of researches tried to work with PS3 in order to build supercomputers, like Gaurav Khanna at UMass Dartmouth, that built a cluster of PS3s to make a pure period simulation work on black holes and the United States Air Force that made a project with more than 1700 PS3s to process images of surveillance drones. Things didn't go very well for the PlayStations 3 also, because in March 2010 Sony removed the OtherOS feature due to security concerns. This pretty much ended the era of PlayStation supercomputers because when Sony blocked the use of the OtherOS they also blocked the access of the RSX Nvidia GPU chip, making unable to use any kind of hardware acceleration limiting the use of Linux in PS3s as only a regular not so much powerful computer. So the idea of making a PS3 boot a Linux kernel is possible but not so powerful or interesting if you want to play with more complex applications, but for any uses in general you can turn a PS3 into a fully functional PC as shown in this tutorial. Info If you want to know more about the history of PlayStations as supercomputers check out the link below: https://www.theverge.com/2019/12/3/20984028/playstation-supercomputer-ps3-umass-dartmouth-astrophysics-25th-anniversary Setting Up the PS3 and Booting from a Live Image \u00b6 To follow this part of the tutorial you will need: Download: REBUG 4.81.2 Linux package. https://mega.nz/#!tTBl3CxA!Zr4cqwmFUsfq_oZi89JZWKmJ1pJWXCV-o7WLH2IU09k Downgrade PS3 version \u00b6 In this part of the tutorial we need to install REBUG_4.81.2.PUP in the PS3, this file should be inside the downloaded archive. Note In order to downgrade the firmware of the PS3 you need to have the package Rebug Toolbox installed in the PS3. First of all you need to check in your device if it is possible to downgrade your firmware: Game Rebug Toolbox Utilities Toggle QA.Flag Enabled Game Rebug Toolbox System Information system Make sure the line PS3 System: Firmware [version] DEX contains DEX. In case the version of the firmware is CEX you will need to change the version. This following tutorial can be useful: https://www.youtube.com/watch?v=0YJBCl4PjCo&t=758s . After making sure your device match the downgrade requeriments you can proceed the tutorial. 1. In your computer: Plug in your empty USB stick in your PC and crate the folder PS3 . Inside of the PS3 folder create another folder UPDATE . Extract the file REBUG_4.81.2_D-REX_EMER_INIT_PS3UPDAT.PUP into your ../PS3/UPDATE folder. Warning Make sure your USB drive is formatted to FAT32 before extracting the file. If not you can do so by using the option format in any OS or by using a third-party format software like Rufus . 2. In your PS3: Plug your USB drive with the file .PUP file on it. Go to Settings System Update Update via Storage Media 4.81.2 PS3UPDAT.PUP . When the installation completes, check if the older version is installed correctly at: Settings System Settings System Information . Repartitioning PS3 Hard Drive \u00b6 In this section of the tutorial we will format our device in order to create a second partition to hold our Linux, so make sure you make a backup of all the data inside the PS3. Turn Off your PS3 and boot it in the Safe Mode . Press the PS Button (controller) and then go to: Restore PS3 System Yes . Note After finishing the reset you will notice a decrease in the PS3 storage space, this happens because the 4.81.2 update is a modified version of the system that creates a new partition when formated. Installing Petitboot \u00b6 1. In your computer: To install petitboot first delete the ../PS3 folder in the USB drive. In the downloaded archive you have 2 folders Petitboot NOR/ and Petitboot NAND/ you need to find out what architeture correspond correspond to your model of PS3 you can do so by checking your model number in this link: https://www.psdevwiki.com/ps3/SKU_Models (All Slim models are NOR). With this information copy the binary file inside the corect petitboot folder to your empty ../USB folder. 2. In your PS3: You can now plug the USB in your PS3 but first you will need to install again the Rebug Toolbox , aceess: Game Package Manager Install Package Files PS3 System Storage REBUG_TOOLBOX . With Rebug Toolbox installed: Game Rebug Toolbox Utilities Resize VFLASH/NAND Regions Yes . Reboot the PS3. Game Rebug Toolbox Utilities Install petitboot Yes . Reboot again. Installing Red Ribbon Linux \u00b6 After installing petitboot in our PS3 we basically installed OtherOS in the system creating the possibility to boot another OS inside the created partition on the PS3 Hard Drive so now we can proceed to install our Linux version. 1. In your computer: Delete again the file from the ../USB folder and extract the contents inside the red_ribbon_lxde_14.03.iso from the archive to the ../USB folder. Tip You can use Winrar to extract the contents from the .iso to the desired folder. Copy also the file create_hdd_region.sh from the archive to ../USB . 2. In your PS3: In this moment we will boot a live version of linux in the PS3 so you need to use a mouse and a keyboard in order to navigate in the Red Ribbon interface. Plug the USB Stick, the mouse and the keyboard into the PS3. Game Rebug Toolbox System Boot OtherOS Boot (LV1 patches: Use current) Yes . At this point you will be able to see the Petitboot screen with some boot options. Press ESC on the plugged keyboard, you should be able to access this Linux terminal. In the terminal execute: $ cd /tmp/petitboot/mnt/sda1/ (sda1 for NOR PS3 if you have a NAND PS3 replace sda1 for sdd1) $ ./create_hdd_region.sh $ exit $ petitboot Info If you are interested in compilating your own Linux Kernel, stop right here and jump to read the section \"Using buildroot for Cross-Compilation\", this tutorial did not achieve complete success, but shows some possible ways to start. Executing these commands will take you back to the Petitboot screen with the boot options, select with the keyboard the first one (Live) and press Enter . If everything goes right you will boot the live version of Red Ribbon Linux in the PS3. The live version of linux doesn't give full access to the system and format the system after a normal reboot so we still need to install the full version of linux into the system. At the Desktop click in the only icon Install Red Ribbon , it should open the installation screen. Select continent Select language Enter system's hostname Automatic partitioning Yes . Finish the installation process and press the upper right On/Off icon in the taskbar, you will be able to see the Logout Menu. When selecting the Boot GameOS option you will need to remove the USB Stick from the PS3 and you won't need to use it again to boot the linux because now it is installed inside the PS3 partition. If everything goes as planned you shoud be back to the PS3 main OS screen and be able to go back to Linux easily from OtherOS. Note After finishing the installation process you can update your old PS3 firmware version installed in the process back to a newer version if you want to. This change will not affect the new installed system. Using buildroot for Cross-Compilation \u00b6 Buildroot is a set of Makefiles and patches that simplifies and automates the process of building a complete and bootable Linux environment for an embedded system, while using cross-compilation to allow building for multiple target platforms on a single Linux-based development system. Buildroot can automatically build the required cross-compilation toolchain, create a root file system, compile a Linux kernel image, and generate a boot loader for the targeted embedded system, or it can perform any independent combination of these steps. For example, an already installed cross-compilation toolchain can be used independently, while Buildroot only creates the root file system. This means we can create compile a Linux enviroment that will run on the PS3 from our Desktop, this is great because now we don't need to rely on whatever packages, applications and configurations the pre-compiled distribution comes with. We will be using the petitboot--buildroot project wich is basically buildroot with updates to generate a bootable petitboot image. This is because the bootloader, wich is a progtam that loads the operating system into the working memory of a computer on start-up, is called petitboot and is not availabe on the original buildroot $ git clone https://github.com/glevand/petitboot--buildroot.git $ cd petitboot--buildroot Now we can configure what we want the buildroot to include in our own linux $ make menuconfig This command should bring up an interface like the one shown below that can be navigated using the arrow keys, Enter and Esc: Under Target options we need to change the Target Architecture to the one of the PS3, wich is big endian PowerPC64. After that you can press the Escape key twice to go back to the main menu and then enter the Kernel submenu. There we can select our kernel's verion or specify one to be downloaded. We will also set the Defconfig name as PS3 under the Kernel Configuration option, this will automatically set some configurations specific to the PS3. Also change the Kernel binary format to vmlinux and enable the Install kernel image to /boot in target option. You can also change options under System Configurations and Target packages to personalize your linux and also compile it with some additional programs such as Python or even some emulators. Finally we can compile it, fot that we will use the commands bellow, the clean argument is important if you've alredy tried to compile the os before since it will delete the files generated from previous attempts. The -j 8 argument means the compiller will use 8 threads from the CPU to compile everything, you can change that value depending on your hardware, the more threads you give the compiller the faster the processing will be. $ make clean $ make all -j 8 The compiled Filesystem and kernel will be in /output/images/ .Inside there, we can find this three outputs: rootfs.tar: This is just our Linux Filesystem vmlinux: This archive can be found in the /output/images folder like the others or already inside the /rootfs/boot/. This is essentially our kernel . rootfs.cpio.gz: This archive relates to the initial ramdisk for our filesystem. This stands for a temporary root file system that will load in memory to help the Linux startup process. Now, to finalize we need to copy all this to the PS3. First we will put everything in a pen drive and plug in. At the PS3 shell, we should find the pendrive content in the path /tmp/petitboot/mnt/sda(this name can variate)/. First we need to mount where our linux will be located. mkfs.ext4 -m 0 /dev/ps3dd2 mkswap /dev/ps3dd1 mkdir linux mount /dev/ps3dd2 /linux Now we should tar our file system into /dev/ps3dd2 which is mounted at /linux. tar xvf /tmp/petitboot/mnt/sda/rootfs.tar -C /linux We now have our file system properly ready to go. We are only left with the initial ramdisk image and possibly the kernel to finalize. cp /tmp/petitboot/mnt/sda/rootfs.cpio.gz /linux/boot Warning Check first if the /linux/boot doesn't already have the vmlinux(kernel) inside before executing the next command. cp /tmp/petiboot/mnt/sda/vmlinux /linux/boot Nice, we should have all set to boot our linux right? Yeah kind of.... If you followed our advice, you know that we didn't succeed in this last attempt and here where things went wrong. To boot our own cross-compiled kernel we needed to only execute the next line: kexec -l /linux/boot/vmlinux --initrd=/linux/boot/rootfs.cpio.gz --append=\"root=/dev/ps3dd2\" Kexec is the bootloader which petitboot is based on. But this didn't work out for us. So now you can choose between searching on how to make it work, or install an already stable distro for the ps3 called Red Ribbon that you saw in the first part of this tutorial. If you are a thrilled to make this work, we recommend Ren\u00e9 Rebe works to follow on: https://www.youtube.com/user/renerebe https://rene.rebe.de/?s=ps3 http://t2sde.org/hardware/console/Sony/PS3/","title":"PS3 Hack"},{"location":"2020/PS3-Linux-Tutorial/#ps3-hack","text":"Alunes: Gabriel Monteiro / Guilherme Leite / Hugo Carl Curso: Engenharia da Computa\u00e7\u00e3o Semestre: 9 Contato: corsiferrao@gmail.com , guilhermepl3@al.insper.edu.br Ano: 2020 Info Original repo: https://github.com/guipleite/PS3-Linux-Tutorial","title":"PS3 Hack"},{"location":"2020/PS3-Linux-Tutorial/#starting","text":"To follow this tutorial you will need: Hardware: PS3 (Jailbroken), USB Flash Drive, Keyboard, Mouse Software: A Linux distribution, we will be using Ubuntu Info If you need to Jailbreak your PS3 you can follow this tutorial: https://www.youtube.com/watch?v=q-06YPB18N4&t=12s&has_verified=1","title":"Starting"},{"location":"2020/PS3-Linux-Tutorial/#motivation","text":"Many people tend to buy new gaming consoles in their launch, meanig a large number of obsolete consoles are left unused the objective of this tutorial is to repurpose these old pieces of hardware by installing GNU/Linux enabliing them to be used for a vast number of applications.","title":"Motivation"},{"location":"2020/PS3-Linux-Tutorial/#linux-on-the-ps3","text":"The history of Linux in PlayStation started with researchers messing with ideas of using graphics processors to boost their computing powers for years. The main idea is that you can use the same power that is used to run heavy games to run nearly everything, including massive calculations like complicated mathematic models. The necessity of cheap hardware in a moment when supercomputers were very expensive created the plan to use PlayStations as cluster computers. This idea born in 2002 when Sony released a kit called Linux for the Playstation 2, making it easy to create applications using PS2. Things didn't go very well for the PS2 since they started to get unstable when used as clusters to process any kind of data. Only with the PS3 entering the scene in 2006 the applications started to get more interesting. PlayStations 3 have more powerful and stable hardware in comparison to PlayStation 2, and also Sony made available a feature called OtherOS, capable of booting Linux in an easy way. With this new piece of hardware, a lot of researches tried to work with PS3 in order to build supercomputers, like Gaurav Khanna at UMass Dartmouth, that built a cluster of PS3s to make a pure period simulation work on black holes and the United States Air Force that made a project with more than 1700 PS3s to process images of surveillance drones. Things didn't go very well for the PlayStations 3 also, because in March 2010 Sony removed the OtherOS feature due to security concerns. This pretty much ended the era of PlayStation supercomputers because when Sony blocked the use of the OtherOS they also blocked the access of the RSX Nvidia GPU chip, making unable to use any kind of hardware acceleration limiting the use of Linux in PS3s as only a regular not so much powerful computer. So the idea of making a PS3 boot a Linux kernel is possible but not so powerful or interesting if you want to play with more complex applications, but for any uses in general you can turn a PS3 into a fully functional PC as shown in this tutorial. Info If you want to know more about the history of PlayStations as supercomputers check out the link below: https://www.theverge.com/2019/12/3/20984028/playstation-supercomputer-ps3-umass-dartmouth-astrophysics-25th-anniversary","title":"Linux on the PS3"},{"location":"2020/PS3-Linux-Tutorial/#setting-up-the-ps3-and-booting-from-a-live-image","text":"To follow this part of the tutorial you will need: Download: REBUG 4.81.2 Linux package. https://mega.nz/#!tTBl3CxA!Zr4cqwmFUsfq_oZi89JZWKmJ1pJWXCV-o7WLH2IU09k","title":"Setting Up the PS3 and Booting from a Live Image"},{"location":"2020/PS3-Linux-Tutorial/#downgrade-ps3-version","text":"In this part of the tutorial we need to install REBUG_4.81.2.PUP in the PS3, this file should be inside the downloaded archive. Note In order to downgrade the firmware of the PS3 you need to have the package Rebug Toolbox installed in the PS3. First of all you need to check in your device if it is possible to downgrade your firmware: Game Rebug Toolbox Utilities Toggle QA.Flag Enabled Game Rebug Toolbox System Information system Make sure the line PS3 System: Firmware [version] DEX contains DEX. In case the version of the firmware is CEX you will need to change the version. This following tutorial can be useful: https://www.youtube.com/watch?v=0YJBCl4PjCo&t=758s . After making sure your device match the downgrade requeriments you can proceed the tutorial. 1. In your computer: Plug in your empty USB stick in your PC and crate the folder PS3 . Inside of the PS3 folder create another folder UPDATE . Extract the file REBUG_4.81.2_D-REX_EMER_INIT_PS3UPDAT.PUP into your ../PS3/UPDATE folder. Warning Make sure your USB drive is formatted to FAT32 before extracting the file. If not you can do so by using the option format in any OS or by using a third-party format software like Rufus . 2. In your PS3: Plug your USB drive with the file .PUP file on it. Go to Settings System Update Update via Storage Media 4.81.2 PS3UPDAT.PUP . When the installation completes, check if the older version is installed correctly at: Settings System Settings System Information .","title":"Downgrade PS3 version"},{"location":"2020/PS3-Linux-Tutorial/#repartitioning-ps3-hard-drive","text":"In this section of the tutorial we will format our device in order to create a second partition to hold our Linux, so make sure you make a backup of all the data inside the PS3. Turn Off your PS3 and boot it in the Safe Mode . Press the PS Button (controller) and then go to: Restore PS3 System Yes . Note After finishing the reset you will notice a decrease in the PS3 storage space, this happens because the 4.81.2 update is a modified version of the system that creates a new partition when formated.","title":"Repartitioning PS3 Hard Drive"},{"location":"2020/PS3-Linux-Tutorial/#installing-petitboot","text":"1. In your computer: To install petitboot first delete the ../PS3 folder in the USB drive. In the downloaded archive you have 2 folders Petitboot NOR/ and Petitboot NAND/ you need to find out what architeture correspond correspond to your model of PS3 you can do so by checking your model number in this link: https://www.psdevwiki.com/ps3/SKU_Models (All Slim models are NOR). With this information copy the binary file inside the corect petitboot folder to your empty ../USB folder. 2. In your PS3: You can now plug the USB in your PS3 but first you will need to install again the Rebug Toolbox , aceess: Game Package Manager Install Package Files PS3 System Storage REBUG_TOOLBOX . With Rebug Toolbox installed: Game Rebug Toolbox Utilities Resize VFLASH/NAND Regions Yes . Reboot the PS3. Game Rebug Toolbox Utilities Install petitboot Yes . Reboot again.","title":"Installing Petitboot"},{"location":"2020/PS3-Linux-Tutorial/#installing-red-ribbon-linux","text":"After installing petitboot in our PS3 we basically installed OtherOS in the system creating the possibility to boot another OS inside the created partition on the PS3 Hard Drive so now we can proceed to install our Linux version. 1. In your computer: Delete again the file from the ../USB folder and extract the contents inside the red_ribbon_lxde_14.03.iso from the archive to the ../USB folder. Tip You can use Winrar to extract the contents from the .iso to the desired folder. Copy also the file create_hdd_region.sh from the archive to ../USB . 2. In your PS3: In this moment we will boot a live version of linux in the PS3 so you need to use a mouse and a keyboard in order to navigate in the Red Ribbon interface. Plug the USB Stick, the mouse and the keyboard into the PS3. Game Rebug Toolbox System Boot OtherOS Boot (LV1 patches: Use current) Yes . At this point you will be able to see the Petitboot screen with some boot options. Press ESC on the plugged keyboard, you should be able to access this Linux terminal. In the terminal execute: $ cd /tmp/petitboot/mnt/sda1/ (sda1 for NOR PS3 if you have a NAND PS3 replace sda1 for sdd1) $ ./create_hdd_region.sh $ exit $ petitboot Info If you are interested in compilating your own Linux Kernel, stop right here and jump to read the section \"Using buildroot for Cross-Compilation\", this tutorial did not achieve complete success, but shows some possible ways to start. Executing these commands will take you back to the Petitboot screen with the boot options, select with the keyboard the first one (Live) and press Enter . If everything goes right you will boot the live version of Red Ribbon Linux in the PS3. The live version of linux doesn't give full access to the system and format the system after a normal reboot so we still need to install the full version of linux into the system. At the Desktop click in the only icon Install Red Ribbon , it should open the installation screen. Select continent Select language Enter system's hostname Automatic partitioning Yes . Finish the installation process and press the upper right On/Off icon in the taskbar, you will be able to see the Logout Menu. When selecting the Boot GameOS option you will need to remove the USB Stick from the PS3 and you won't need to use it again to boot the linux because now it is installed inside the PS3 partition. If everything goes as planned you shoud be back to the PS3 main OS screen and be able to go back to Linux easily from OtherOS. Note After finishing the installation process you can update your old PS3 firmware version installed in the process back to a newer version if you want to. This change will not affect the new installed system.","title":"Installing Red Ribbon Linux"},{"location":"2020/PS3-Linux-Tutorial/#using-buildroot-for-cross-compilation","text":"Buildroot is a set of Makefiles and patches that simplifies and automates the process of building a complete and bootable Linux environment for an embedded system, while using cross-compilation to allow building for multiple target platforms on a single Linux-based development system. Buildroot can automatically build the required cross-compilation toolchain, create a root file system, compile a Linux kernel image, and generate a boot loader for the targeted embedded system, or it can perform any independent combination of these steps. For example, an already installed cross-compilation toolchain can be used independently, while Buildroot only creates the root file system. This means we can create compile a Linux enviroment that will run on the PS3 from our Desktop, this is great because now we don't need to rely on whatever packages, applications and configurations the pre-compiled distribution comes with. We will be using the petitboot--buildroot project wich is basically buildroot with updates to generate a bootable petitboot image. This is because the bootloader, wich is a progtam that loads the operating system into the working memory of a computer on start-up, is called petitboot and is not availabe on the original buildroot $ git clone https://github.com/glevand/petitboot--buildroot.git $ cd petitboot--buildroot Now we can configure what we want the buildroot to include in our own linux $ make menuconfig This command should bring up an interface like the one shown below that can be navigated using the arrow keys, Enter and Esc: Under Target options we need to change the Target Architecture to the one of the PS3, wich is big endian PowerPC64. After that you can press the Escape key twice to go back to the main menu and then enter the Kernel submenu. There we can select our kernel's verion or specify one to be downloaded. We will also set the Defconfig name as PS3 under the Kernel Configuration option, this will automatically set some configurations specific to the PS3. Also change the Kernel binary format to vmlinux and enable the Install kernel image to /boot in target option. You can also change options under System Configurations and Target packages to personalize your linux and also compile it with some additional programs such as Python or even some emulators. Finally we can compile it, fot that we will use the commands bellow, the clean argument is important if you've alredy tried to compile the os before since it will delete the files generated from previous attempts. The -j 8 argument means the compiller will use 8 threads from the CPU to compile everything, you can change that value depending on your hardware, the more threads you give the compiller the faster the processing will be. $ make clean $ make all -j 8 The compiled Filesystem and kernel will be in /output/images/ .Inside there, we can find this three outputs: rootfs.tar: This is just our Linux Filesystem vmlinux: This archive can be found in the /output/images folder like the others or already inside the /rootfs/boot/. This is essentially our kernel . rootfs.cpio.gz: This archive relates to the initial ramdisk for our filesystem. This stands for a temporary root file system that will load in memory to help the Linux startup process. Now, to finalize we need to copy all this to the PS3. First we will put everything in a pen drive and plug in. At the PS3 shell, we should find the pendrive content in the path /tmp/petitboot/mnt/sda(this name can variate)/. First we need to mount where our linux will be located. mkfs.ext4 -m 0 /dev/ps3dd2 mkswap /dev/ps3dd1 mkdir linux mount /dev/ps3dd2 /linux Now we should tar our file system into /dev/ps3dd2 which is mounted at /linux. tar xvf /tmp/petitboot/mnt/sda/rootfs.tar -C /linux We now have our file system properly ready to go. We are only left with the initial ramdisk image and possibly the kernel to finalize. cp /tmp/petitboot/mnt/sda/rootfs.cpio.gz /linux/boot Warning Check first if the /linux/boot doesn't already have the vmlinux(kernel) inside before executing the next command. cp /tmp/petiboot/mnt/sda/vmlinux /linux/boot Nice, we should have all set to boot our linux right? Yeah kind of.... If you followed our advice, you know that we didn't succeed in this last attempt and here where things went wrong. To boot our own cross-compiled kernel we needed to only execute the next line: kexec -l /linux/boot/vmlinux --initrd=/linux/boot/rootfs.cpio.gz --append=\"root=/dev/ps3dd2\" Kexec is the bootloader which petitboot is based on. But this didn't work out for us. So now you can choose between searching on how to make it work, or install an already stable distro for the ps3 called Red Ribbon that you saw in the first part of this tutorial. If you are a thrilled to make this work, we recommend Ren\u00e9 Rebe works to follow on: https://www.youtube.com/user/renerebe https://rene.rebe.de/?s=ps3 http://t2sde.org/hardware/console/Sony/PS3/","title":"Using buildroot for Cross-Compilation"}]}